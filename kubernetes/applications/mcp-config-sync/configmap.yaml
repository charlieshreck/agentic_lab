---
apiVersion: v1
kind: ConfigMap
metadata:
  name: mcp-config-sync
  namespace: ai-platform
  labels:
    app: mcp-config-sync
data:
  # Lightweight webhook receiver for MCP config sync
  # Triggered by GitHub webhook on push to .mcp.json
  main.py: |
    #!/usr/bin/env python3
    """
    MCP Config Sync Webhook Receiver

    Receives GitHub webhooks and triggers config regeneration when .mcp.json changes.
    """
    import os
    import hmac
    import hashlib
    import json
    import subprocess
    from datetime import datetime
    from typing import Dict, Any

    from fastapi import FastAPI, Request, HTTPException, BackgroundTasks

    app = FastAPI(title="MCP Config Sync", version="1.0.0")

    # Configuration
    WEBHOOK_SECRET = os.environ.get("GITHUB_WEBHOOK_SECRET", "")
    REPO_PATH = "/repo"
    KUBECONFIG = "/kubeconfig/config"
    NAMESPACE = "ai-platform"

    # Track sync status
    last_sync: Dict[str, Any] = {"timestamp": None, "status": None, "message": None, "triggered_by": None}

    def verify_github_signature(payload: bytes, signature: str) -> bool:
        """Verify GitHub webhook signature."""
        if not WEBHOOK_SECRET:
            return True  # Skip verification if no secret configured

        expected = "sha256=" + hmac.new(
            WEBHOOK_SECRET.encode(),
            payload,
            hashlib.sha256
        ).hexdigest()

        return hmac.compare_digest(expected, signature)

    def run_sync(triggered_by: str = "manual"):
        """Run the MCP config sync."""
        global last_sync

        try:
            # Pull latest changes
            result = subprocess.run(
                ["git", "pull", "--ff-only"],
                cwd=REPO_PATH,
                capture_output=True,
                text=True,
                timeout=60
            )

            if result.returncode != 0:
                raise Exception(f"Git pull failed: {result.stderr}")

            # Regenerate ConfigMap using external script
            result = subprocess.run(
                ["python3", "/app/generate_configmap.py"],
                capture_output=True,
                text=True,
                timeout=30
            )

            if result.returncode != 0:
                raise Exception(f"ConfigMap generation failed: {result.stderr}")

            # Apply ConfigMap
            result = subprocess.run(
                ["kubectl", "--kubeconfig", KUBECONFIG, "apply", "-f", "/tmp/mcp-servers-config.yaml"],
                capture_output=True,
                text=True,
                timeout=30
            )

            if result.returncode != 0:
                raise Exception(f"kubectl apply failed: {result.stderr}")

            # Restart deployments to pick up new config
            for deployment in ["claude-agent", "langgraph"]:
                subprocess.run(
                    ["kubectl", "--kubeconfig", KUBECONFIG, "rollout", "restart",
                     f"deployment/{deployment}", "-n", NAMESPACE],
                    capture_output=True,
                    timeout=30
                )

            # Count servers from output
            server_count = result.stdout.count("_MCP_URL") if result.stdout else 0

            last_sync = {
                "timestamp": datetime.utcnow().isoformat() + "Z",
                "status": "success",
                "message": f"Synced MCP config, restarted deployments",
                "triggered_by": triggered_by
            }

            print(f"[Sync] Success: {last_sync['message']}")

        except Exception as e:
            last_sync = {
                "timestamp": datetime.utcnow().isoformat() + "Z",
                "status": "error",
                "message": str(e),
                "triggered_by": triggered_by
            }
            print(f"[Sync] Error: {e}")

    @app.get("/health")
    async def health():
        return {"status": "healthy", "last_sync": last_sync}

    @app.get("/status")
    async def status():
        """Get current sync status and ConfigMap info."""
        try:
            result = subprocess.run(
                ["kubectl", "--kubeconfig", KUBECONFIG, "get", "configmap",
                 "mcp-servers-config", "-n", NAMESPACE, "-o", "json"],
                capture_output=True,
                text=True,
                timeout=10
            )
            if result.returncode == 0:
                cm = json.loads(result.stdout)
                server_count = len([k for k in cm.get("data", {}).keys() if k.endswith("_MCP_URL")])
                return {
                    "configmap_exists": True,
                    "server_count": server_count,
                    "generated_at": cm.get("metadata", {}).get("annotations", {}).get("generated-at"),
                    "last_sync": last_sync
                }
        except Exception:
            pass

        return {"configmap_exists": False, "last_sync": last_sync}

    @app.post("/webhook/github")
    async def github_webhook(request: Request, background_tasks: BackgroundTasks):
        """Handle GitHub push webhooks."""
        # Verify signature
        signature = request.headers.get("X-Hub-Signature-256", "")
        payload = await request.body()

        if not verify_github_signature(payload, signature):
            raise HTTPException(status_code=401, detail="Invalid signature")

        # Parse payload
        try:
            data = json.loads(payload)
        except Exception:
            raise HTTPException(status_code=400, detail="Invalid JSON")

        # Check if .mcp.json was modified
        event = request.headers.get("X-GitHub-Event", "")

        if event == "push":
            # Check commits for .mcp.json changes
            mcp_changed = False
            for commit in data.get("commits", []):
                files = commit.get("added", []) + commit.get("modified", [])
                if ".mcp.json" in files:
                    mcp_changed = True
                    break

            if mcp_changed:
                print("[Webhook] .mcp.json changed, triggering sync...")
                background_tasks.add_task(run_sync, f"github-push:{data.get('after', '')[:7]}")
                return {"status": "sync_triggered", "reason": ".mcp.json changed"}
            else:
                return {"status": "ignored", "reason": ".mcp.json not in changed files"}

        elif event == "ping":
            return {"status": "pong"}

        return {"status": "ignored", "event": event}

    @app.post("/sync")
    async def manual_sync(background_tasks: BackgroundTasks):
        """Manually trigger a sync."""
        background_tasks.add_task(run_sync, "manual-api")
        return {"status": "sync_triggered"}

  generate_configmap.py: |
    #!/usr/bin/env python3
    """Generate Kubernetes ConfigMap from .mcp.json"""
    import json
    from datetime import datetime

    MCP_JSON = "/repo/.mcp.json"
    OUTPUT = "/tmp/mcp-servers-config.yaml"

    with open(MCP_JSON) as f:
        config = json.load(f)

    servers = config.get("mcpServers", {})

    timestamp = datetime.utcnow().isoformat() + "Z"

    yaml_lines = [
        "# AUTO-GENERATED by mcp-config-sync webhook",
        "apiVersion: v1",
        "kind: ConfigMap",
        "metadata:",
        "  name: mcp-servers-config",
        "  namespace: ai-platform",
        "  annotations:",
        f'    generated-at: "{timestamp}"',
        '    source: "webhook-sync"',
        "data:",
    ]

    for name, cfg in servers.items():
        env_name = name.upper().replace("-", "_") + "_MCP_URL"
        # Use internal Kubernetes service name
        internal_url = f"http://{name}-mcp:8000"
        yaml_lines.append(f'  {env_name}: "{internal_url}"')

    with open(OUTPUT, "w") as f:
        f.write("\n".join(yaml_lines) + "\n")

    print(f"Generated ConfigMap with {len(servers)} servers")

  requirements.txt: |
    fastapi>=0.109.0
    uvicorn[standard]>=0.27.0
    httpx>=0.26.0
    pydantic>=2.5.0
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: mcp-config-sync-scripts
  namespace: ai-platform
data:
  start.sh: |
    #!/bin/bash
    set -e

    echo "=== MCP Config Sync Startup ==="

    # Install system dependencies (git, kubectl, curl)
    echo "Installing system dependencies..."
    apt-get update -qq && apt-get install -y -qq git curl > /dev/null

    # Install kubectl
    echo "Installing kubectl..."
    cd /tmp
    curl -sLO "https://dl.k8s.io/release/$(curl -sL https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
    chmod +x kubectl
    mv kubectl /usr/local/bin/kubectl
    cd /app

    # Decode kubeconfig from base64
    if [ -f /kubeconfig-b64/KUBECONFIG_B64 ]; then
        echo "Decoding kubeconfig..."
        base64 -d /kubeconfig-b64/KUBECONFIG_B64 > /kubeconfig/config
        chmod 600 /kubeconfig/config
        export KUBECONFIG=/kubeconfig/config
        echo "Testing kubectl connectivity..."
        kubectl cluster-info --request-timeout=5s || echo "Warning: Cannot reach cluster"
    else
        echo "Warning: No kubeconfig found at /kubeconfig-b64/KUBECONFIG_B64"
    fi

    # Clone repo if not exists
    if [ ! -d /repo/.git ]; then
        echo "Cloning repository..."
        git clone --depth 1 https://github.com/charlieshreck/kernow-homelab.git /repo
    fi

    # Install Python dependencies
    echo "Installing Python dependencies..."
    pip install --no-cache-dir -r /app/requirements.txt > /dev/null

    echo "Starting webhook receiver..."
    exec uvicorn main:app --host 0.0.0.0 --port 8000
