---
apiVersion: v1
kind: ConfigMap
metadata:
  name: mcp-config-sync
  namespace: ai-platform
  labels:
    app: mcp-config-sync
data:
  # Lightweight webhook receiver for MCP config sync
  # Triggered by GitHub webhook on push to .mcp.json
  main.py: |
    #!/usr/bin/env python3
    """
    MCP Config Sync Webhook Receiver

    Receives GitHub webhooks and triggers config regeneration when .mcp.json changes.
    """
    import os
    import hmac
    import hashlib
    import json
    import subprocess
    from datetime import datetime
    from typing import Optional

    from fastapi import FastAPI, Request, HTTPException, BackgroundTasks
    from pydantic import BaseModel
    import httpx

    app = FastAPI(title="MCP Config Sync", version="1.0.0")

    # Configuration
    WEBHOOK_SECRET = os.environ.get("GITHUB_WEBHOOK_SECRET", "")
    REPO_PATH = "/repo"
    KUBECONFIG = "/kubeconfig/config"
    NAMESPACE = "ai-platform"

    # Track sync status
    last_sync = {"timestamp": None, "status": None, "message": None, "triggered_by": None}

    def verify_github_signature(payload: bytes, signature: str) -> bool:
        """Verify GitHub webhook signature."""
        if not WEBHOOK_SECRET:
            return True  # Skip verification if no secret configured

        expected = "sha256=" + hmac.new(
            WEBHOOK_SECRET.encode(),
            payload,
            hashlib.sha256
        ).hexdigest()

        return hmac.compare_digest(expected, signature)

    def run_sync(triggered_by: str = "manual"):
        """Run the MCP config sync."""
        global last_sync

        try:
            # Pull latest changes
            result = subprocess.run(
                ["git", "pull", "--ff-only"],
                cwd=REPO_PATH,
                capture_output=True,
                text=True,
                timeout=60
            )

            if result.returncode != 0:
                raise Exception(f"Git pull failed: {result.stderr}")

            # Regenerate ConfigMap
            result = subprocess.run(
                ["python3", "-c", """
import json
import os
from datetime import datetime

MCP_JSON = '/repo/.mcp.json'
OUTPUT = '/tmp/mcp-servers-config.yaml'

with open(MCP_JSON) as f:
    config = json.load(f)

servers = config.get('mcpServers', {})

yaml_content = '''# AUTO-GENERATED by mcp-config-sync webhook
apiVersion: v1
kind: ConfigMap
metadata:
  name: mcp-servers-config
  namespace: ai-platform
  annotations:
    generated-at: "{timestamp}"
    source: "webhook-sync"
data:
'''.format(timestamp=datetime.utcnow().isoformat() + 'Z')

for name, cfg in servers.items():
    url = cfg.get('url', '').replace('/mcp', '')
    env_name = name.upper().replace('-', '_') + '_MCP_URL'
    # Convert external URL to internal service name
    internal_url = f"http://{name}-mcp:8000"
    yaml_content += f'  {env_name}: "{internal_url}"\\n'

with open(OUTPUT, 'w') as f:
    f.write(yaml_content)

print(f"Generated ConfigMap with {len(servers)} servers")
"""],
                capture_output=True,
                text=True,
                timeout=30
            )

            if result.returncode != 0:
                raise Exception(f"ConfigMap generation failed: {result.stderr}")

            # Apply ConfigMap
            result = subprocess.run(
                ["kubectl", "--kubeconfig", KUBECONFIG, "apply", "-f", "/tmp/mcp-servers-config.yaml"],
                capture_output=True,
                text=True,
                timeout=30
            )

            if result.returncode != 0:
                raise Exception(f"kubectl apply failed: {result.stderr}")

            # Restart deployments to pick up new config
            for deployment in ["claude-agent", "langgraph"]:
                subprocess.run(
                    ["kubectl", "--kubeconfig", KUBECONFIG, "rollout", "restart",
                     f"deployment/{deployment}", "-n", NAMESPACE],
                    capture_output=True,
                    timeout=30
                )

            last_sync = {
                "timestamp": datetime.utcnow().isoformat() + "Z",
                "status": "success",
                "message": f"Synced {len(servers)} MCP servers, restarted deployments",
                "triggered_by": triggered_by
            }

            print(f"[Sync] Success: {last_sync['message']}")

        except Exception as e:
            last_sync = {
                "timestamp": datetime.utcnow().isoformat() + "Z",
                "status": "error",
                "message": str(e),
                "triggered_by": triggered_by
            }
            print(f"[Sync] Error: {e}")

    @app.get("/health")
    async def health():
        return {"status": "healthy", "last_sync": last_sync}

    @app.get("/status")
    async def status():
        """Get current sync status and ConfigMap info."""
        try:
            result = subprocess.run(
                ["kubectl", "--kubeconfig", KUBECONFIG, "get", "configmap",
                 "mcp-servers-config", "-n", NAMESPACE, "-o", "json"],
                capture_output=True,
                text=True,
                timeout=10
            )
            if result.returncode == 0:
                cm = json.loads(result.stdout)
                server_count = len([k for k in cm.get("data", {}).keys() if k.endswith("_MCP_URL")])
                return {
                    "configmap_exists": True,
                    "server_count": server_count,
                    "generated_at": cm.get("metadata", {}).get("annotations", {}).get("generated-at"),
                    "last_sync": last_sync
                }
        except:
            pass

        return {"configmap_exists": False, "last_sync": last_sync}

    @app.post("/webhook/github")
    async def github_webhook(request: Request, background_tasks: BackgroundTasks):
        """Handle GitHub push webhooks."""
        # Verify signature
        signature = request.headers.get("X-Hub-Signature-256", "")
        payload = await request.body()

        if not verify_github_signature(payload, signature):
            raise HTTPException(status_code=401, detail="Invalid signature")

        # Parse payload
        try:
            data = json.loads(payload)
        except:
            raise HTTPException(status_code=400, detail="Invalid JSON")

        # Check if .mcp.json was modified
        event = request.headers.get("X-GitHub-Event", "")

        if event == "push":
            # Check commits for .mcp.json changes
            mcp_changed = False
            for commit in data.get("commits", []):
                files = commit.get("added", []) + commit.get("modified", [])
                if ".mcp.json" in files:
                    mcp_changed = True
                    break

            if mcp_changed:
                print(f"[Webhook] .mcp.json changed, triggering sync...")
                background_tasks.add_task(run_sync, f"github-push:{data.get('after', '')[:7]}")
                return {"status": "sync_triggered", "reason": ".mcp.json changed"}
            else:
                return {"status": "ignored", "reason": ".mcp.json not in changed files"}

        elif event == "ping":
            return {"status": "pong"}

        return {"status": "ignored", "event": event}

    @app.post("/sync")
    async def manual_sync(background_tasks: BackgroundTasks):
        """Manually trigger a sync."""
        background_tasks.add_task(run_sync, "manual-api")
        return {"status": "sync_triggered"}

  requirements.txt: |
    fastapi>=0.109.0
    uvicorn[standard]>=0.27.0
    httpx>=0.26.0
    pydantic>=2.5.0
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: mcp-config-sync-scripts
  namespace: ai-platform
data:
  start.sh: |
    #!/bin/bash
    set -e

    echo "=== MCP Config Sync Startup ==="

    # Install system dependencies (git, kubectl, curl)
    echo "Installing system dependencies..."
    apt-get update -qq && apt-get install -y -qq git curl > /dev/null

    # Install kubectl
    echo "Installing kubectl..."
    curl -sLO "https://dl.k8s.io/release/$(curl -sL https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
    install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl
    rm kubectl

    # Decode kubeconfig from base64
    if [ -f /kubeconfig-b64/KUBECONFIG_B64 ]; then
        echo "Decoding kubeconfig..."
        base64 -d /kubeconfig-b64/KUBECONFIG_B64 > /kubeconfig/config
        chmod 600 /kubeconfig/config
        export KUBECONFIG=/kubeconfig/config
        echo "Testing kubectl connectivity..."
        kubectl cluster-info --request-timeout=5s || echo "Warning: Cannot reach cluster"
    else
        echo "Warning: No kubeconfig found at /kubeconfig-b64/KUBECONFIG_B64"
    fi

    # Clone repo if not exists
    if [ ! -d /repo/.git ]; then
        echo "Cloning repository..."
        git clone --depth 1 https://github.com/charlieshreck/kernow-homelab.git /repo
    fi

    # Install Python dependencies
    echo "Installing Python dependencies..."
    pip install --no-cache-dir -r /app/requirements.txt > /dev/null

    echo "Starting webhook receiver..."
    exec uvicorn main:app --host 0.0.0.0 --port 8000
