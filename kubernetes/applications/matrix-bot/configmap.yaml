apiVersion: v1
kind: ConfigMap
metadata:
  name: matrix-bot-code
  namespace: ai-platform
  labels:
    app: matrix-bot
    component: interaction-layer
data:
  bot.py: |
    """
    Agentic Platform Matrix Bot

    Provides conversational interface to the agentic platform via Matrix.
    Uses matrix-nio for Matrix protocol, integrates with LangGraph for Gemini.
    """
    import asyncio
    import json
    import os
    import logging
    from typing import Optional
    import httpx
    from nio import (
        AsyncClient,
        LoginResponse,
        RoomMessageText,
        ReactionEvent,
        InviteMemberEvent,
        JoinError,
    )
    from fastapi import FastAPI, BackgroundTasks, Request
    from pydantic import BaseModel
    import uvicorn
    from contextlib import asynccontextmanager

    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger(__name__)

    # Reduce noise from matrix-nio validation warnings
    logging.getLogger("nio.responses").setLevel(logging.ERROR)
    logging.getLogger("nio.client.async_client").setLevel(logging.ERROR)

    # Configuration from environment
    MATRIX_HOMESERVER = os.environ.get("MATRIX_HOMESERVER", "http://conduit:6167")
    MATRIX_USER_ID = os.environ.get("MATRIX_USER_ID", "@agentic-bot:agentic.local")
    MATRIX_PASSWORD = os.environ.get("MATRIX_PASSWORD", "")
    LANGGRAPH_URL = os.environ.get("LANGGRAPH_URL", "http://langgraph:8000")
    QDRANT_URL = os.environ.get("QDRANT_URL", "http://qdrant:6333")

    # Default room for alerts (can be overridden per alert)
    ALERT_ROOM_ID = os.environ.get("ALERT_ROOM_ID", "!alerts:agentic.local")

    class AgenticMatrixBot:
        def __init__(self):
            self.client = AsyncClient(MATRIX_HOMESERVER, MATRIX_USER_ID)
            self.conversations = {}  # room_id or thread_id -> conversation history
            self.http_client = httpx.AsyncClient(timeout=120.0)
            self.max_history = 20  # Keep last N messages per conversation
            self.startup_time = int(asyncio.get_event_loop().time() * 1000)  # ms timestamp
            import time
            self.startup_time = int(time.time() * 1000)  # Unix ms for comparison with event timestamps

        async def login(self):
            """Login to Matrix homeserver."""
            response = await self.client.login(MATRIX_PASSWORD)
            if isinstance(response, LoginResponse):
                logger.info(f"Logged in as {MATRIX_USER_ID}")
                return True
            else:
                logger.error(f"Login failed: {response}")
                return False

        async def setup_callbacks(self):
            """Register event callbacks."""
            self.client.add_event_callback(self.on_message, RoomMessageText)
            self.client.add_event_callback(self.on_reaction, ReactionEvent)
            self.client.add_event_callback(self.on_invite, InviteMemberEvent)

        async def on_invite(self, room, event):
            """Auto-join rooms when invited."""
            if event.membership == "invite":
                try:
                    # Use direct HTTP call for Conduit compatibility
                    # Conduit requires proper JSON body, nio sends empty body
                    url = f"{MATRIX_HOMESERVER}/_matrix/client/v3/join/{room.room_id}"
                    headers = {"Authorization": f"Bearer {self.client.access_token}"}
                    response = await self.http_client.post(url, headers=headers, json={})
                    if response.status_code == 200:
                        logger.info(f"Joined room {room.room_id}")
                    else:
                        logger.error(f"Failed to join {room.room_id}: {response.status_code} {response.text}")
                except Exception as e:
                    logger.error(f"Exception joining {room.room_id}: {e}")

        async def on_message(self, room, event):
            """Handle incoming messages."""
            try:
                # Ignore messages from before bot started (prevents replay on restart)
                event_time = event.server_timestamp
                if event_time < self.startup_time:
                    return

                logger.info(f"=== MESSAGE RECEIVED from {event.sender} ===")
                logger.info(f"Body: {event.body}")

                # Debug: log full event source to understand structure
                content = event.source.get("content", {})
                logger.info(f"Content keys: {list(content.keys())}")
                if "m.relates_to" in content:
                    logger.info(f"m.relates_to: {content.get('m.relates_to')}")

                # Ignore our own messages
                if event.sender == self.client.user_id:
                    logger.info("Ignoring own message")
                    return

                # Check if this is a reply to another message (user clicked "reply")
                relates_to = content.get("m.relates_to", {})
                reply_to = relates_to.get("m.in_reply_to", {}).get("event_id")

                if reply_to:
                    # User replied to a message - include that message as context
                    await self.handle_reply_with_context(room, event, reply_to)
                else:
                    await self.handle_command(room, event)
            except Exception as e:
                logger.error(f"Error in on_message: {e}")
                import traceback
                logger.error(traceback.format_exc())

        async def handle_command(self, room, event):
            """Handle messages in room - responds to triggers like 'g', 'gemini', etc."""
            import re
            message = event.body.strip()
            message_lower = message.lower()
            logger.info(f"Handling message: {message[:50]}")

            # Trigger patterns - bot responds to these prefixes
            triggers = [
                r'^g[,:\s]+',           # "g, ..." or "g: ..." or "g ..."
                r'^gemini[,:\s]+',      # "gemini, ..."
                r'^hey g[,:\s]*',       # "hey g, ..." or "hey g ..."
                r'^yo g[,:\s]*',        # "yo g ..."
                r'^ok g[,:\s]*',        # "ok g ..."
                r'^@[\w.-]+:[\w.-]+',   # @mentions
            ]

            # Check if message is addressed to us
            triggered = False
            query = message
            for pattern in triggers:
                match = re.match(pattern, message_lower)
                if match:
                    triggered = True
                    # Strip the trigger from the message
                    query = message[match.end():].strip()
                    break

            # Also strip any @mention that might be embedded
            query = re.sub(r'@[\w.-]+:[\w.-]+', '', query, flags=re.IGNORECASE).strip()

            if not triggered:
                logger.info("Message not addressed to bot, ignoring")
                return

            if not query:
                await self.send_message(room.room_id, "Yes?")
                return

            query_lower = query.lower()

            # Quick commands that don't need conversation context
            if query_lower in ["status", "what's happening", "what's happening?"]:
                logger.info("Status command detected")
                response = await self.get_platform_status()
                await self.send_message(room.room_id, response)
                return
            elif query_lower in ["what needs attention", "what needs attention?", "pending"]:
                logger.info("Pending command detected")
                response = await self.get_pending_items()
                await self.send_message(room.room_id, response)
                return
            elif query_lower in ["clear", "reset", "new conversation"]:
                self.conversations.pop(room.room_id, None)
                await self.send_message(room.room_id, "Conversation cleared. Starting fresh!")
                return

            # Get or create conversation history for this room
            conv_id = room.room_id
            history = self.conversations.get(conv_id, [])

            # Add user message to history
            history.append({"role": "user", "content": query})

            # Query Gemini with history
            response = await self.query_gemini(query, {}, history)

            # Add assistant response to history
            history.append({"role": "assistant", "content": response})

            # Trim history if too long
            if len(history) > self.max_history:
                history = history[-self.max_history:]
            self.conversations[conv_id] = history

            logger.info(f"Sending response: {response[:100] if response else 'None'}...")
            await self.send_message(room.room_id, response)

        async def handle_reply_with_context(self, room, event, reply_to_event_id):
            """Handle when user replies to a message - includes original as context."""
            import re
            logger.info(f"Reply detected to event: {reply_to_event_id}")

            # Get the original message being replied to (includes sender info)
            original_content, original_sender = await self.get_original_message(room.room_id, reply_to_event_id)

            # Extract user's actual message (Matrix replies include quoted text we need to strip)
            user_message = event.body
            # Matrix reply format: "> <@user:server> original message\n\nactual reply"
            if user_message.startswith(">"):
                # Find the actual reply after the quoted section
                parts = user_message.split("\n\n", 1)
                if len(parts) > 1:
                    user_message = parts[1].strip()

            # Check for trigger word in the reply
            message_lower = user_message.lower()
            triggers = [
                r'^g[,:\s]+',
                r'^gemini[,:\s]+',
                r'^hey g[,:\s]*',
                r'^yo g[,:\s]*',
                r'^ok g[,:\s]*',
            ]

            triggered = False
            query = user_message
            for pattern in triggers:
                match = re.match(pattern, message_lower)
                if match:
                    triggered = True
                    query = user_message[match.end():].strip()
                    break

            # Only respond if:
            # 1. User used a trigger word, OR
            # 2. User is replying to a bot message (alert response)
            is_reply_to_bot = original_sender == self.client.user_id

            if not triggered and not is_reply_to_bot:
                logger.info("Reply not addressed to bot and not replying to bot message, ignoring")
                return

            if not query:
                query = user_message  # Use full message if no trigger found

            # Build context with original message
            context_prompt = f"The user is replying to this message:\n\n---\n{original_content}\n---\n\nUser's reply: {query}"

            logger.info(f"Reply with context - Original: {original_content[:80] if original_content else 'None'}...")
            logger.info(f"User query: {query[:80]}...")

            # Query Gemini with the context
            response = await self.query_gemini(context_prompt, {"is_reply": True}, [])

            # Send response back to the room
            await self.send_message(room.room_id, response)

        async def on_reaction(self, room, event):
            """Handle reaction-based approvals."""
            if event.key == "\u2705":  # Checkmark
                thread_id = event.reacts_to
                await self.process_approval(room.room_id, thread_id, approved=True)
            elif event.key == "\u274c":  # X mark
                thread_id = event.reacts_to
                await self.process_approval(room.room_id, thread_id, approved=False)

        async def query_gemini(self, message: str, context: dict, history: list = None) -> str:
            """Query Gemini via LangGraph /query endpoint."""
            try:
                payload = {
                    "prompt": message,
                    "context": context or {},
                    "source": "matrix_bot",
                    "messages": history or []  # Send conversation history to LangGraph
                }
                response = await self.http_client.post(
                    f"{LANGGRAPH_URL}/query",
                    json=payload
                )
                if response.status_code == 200:
                    result = response.json()
                    return result.get("response", result.get("answer", "No response from Gemini"))
                else:
                    logger.error(f"Gemini query failed: {response.status_code} - {response.text}")
                    return f"Error querying Gemini: {response.status_code}"
            except Exception as e:
                logger.error(f"Error querying Gemini: {e}")
                return f"Error: {str(e)}"

        async def get_platform_status(self) -> str:
            """Get current platform status."""
            try:
                # Query LangGraph for status
                response = await self.http_client.get(f"{LANGGRAPH_URL}/health")
                langgraph_healthy = response.status_code == 200

                # Query Qdrant for pending items
                pending = await self.get_pending_count()

                status = "**Platform Status**\n\n"
                status += f"- LangGraph: {'Healthy' if langgraph_healthy else 'Unhealthy'}\n"
                status += f"- Pending approvals: {pending}\n"

                return status
            except Exception as e:
                return f"Error getting status: {e}"

        async def get_pending_items(self) -> str:
            """Get items pending approval."""
            try:
                response = await self.http_client.post(
                    f"{QDRANT_URL}/collections/validations/points/scroll",
                    json={
                        "filter": {
                            "must": [{"key": "status", "match": {"value": "pending"}}]
                        },
                        "limit": 10
                    }
                )
                if response.status_code == 200:
                    points = response.json().get("result", {}).get("points", [])
                    if not points:
                        return "No pending items."

                    items = []
                    for p in points:
                        payload = p.get("payload", {})
                        items.append(f"- [{payload.get('target_type')}] {payload.get('target_id')}")
                    return "**Pending Approvals**\n\n" + "\n".join(items)
                return "Could not fetch pending items."
            except Exception as e:
                return f"Error: {e}"

        async def get_pending_count(self) -> int:
            """Get count of pending items."""
            try:
                response = await self.http_client.post(
                    f"{QDRANT_URL}/collections/validations/points/count",
                    json={
                        "filter": {
                            "must": [{"key": "status", "match": {"value": "pending"}}]
                        }
                    }
                )
                if response.status_code == 200:
                    return response.json().get("result", {}).get("count", 0)
                return 0
            except:
                return 0

        async def get_thread_context(self, thread_id: str) -> dict:
            """Get context for a thread (incident details, etc)."""
            return {"thread_id": thread_id}

        async def get_original_message(self, room_id: str, event_id: str) -> tuple:
            """Fetch the original message content and sender."""
            try:
                # Use Matrix client API to get the event
                url = f"{MATRIX_HOMESERVER}/_matrix/client/v3/rooms/{room_id}/event/{event_id}"
                headers = {"Authorization": f"Bearer {self.client.access_token}"}
                response = await self.http_client.get(url, headers=headers)

                if response.status_code == 200:
                    event_data = response.json()
                    content = event_data.get("content", {})
                    sender = event_data.get("sender", "")
                    # Get plain text body
                    body = content.get("body", "")
                    logger.info(f"Fetched original message from {sender}: {body[:100]}...")
                    return body, sender
                else:
                    logger.warning(f"Failed to fetch event {event_id}: {response.status_code}")
                    return None, None
            except Exception as e:
                logger.error(f"Error fetching original message: {e}")
                return None, None

        async def process_approval(self, room_id: str, thread_id: str, approved: bool):
            """Process an approval reaction."""
            action = "Approved" if approved else "Rejected"

            try:
                # Notify LangGraph of approval
                response = await self.http_client.post(
                    f"{LANGGRAPH_URL}/approval",
                    json={
                        "thread_id": thread_id,
                        "approved": approved,
                        "source": "matrix_reaction"
                    }
                )

                if response.status_code == 200:
                    result = response.json()
                    await self.send_thread_reply(
                        room_id,
                        thread_id,
                        f"\u2705 {action}. {result.get('message', '')}"
                    )
                else:
                    await self.send_thread_reply(
                        room_id,
                        thread_id,
                        f"Failed to process {action.lower()}: {response.status_code}"
                    )
            except Exception as e:
                logger.error(f"Error processing approval: {e}")

        async def send_message(self, room_id: str, message: str):
            """Send a message to a room."""
            await self.client.room_send(
                room_id,
                "m.room.message",
                {
                    "msgtype": "m.text",
                    "body": message,
                    "format": "org.matrix.custom.html",
                    "formatted_body": self.markdown_to_html(message),
                }
            )

        async def send_thread_reply(self, room_id: str, thread_id: str, message: str):
            """Send a reply in a thread."""
            await self.client.room_send(
                room_id,
                "m.room.message",
                {
                    "msgtype": "m.text",
                    "body": message,
                    "format": "org.matrix.custom.html",
                    "formatted_body": self.markdown_to_html(message),
                    "m.relates_to": {
                        "rel_type": "m.thread",
                        "event_id": thread_id,
                    }
                }
            )

        async def create_incident_thread(self, room_id: str, incident: dict) -> str:
            """Create a new thread for an incident."""
            severity_emoji = {"critical": "\U0001F534", "warning": "\U0001F7E1", "info": "\U0001F535"}
            emoji = severity_emoji.get(incident.get("severity", "info"), "\U0001F535")

            response = await self.client.room_send(
                room_id,
                "m.room.message",
                {
                    "msgtype": "m.text",
                    "body": f"{emoji} [{incident['id']}] {incident['title']}",
                    "format": "org.matrix.custom.html",
                    "formatted_body": f"""
                        <h3>{emoji} [{incident['id']}] {incident['title']}</h3>
                        <p><strong>Severity:</strong> {incident.get('severity', 'unknown')}</p>
                        <p><strong>Service:</strong> {incident.get('service', 'unknown')}</p>
                        <hr/>
                        <p>{incident.get('description', '')}</p>
                        <p><em>Reply in thread to discuss. React \u2705 to approve, \u274c to reject.</em></p>
                    """,
                }
            )
            return response.event_id

        def markdown_to_html(self, text: str) -> str:
            """Simple markdown to HTML conversion."""
            import re
            # Bold
            text = re.sub(r'\*\*(.+?)\*\*', r'<strong>\1</strong>', text)
            # Italic
            text = re.sub(r'\*(.+?)\*', r'<em>\1</em>', text)
            # Code
            text = re.sub(r'`(.+?)`', r'<code>\1</code>', text)
            # Newlines
            text = text.replace('\n', '<br/>')
            return text

        async def run(self):
            """Main run loop."""
            if not await self.login():
                return

            await self.setup_callbacks()
            logger.info("Bot started, syncing with sync_forever...")

            # Use sync_forever which properly triggers callbacks
            await self.client.sync_forever(
                timeout=30000,
                full_state=True,
                loop_sleep_time=1000
            )

    # Global bot instance for API access
    bot_instance: Optional[AgenticMatrixBot] = None

    class AlertRequest(BaseModel):
        """Incoming alert from alerting pipeline."""
        name: str
        severity: str = "info"
        description: str
        source: str = "unknown"
        suggested_fix: Optional[str] = None
        context: Optional[str] = None
        room_id: Optional[str] = None

    class MessageRequest(BaseModel):
        """Send a message to a room."""
        room_id: str
        message: str

    @asynccontextmanager
    async def lifespan(app: FastAPI):
        """Manage bot lifecycle."""
        global bot_instance
        bot_instance = AgenticMatrixBot()

        # Login and start sync in background
        if await bot_instance.login():
            await bot_instance.setup_callbacks()
            # Start sync in background task
            asyncio.create_task(bot_instance.client.sync_forever(
                timeout=30000,
                full_state=True,
                loop_sleep_time=1000
            ))
            logger.info("Matrix bot started and syncing")

        yield

        # Cleanup
        if bot_instance:
            await bot_instance.client.close()

    app = FastAPI(title="Matrix Bot API", lifespan=lifespan)

    @app.get("/health")
    async def health():
        """Health check endpoint."""
        if bot_instance and bot_instance.client.logged_in:
            return {"status": "healthy", "logged_in": True}
        return {"status": "unhealthy", "logged_in": False}

    @app.post("/alert")
    async def receive_alert(alert: AlertRequest):
        """Receive an alert and send to Matrix."""
        if not bot_instance or not bot_instance.client.logged_in:
            return {"status": "error", "message": "Bot not logged in"}

        severity_emoji = {"critical": "\U0001F534", "warning": "\U0001F7E1", "info": "\U0001F535"}
        emoji = severity_emoji.get(alert.severity, "\U0001F535")

        # Build alert message
        message = f"{emoji} **{alert.name}**\n\n"
        message += f"**Severity:** {alert.severity}\n"
        message += f"**Source:** {alert.source}\n\n"
        message += f"{alert.description}\n"

        if alert.suggested_fix:
            message += f"\n**Suggested Fix:** {alert.suggested_fix}"

        if alert.context:
            message += f"\n\n```\n{alert.context[:500]}\n```"

        room_id = alert.room_id or ALERT_ROOM_ID

        try:
            await bot_instance.send_message(room_id, message)
            return {"status": "sent", "room_id": room_id}
        except Exception as e:
            logger.error(f"Failed to send alert: {e}")
            return {"status": "error", "message": str(e)}

    @app.post("/message")
    async def send_message(req: MessageRequest):
        """Send a message to a specific room."""
        if not bot_instance or not bot_instance.client.logged_in:
            return {"status": "error", "message": "Bot not logged in"}

        try:
            await bot_instance.send_message(req.room_id, req.message)
            return {"status": "sent", "room_id": req.room_id}
        except Exception as e:
            logger.error(f"Failed to send message: {e}")
            return {"status": "error", "message": str(e)}

    @app.post("/approval")
    async def request_approval(request: Request):
        """Receive approval request from LangGraph and post to Matrix.

        Accepts flexible JSON payload - extracts what it can.
        """
        if not bot_instance or not bot_instance.client.logged_in:
            return {"status": "error", "message": "Bot not logged in"}

        try:
            payload = await request.json()
        except Exception as e:
            logger.error(f"Failed to parse approval payload: {e}")
            return {"status": "error", "message": str(e)}

        logger.info(f"Received approval request payload: {json.dumps(payload)[:500]}")

        # Extract fields flexibly - handle various payload formats
        alert_name = (
            payload.get("alert_name") or
            payload.get("alertname") or
            payload.get("name") or
            payload.get("title") or
            "Unknown Alert"
        )
        severity = (
            payload.get("severity") or
            payload.get("level") or
            "info"
        )
        description = (
            payload.get("description") or
            payload.get("message") or
            payload.get("summary") or
            ""
        )
        assessment = (
            payload.get("assessment") or
            payload.get("analysis") or
            payload.get("ai_response") or
            ""
        )
        suggested_action = (
            payload.get("suggested_action") or
            payload.get("action") or
            payload.get("recommendation") or
            payload.get("suggested_fix") or
            None
        )
        runbook = (
            payload.get("runbook") or
            payload.get("runbook_url") or
            None
        )
        room_id = payload.get("room_id") or ALERT_ROOM_ID

        severity_emoji = {"critical": "\U0001F534", "warning": "\U0001F7E1", "info": "\U0001F535"}
        emoji = severity_emoji.get(severity, "\U0001F535")

        # Build approval request message
        message = f"{emoji} **Approval Needed: {alert_name}**\n\n"
        message += f"**Severity:** {severity}\n\n"

        if description:
            message += f"**Description:**\n{description}\n\n"

        if assessment:
            message += f"**AI Assessment:**\n{assessment}\n\n"

        if suggested_action:
            message += f"**Suggested Action:**\n{suggested_action}\n\n"

        if runbook:
            message += f"**Runbook:** {runbook}\n\n"

        message += "_React \u2705 to approve, \u274c to reject_"

        try:
            await bot_instance.send_message(room_id, message)
            logger.info(f"Approval request sent to {room_id}: {alert_name}")
            return {"status": "sent", "room_id": room_id, "alert_name": alert_name}
        except Exception as e:
            logger.error(f"Failed to send approval request: {e}")
            return {"status": "error", "message": str(e)}

    if __name__ == "__main__":
        uvicorn.run(app, host="0.0.0.0", port=8000)

  requirements.txt: |
    matrix-nio[e2e]>=0.24.0
    httpx>=0.27.0
    aiohttp>=3.9.0
    fastapi>=0.109.0
    uvicorn>=0.27.0
