apiVersion: v1
kind: ConfigMap
metadata:
  name: matrix-bot-code
  namespace: ai-platform
  labels:
    app: matrix-bot
    component: interaction-layer
data:
  bot.py: |
    """
    Agentic Platform Matrix Bot â€” UX Enhanced

    Rich formatting, live status updates, structured message cards,
    Redis-backed state persistence, typing indicators, reaction-based
    approvals with power level RBAC, Grafana panel snapshots,
    dynamic incident rooms, and Matrix Space hierarchy.
    """
    import asyncio
    import io
    import json
    import os
    import logging
    import time
    from datetime import datetime
    from typing import Optional

    import httpx
    import redis.asyncio as aioredis
    from nio import (
        AsyncClient,
        LoginResponse,
        RoomMessageText,
        ReactionEvent,
        InviteMemberEvent,
        JoinError,
    )
    from fastapi import FastAPI, BackgroundTasks, Request
    from pydantic import BaseModel
    import uvicorn
    from contextlib import asynccontextmanager

    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger(__name__)

    # Reduce noise from matrix-nio validation warnings
    logging.getLogger("nio.responses").setLevel(logging.ERROR)
    logging.getLogger("nio.client.async_client").setLevel(logging.ERROR)

    # Configuration from environment
    MATRIX_HOMESERVER = os.environ.get("MATRIX_HOMESERVER", "http://conduit:6167")
    MATRIX_USER_ID = os.environ.get("MATRIX_USER_ID", "@agentic-bot:agentic.local")
    MATRIX_PASSWORD = os.environ.get("MATRIX_PASSWORD", "")
    LANGGRAPH_URL = os.environ.get("LANGGRAPH_URL", "http://langgraph:8000")
    QDRANT_URL = os.environ.get("QDRANT_URL", "http://qdrant:6333")
    ALERT_ROOM_ID = os.environ.get("ALERT_ROOM_ID", "!alerts:agentic.local")
    REDIS_URL = os.environ.get("REDIS_URL", "redis://redis:6379/1")
    GRAFANA_URL = os.environ.get("GRAFANA_URL", "")
    GRAFANA_USER = os.environ.get("GRAFANA_USER", "")
    GRAFANA_PASSWORD = os.environ.get("GRAFANA_PASSWORD", "")
    OPERATOR_USER_ID = os.environ.get("OPERATOR_USER_ID", "@charlie:agentic.local")

    # Skill Router: Slash command â†’ skill mapping
    SKILL_COMMANDS = {
        "/troubleshoot": "infrastructure-skill",
        "/deploy": "infrastructure-skill",
        "/remediate": "infrastructure-skill",
        "/cluster": "infrastructure-skill",
        "/investigate": "observability-skill",
        "/status": "observability-skill",
        "/metrics": "observability-skill",
        "/home": "home-skill",
        "/lights": "home-skill",
        "/devices": "home-skill",
        "/media": "media-skill",
        "/plex": "media-skill",
        "/download": "media-skill",
        "/research": "research-skill",
        "/search": "research-skill",
        "/web": "research-skill",
        "/learn": "data-skill",
        "/knowledge": "data-skill",
    }

    # Alert â†’ Grafana dashboard mapping
    ALERT_DASHBOARD_MAP = {
        # Pod alerts â†’ K8s Compute Resources / Pod
        "KubePodCrashLooping": {"uid": "6581e46e4e5c7ba40a07646395ef7b23", "panel": 1},
        "HomelabPodCrashLooping": {"uid": "6581e46e4e5c7ba40a07646395ef7b23", "panel": 1},
        "HomelabPodOOMKilled": {"uid": "6581e46e4e5c7ba40a07646395ef7b23", "panel": 1},
        # Namespace alerts â†’ K8s Compute Resources / Namespace
        "KubePodNotReady": {"uid": "85a562078cdf77779eaa1add43ccec1e", "panel": 1},
        "KubeDeploymentReplicasMismatch": {"uid": "85a562078cdf77779eaa1add43ccec1e", "panel": 1},
        # Node alerts â†’ Node Exporter Full
        "NodeHighCPU": {"uid": "rYdddlPWk", "panel": 77},
        "HomelabNodeHighCPU": {"uid": "rYdddlPWk", "panel": 77},
        "HomelabNodeCriticalCPU": {"uid": "rYdddlPWk", "panel": 77},
        "HomelabNodeHighMemory": {"uid": "rYdddlPWk", "panel": 78},
        "HomelabNodeCriticalMemory": {"uid": "rYdddlPWk", "panel": 78},
        "NodeFilesystemSpaceFillingUp": {"uid": "rYdddlPWk", "panel": 44},
        "HomelabNodeDiskPressure": {"uid": "rYdddlPWk", "panel": 44},
        "HomelabNodeDiskCritical": {"uid": "rYdddlPWk", "panel": 44},
        # Node view for node-level alerts
        "HomelabNodeDown": {"uid": "k8s_views_nodes", "panel": 1},
        "TargetDown": {"uid": "k8s_views_nodes", "panel": 1},
        # PVC alerts â†’ K8s Persistent Volumes
        "PersistentVolumeFillingUp": {"uid": "919b92a8e8041bd567af9edab12c840c", "panel": 1},
        "HomelabPVCNearFull": {"uid": "919b92a8e8041bd567af9edab12c840c", "panel": 1},
        "HomelabPVCCriticallyFull": {"uid": "919b92a8e8041bd567af9edab12c840c", "panel": 1},
        # Cluster overcommit â†’ K8s Compute Resources / Cluster
        "KubeMemoryOvercommit": {"uid": "efa86fd1d0c121a26444b636a3f509a8", "panel": 4},
        "KubeCPUOvercommit": {"uid": "efa86fd1d0c121a26444b636a3f509a8", "panel": 2},
        # Global view for deployment/MCP alerts
        "MCPServerUnhealthy": {"uid": "k8s_views_ns", "panel": 1},
        # Functional health alerts
        "MediaImportStalled": {"uid": "k8s_views_ns", "panel": 1},
        "TailscaleDown": {"uid": "k8s_views_global", "panel": 1},
        "CloudflareTunnelDown": {"uid": "k8s_views_global", "panel": 1},
        # Backup alerts
        "VeleroBackupFailed": {"uid": "k8s_views_ns", "panel": 1},
        "VeleroBackupMissing": {"uid": "k8s_views_ns", "panel": 1},
        "StaleStorageMount": {"uid": "k8s_views_ns", "panel": 1},
    }


    # â”€â”€ Redis-Backed State Store â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    class AlertStateStore:
        """Redis-backed alert state persistence. Survives bot restarts."""

        def __init__(self, redis_url: str):
            self.redis = aioredis.from_url(redis_url, decode_responses=True)
            self.prefix = "matrix:alert:"
            self.ttl = 86400  # 24h expiry

        async def store_alert(self, alert_id: str, data: dict):
            """Store alert â†’ Matrix event mapping."""
            await self.redis.setex(
                f"{self.prefix}{alert_id}", self.ttl, json.dumps(data)
            )

        async def get_alert(self, alert_id: str) -> Optional[dict]:
            raw = await self.redis.get(f"{self.prefix}{alert_id}")
            return json.loads(raw) if raw else None

        async def store_approval(self, event_id: str, data: dict):
            """Store pending approval keyed by Matrix event_id for reaction lookup."""
            await self.redis.setex(
                f"matrix:approval:{event_id}", self.ttl, json.dumps(data)
            )

        async def get_approval(self, event_id: str) -> Optional[dict]:
            raw = await self.redis.get(f"matrix:approval:{event_id}")
            return json.loads(raw) if raw else None

        async def delete_approval(self, event_id: str):
            await self.redis.delete(f"matrix:approval:{event_id}")

        async def health_check(self) -> bool:
            try:
                return await self.redis.ping()
            except Exception:
                return False


    # â”€â”€ Rich Message Formatter â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    class MessageFormatter:
        """Rich Matrix message formatting with severity colors and structured cards."""

        SEVERITY_COLORS = {
            "critical": "#ff1744",
            "warning": "#ffd600",
            "info": "#2979ff",
            "ok": "#00c853",
            "pending": "#9e9e9e",
        }
        SEVERITY_EMOJI = {
            "critical": "\U0001f534",
            "warning": "\U0001f7e1",
            "info": "\U0001f535",
            "ok": "\U0001f7e2",
        }

        @staticmethod
        def status_badge(status: str) -> str:
            color = MessageFormatter.SEVERITY_COLORS.get(status.lower(), "#9e9e9e")
            text_color = "#000000" if status.lower() == "warning" else "#ffffff"
            return (
                f'<span data-mx-bg-color="{color}" data-mx-color="{text_color}">'
                f" {status.upper()} </span>"
            )

        @staticmethod
        def table(headers: list, rows: list) -> str:
            html = '<table style="margin:8px 0;">'
            if headers:
                html += "<tr>" + "".join(f"<th>{h}</th>" for h in headers) + "</tr>"
            for row in rows:
                html += "<tr>" + "".join(f"<td>{c}</td>" for c in row) + "</tr>"
            return html + "</table>"

        @staticmethod
        def kv_table(pairs: dict) -> str:
            """Key-value pairs as a two-column table (no headers)."""
            rows = [[f"<strong>{k}</strong>", f" {v}"] for k, v in pairs.items()]
            return MessageFormatter.table([], rows)

        @staticmethod
        def collapsible(summary: str, content: str) -> str:
            return f"<details><summary>{summary}</summary>{content}</details>"

        @staticmethod
        def card(title: str, severity: str, body: str, footer: str = "") -> str:
            emoji = MessageFormatter.SEVERITY_EMOJI.get(severity.lower(), "\U0001f4cb")
            html = f"<h3>{emoji} {title}</h3><br/>{body}"
            if footer:
                html += f"<br/><hr/><br/>{footer}"
            return html


    # â”€â”€ Matrix Bot â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    class AgenticMatrixBot:
        SPACE_STRUCTURE = {
            "name": "Agentic Lab",
            "rooms": {
                "status": {
                    "name": "Status",
                    "topic": "Read-only platform health (state events)",
                },
                "alerts-critical": {
                    "name": "Critical Alerts",
                    "topic": "Critical alerts spawn incident rooms",
                },
                "alerts-info": {
                    "name": "Info & Warnings",
                    "topic": "Low-noise non-critical alerts",
                },
                "brain-trust": {
                    "name": "Brain Trust",
                    "topic": "Runbook proposals & architectural discussions",
                },
                "lab-command": {
                    "name": "Lab Command",
                    "topic": "Conversational interface: g, <query>",
                },
            },
        }

        def __init__(self):
            self.client = AsyncClient(MATRIX_HOMESERVER, MATRIX_USER_ID)
            self.conversations = {}
            self.http_client = httpx.AsyncClient(timeout=120.0)
            self.max_history = 20
            self.state = AlertStateStore(REDIS_URL)
            self._fallback_approvals = {}  # In-memory fallback if Redis is down
            self.rooms = {}  # Space room mapping
            self.startup_time = int(time.time() * 1000)

        async def login(self):
            """Login to Matrix homeserver."""
            response = await self.client.login(MATRIX_PASSWORD)
            if isinstance(response, LoginResponse):
                logger.info(f"Logged in as {MATRIX_USER_ID}")
                return True
            else:
                logger.error(f"Login failed: {response}")
                return False

        async def setup_callbacks(self):
            """Register event callbacks."""
            self.client.add_event_callback(self.on_message, RoomMessageText)
            self.client.add_event_callback(self.on_reaction, ReactionEvent)
            self.client.add_event_callback(self.on_invite, InviteMemberEvent)
            # Debug: catch-all for event types
            self.client.add_event_callback(self.on_any_event, (RoomMessageText, ReactionEvent, InviteMemberEvent))
            logger.info("Event callbacks registered: RoomMessageText, ReactionEvent, InviteMemberEvent")

        async def on_any_event(self, room, event):
            """Debug: log all received events."""
            event_type = type(event).__name__
            logger.info(f"EVENT RECEIVED: type={event_type} room={room.room_id} sender={getattr(event, 'sender', 'N/A')}")

        # â”€â”€ Core Matrix Operations â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

        async def send_message(self, room_id: str, message: str, html: str = None):
            """Send an m.notice to a room. Returns response with event_id."""
            return await self.client.room_send(
                room_id,
                "m.room.message",
                {
                    "msgtype": "m.notice",
                    "body": message,
                    "format": "org.matrix.custom.html",
                    "formatted_body": html or self.markdown_to_html(message),
                },
            )

        async def send_thread_reply(
            self, room_id: str, thread_id: str, message: str, html: str = None
        ):
            """Send a threaded reply."""
            return await self.client.room_send(
                room_id,
                "m.room.message",
                {
                    "msgtype": "m.notice",
                    "body": message,
                    "format": "org.matrix.custom.html",
                    "formatted_body": html or self.markdown_to_html(message),
                    "m.relates_to": {
                        "rel_type": "m.thread",
                        "event_id": thread_id,
                    },
                },
            )

        async def edit_message(
            self, room_id: str, event_id: str, new_body: str, new_html: str
        ):
            """Edit a previously sent message for live status updates."""
            await self.client.room_send(
                room_id,
                "m.room.message",
                {
                    "msgtype": "m.notice",
                    "body": f"* {new_body}",
                    "format": "org.matrix.custom.html",
                    "formatted_body": new_html,
                    "m.new_content": {
                        "msgtype": "m.notice",
                        "body": new_body,
                        "format": "org.matrix.custom.html",
                        "formatted_body": new_html,
                    },
                    "m.relates_to": {
                        "rel_type": "m.replace",
                        "event_id": event_id,
                    },
                },
            )

        async def react_to_message(self, room_id: str, event_id: str, emoji: str):
            """Add a reaction to a message."""
            await self.client.room_send(
                room_id,
                "m.reaction",
                {
                    "m.relates_to": {
                        "rel_type": "m.annotation",
                        "event_id": event_id,
                        "key": emoji,
                    }
                },
            )

        async def set_typing(self, room_id: str, typing: bool, timeout: int = 10000):
            """Set typing indicator."""
            try:
                await self.client.room_typing(room_id, typing, timeout=timeout)
            except Exception as e:
                logger.debug(f"Typing indicator failed: {e}")

        async def check_power_level(
            self, room_id: str, user_id: str, required: int = 50
        ) -> bool:
            """Check if user has sufficient power level. Fails closed."""
            try:
                room = self.client.rooms.get(room_id)
                if room and hasattr(room, "power_levels") and room.power_levels:
                    user_pl = room.power_levels.users.get(
                        user_id, room.power_levels.defaults.users_default
                    )
                    return user_pl >= required
            except Exception as e:
                logger.warning(f"Power level check failed: {e}")
            return False

        # â”€â”€ Grafana Integration â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

        async def capture_grafana_panel(
            self,
            dashboard_uid: str,
            panel_id: int,
            from_ts: str = "now-1h",
            to_ts: str = "now",
            width: int = 1280,
            height: int = 720,
        ) -> Optional[bytes]:
            """Render a Grafana panel as PNG."""
            if not GRAFANA_URL or not GRAFANA_USER:
                return None
            url = (
                f"{GRAFANA_URL}/render/d-solo/{dashboard_uid}"
                f"?panelId={panel_id}&from={from_ts}&to={to_ts}"
                f"&width={width}&height={height}"
            )
            try:
                resp = await self.http_client.get(
                    url,
                    auth=(GRAFANA_USER, GRAFANA_PASSWORD),
                    timeout=30.0,
                )
                if resp.status_code == 200 and resp.headers.get(
                    "content-type", ""
                ).startswith("image/"):
                    return resp.content
                logger.warning(f"Grafana render returned {resp.status_code}")
            except Exception as e:
                logger.warning(f"Grafana render failed: {e}")
            return None

        async def send_image(
            self,
            room_id: str,
            image_bytes: bytes,
            filename: str,
            width: int = 1280,
            height: int = 720,
            thread_id: str = None,
        ):
            """Upload image to Conduit and send as m.image."""
            try:
                resp, _ = await self.client.upload(
                    io.BytesIO(image_bytes),
                    content_type="image/png",
                    filename=filename,
                    filesize=len(image_bytes),
                )
                if not hasattr(resp, "content_uri"):
                    logger.warning("Image upload failed: no content_uri")
                    return

                content = {
                    "msgtype": "m.image",
                    "body": filename,
                    "url": resp.content_uri,
                    "info": {
                        "size": len(image_bytes),
                        "mimetype": "image/png",
                        "w": width,
                        "h": height,
                    },
                }
                if thread_id:
                    content["m.relates_to"] = {
                        "rel_type": "m.thread",
                        "event_id": thread_id,
                    }

                await self.client.room_send(room_id, "m.room.message", content)
            except Exception as e:
                logger.warning(f"Failed to send image: {e}")

        async def _attach_grafana_snapshot(
            self, room_id: str, root_event_id: str, alert_name: str
        ):
            """Fire-and-forget: attach Grafana panel snapshot to alert thread."""
            mapping = ALERT_DASHBOARD_MAP.get(alert_name)
            if not mapping:
                # Catch-all: route unmatched alerts (e.g. Coroot) to K8s Global view
                mapping = {"uid": "k8s_views_global", "panel": 1}
            image_bytes = await self.capture_grafana_panel(
                mapping["uid"], mapping["panel"]
            )
            if image_bytes:
                filename = f"{alert_name.lower().replace(' ', '_')}_panel.png"
                await self.send_image(
                    room_id, image_bytes, filename, thread_id=root_event_id
                )

        # â”€â”€ Incident Room Management â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

        async def create_incident_room(
            self,
            alert_id: str,
            alert_name: str,
            severity: str,
            description: str,
        ) -> Optional[str]:
            """Create a temporary incident room for critical alerts."""
            if severity.lower() != "critical":
                return None

            room_name = (
                f"incident-{alert_id[:8]}-"
                f"{alert_name.lower().replace(' ', '-')[:30]}"
            )
            room_topic = (
                f"\U0001f534 Active Incident: {alert_name} | {description[:100]}"
            )

            try:
                resp = await self.client.room_create(
                    name=room_name,
                    topic=room_topic,
                    invite=[OPERATOR_USER_ID],
                )
                if hasattr(resp, "room_id"):
                    card = MessageFormatter.card(
                        alert_name,
                        severity,
                        f"<blockquote>{description}</blockquote>",
                        "<em>Incident room active. All updates will appear here.</em>",
                    )
                    await self.send_message(resp.room_id, alert_name, card)

                    target_room = self.rooms.get("alerts-critical", ALERT_ROOM_ID)
                    await self.send_message(
                        target_room,
                        f"Incident room created for {alert_name}",
                        (
                            f"\U0001f534 Incident room created for "
                            f"<strong>{alert_name}</strong> "
                            f"\u2192 invited to #{room_name}"
                        ),
                    )

                    # Add to space if available
                    try:
                        space_raw = await self.state.redis.get("matrix:space:rooms")
                        if space_raw:
                            space_data = json.loads(space_raw)
                            space_id = space_data.get("_space_id")
                            if space_id:
                                await self.client.room_put_state(
                                    space_id,
                                    "m.space.child",
                                    {"via": ["agentic.local"]},
                                    state_key=resp.room_id,
                                )
                    except Exception as e:
                        logger.warning(f"Failed to add incident room to Space: {e}")

                    return resp.room_id
            except Exception as e:
                logger.warning(f"Failed to create incident room: {e}")
            return None

        async def resolve_incident_room(self, alert_id: str, summary: str):
            """Full archive of incident room on resolution."""
            alert_state = await self.state.get_alert(alert_id)
            if not alert_state or not alert_state.get("incident_room_id"):
                return

            incident_room = alert_state["incident_room_id"]

            try:
                # Post resolution summary
                resolution_card = MessageFormatter.card(
                    "Incident Resolved",
                    "ok",
                    f"<p>{summary}</p>",
                    "<em>This room is now archived and read-only.</em>",
                )
                await self.send_message(
                    incident_room,
                    f"Incident Resolved: {summary}",
                    resolution_card,
                )

                # Set room to read-only
                await self.client.room_put_state(
                    incident_room,
                    "m.room.power_levels",
                    {
                        "events_default": 50,
                        "users": {
                            self.client.user_id: 100,
                            OPERATOR_USER_ID: 100,
                        },
                    },
                )

                # Remove from Space
                try:
                    space_raw = await self.state.redis.get("matrix:space:rooms")
                    if space_raw:
                        space_data = json.loads(space_raw)
                        space_id = space_data.get("_space_id")
                        if space_id:
                            await self.client.room_put_state(
                                space_id,
                                "m.space.child",
                                {},
                                state_key=incident_room,
                            )
                except Exception as e:
                    logger.warning(
                        f"Failed to remove incident room from Space: {e}"
                    )

                # Bot leaves the room
                await self.client.room_leave(incident_room)
                await self.client.room_forget(incident_room)
            except Exception as e:
                logger.warning(f"Failed to resolve incident room: {e}")

            # Clean up Redis
            await self.state.redis.delete(f"matrix:alert:{alert_id}")
            await self.update_presence()

        # â”€â”€ Space Hierarchy â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

        async def ensure_space_structure(self):
            """Idempotent: create Space + rooms on startup if missing."""
            try:
                cached = await self.state.redis.get("matrix:space:rooms")
                if cached:
                    data = json.loads(cached)
                    self.rooms = {
                        k: v for k, v in data.items() if not k.startswith("_")
                    }
                    logger.info(
                        f"Loaded space structure from Redis: "
                        f"{list(self.rooms.keys())}"
                    )
                    return
            except Exception as e:
                logger.warning(f"Redis unavailable for space structure: {e}")
                return

            try:
                space_resp = await self.client.room_create(
                    name=self.SPACE_STRUCTURE["name"],
                    topic="Kernow Homelab AI Platform",
                    space=True,
                )
                space_id = (
                    space_resp.room_id
                    if hasattr(space_resp, "room_id")
                    else None
                )

                rooms = {}
                for key, config in self.SPACE_STRUCTURE["rooms"].items():
                    resp = await self.client.room_create(
                        name=config["name"],
                        topic=config["topic"],
                        invite=[OPERATOR_USER_ID],
                    )
                    if hasattr(resp, "room_id"):
                        rooms[key] = resp.room_id
                        if space_id:
                            try:
                                await self.client.room_put_state(
                                    space_id,
                                    "m.space.child",
                                    {"via": ["agentic.local"]},
                                    state_key=resp.room_id,
                                )
                            except Exception as e:
                                logger.warning(
                                    f"Failed to add {key} to space: {e}"
                                )

                self.rooms = rooms
                store_data = {**rooms, "_space_id": space_id}
                await self.state.redis.set(
                    "matrix:space:rooms", json.dumps(store_data)
                )
                logger.info(f"Created space structure: {list(rooms.keys())}")
            except Exception as e:
                logger.warning(f"Failed to create space structure: {e}")
                logger.info("Falling back to ALERT_ROOM_ID for all messages")

        # â”€â”€ Presence â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

        async def update_presence(self):
            """Set bot status to reflect active incidents."""
            try:
                keys = []
                async for key in self.state.redis.scan_iter("matrix:alert:*"):
                    keys.append(key)
                active_count = len(keys)

                if active_count == 0:
                    status = "\U0001f916 All clear \u2014 monitoring"
                elif active_count == 1:
                    status = "\U0001f916 1 active incident"
                else:
                    status = f"\U0001f916 {active_count} active incidents"

                await self.client.set_presence("online", status_msg=status)
            except Exception as e:
                logger.warning(f"Presence update failed: {e}")

        # â”€â”€ Room Routing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

        def route_room(
            self, severity: str = None, msg_type: str = None
        ) -> str:
            """Route a message to the correct room based on type/severity."""
            if msg_type == "brain-trust" and "brain-trust" in self.rooms:
                return self.rooms["brain-trust"]
            if msg_type == "command" and "lab-command" in self.rooms:
                return self.rooms["lab-command"]
            if (
                severity
                and severity.lower() == "critical"
                and "alerts-critical" in self.rooms
            ):
                return self.rooms["alerts-critical"]
            if (
                severity
                and severity.lower() in ("warning", "info")
                and "alerts-info" in self.rooms
            ):
                return self.rooms["alerts-info"]
            return ALERT_ROOM_ID

        # â”€â”€ Event Callbacks â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

        async def on_invite(self, room, event):
            """Auto-join rooms when invited."""
            if event.membership == "invite":
                try:
                    url = (
                        f"{MATRIX_HOMESERVER}/_matrix/client/v3/join/"
                        f"{room.room_id}"
                    )
                    headers = {
                        "Authorization": f"Bearer {self.client.access_token}"
                    }
                    response = await self.http_client.post(
                        url, headers=headers, json={}
                    )
                    if response.status_code == 200:
                        logger.info(f"Joined room {room.room_id}")
                    else:
                        logger.error(
                            f"Failed to join {room.room_id}: "
                            f"{response.status_code} {response.text}"
                        )
                except Exception as e:
                    logger.error(f"Exception joining {room.room_id}: {e}")

        async def on_message(self, room, event):
            """Handle incoming messages."""
            try:
                event_time = event.server_timestamp
                if event_time < self.startup_time:
                    return

                logger.info(f"=== MESSAGE from {event.sender} ===")
                logger.info(f"Body: {event.body}")

                content = event.source.get("content", {})
                if "m.relates_to" in content:
                    logger.info(
                        f"m.relates_to: {content.get('m.relates_to')}"
                    )

                if event.sender == self.client.user_id:
                    return

                relates_to = content.get("m.relates_to", {})
                reply_to = relates_to.get("m.in_reply_to", {}).get(
                    "event_id"
                )

                if reply_to:
                    await self.handle_reply_with_context(
                        room, event, reply_to
                    )
                else:
                    await self.handle_command(room, event)
            except Exception as e:
                logger.error(f"Error in on_message: {e}")
                import traceback

                logger.error(traceback.format_exc())

        async def handle_command(self, room, event):
            """Handle messages â€” responds to triggers like 'g', 'gemini'."""
            import re

            message = event.body.strip()
            message_lower = message.lower()

            triggers = [
                r"^g[,:\s]+",
                r"^gemini[,:\s]+",
                r"^hey g[,:\s]*",
                r"^yo g[,:\s]*",
                r"^ok g[,:\s]*",
                r"^@[\w.-]+:[\w.-]+",
            ]

            triggered = False
            query = message
            for pattern in triggers:
                match = re.match(pattern, message_lower)
                if match:
                    triggered = True
                    query = message[match.end() :].strip()
                    break

            query = re.sub(
                r"@[\w.-]+:[\w.-]+", "", query, flags=re.IGNORECASE
            ).strip()

            if not triggered:
                return

            if not query:
                await self.send_message(room.room_id, "Yes?")
                return

            query_lower = query.lower()

            # Slash command routing to skill system
            if query.startswith("/"):
                await self.handle_skill_command(room, query)
                return

            # Quick commands
            if query_lower in [
                "status",
                "what's happening",
                "what's happening?",
            ]:
                await self.set_typing(room.room_id, True)
                try:
                    response = await self.get_platform_status()
                    await self.send_message(room.room_id, "Platform Status", response)
                finally:
                    await self.set_typing(room.room_id, False)
                return
            elif query_lower in [
                "what needs attention",
                "what needs attention?",
                "pending",
            ]:
                await self.set_typing(room.room_id, True)
                try:
                    response = await self.get_pending_items()
                    await self.send_message(room.room_id, "Pending Items", response)
                finally:
                    await self.set_typing(room.room_id, False)
                return
            elif query_lower in ["clear", "reset", "new conversation"]:
                self.conversations.pop(room.room_id, None)
                await self.send_message(
                    room.room_id, "Conversation cleared. Starting fresh!"
                )
                return

            # Conversational query with typing indicator
            conv_id = room.room_id
            history = self.conversations.get(conv_id, [])
            history.append({"role": "user", "content": query})

            await self.set_typing(room.room_id, True)
            try:
                response = await self.query_gemini(query, {}, history)
            finally:
                await self.set_typing(room.room_id, False)

            history.append({"role": "assistant", "content": response})
            if len(history) > self.max_history:
                history = history[-self.max_history :]
            self.conversations[conv_id] = history

            await self.send_message(room.room_id, response)

        async def handle_skill_command(self, room, query: str):
            """Handle slash commands by routing to skill system."""
            parts = query.split(maxsplit=1)
            command = parts[0].lower()
            args = parts[1] if len(parts) > 1 else ""

            skill_id = SKILL_COMMANDS.get(command)

            if not skill_id:
                # Unknown command - show available commands
                available = ", ".join(sorted(SKILL_COMMANDS.keys()))
                await self.send_message(
                    room.room_id,
                    f"Unknown command: {command}",
                    (
                        f"<p>Unknown command: <code>{command}</code></p>"
                        f"<p>Available commands: <code>{available}</code></p>"
                    ),
                )
                return

            await self.set_typing(room.room_id, True)
            try:
                # Route to LangGraph /skill endpoint
                payload = {
                    "skill_id": skill_id,
                    "command": command,
                    "query": args or f"{command} request",
                    "source": "matrix_bot",
                    "room_id": room.room_id,
                }

                response = await self.http_client.post(
                    f"{LANGGRAPH_URL}/skill",
                    json=payload,
                    timeout=120.0,
                )

                if response.status_code == 200:
                    result = response.json()
                    answer = result.get(
                        "response",
                        result.get("answer", "Skill executed successfully"),
                    )
                    skill_name = result.get("skill_name", skill_id)

                    # Format response card
                    card = MessageFormatter.card(
                        f"{command} ({skill_name})",
                        "ok",
                        f"<p>{self.markdown_to_html(answer)}</p>",
                    )
                    await self.send_message(room.room_id, answer, card)
                else:
                    error_msg = f"Skill execution failed: {response.status_code}"
                    try:
                        error_detail = response.json().get("detail", response.text[:200])
                        error_msg = f"{error_msg} - {error_detail}"
                    except Exception:
                        pass
                    await self.send_message(
                        room.room_id,
                        error_msg,
                        MessageFormatter.card(
                            f"Error: {command}",
                            "critical",
                            f"<p>{error_msg}</p>",
                        ),
                    )
            except Exception as e:
                logger.error(f"Skill command error: {e}")
                await self.send_message(
                    room.room_id,
                    f"Error executing {command}: {str(e)}",
                    MessageFormatter.card(
                        f"Error: {command}",
                        "critical",
                        f"<p>Error: {str(e)}</p>",
                    ),
                )
            finally:
                await self.set_typing(room.room_id, False)

        async def handle_reply_with_context(
            self, room, event, reply_to_event_id
        ):
            """Handle when user replies to a message."""
            import re

            logger.info(f"Reply detected to event: {reply_to_event_id}")

            original_content, original_sender = await self.get_original_message(
                room.room_id, reply_to_event_id
            )

            user_message = event.body
            if user_message.startswith(">"):
                parts = user_message.split("\n\n", 1)
                if len(parts) > 1:
                    user_message = parts[1].strip()

            message_lower = user_message.lower()
            triggers = [
                r"^g[,:\s]+",
                r"^gemini[,:\s]+",
                r"^hey g[,:\s]*",
                r"^yo g[,:\s]*",
                r"^ok g[,:\s]*",
            ]

            triggered = False
            query = user_message
            for pattern in triggers:
                match = re.match(pattern, message_lower)
                if match:
                    triggered = True
                    query = user_message[match.end() :].strip()
                    break

            is_reply_to_bot = original_sender == self.client.user_id
            if not triggered and not is_reply_to_bot:
                return

            if not query:
                query = user_message

            context_prompt = (
                f"The user is replying to this message:\n\n"
                f"---\n{original_content}\n---\n\n"
                f"User's reply: {query}"
            )

            await self.set_typing(room.room_id, True)
            try:
                response = await self.query_gemini(
                    context_prompt, {"is_reply": True}, []
                )
            finally:
                await self.set_typing(room.room_id, False)

            await self.send_message(room.room_id, response)

        async def on_reaction(self, room, event):
            """Handle reaction-based approvals with power level RBAC."""
            # Debug: log all reaction events
            logger.info(f"REACTION received: key={event.key!r} from={event.sender} reacts_to={event.reacts_to} room={room.room_id}")

            event_id = event.reacts_to

            pending = await self._get_pending_approval(event_id)
            if not pending:
                logger.debug(f"No pending approval found for event_id={event_id}")
                return

            logger.info(f"Found pending approval for {event_id}: alert_id={pending.get('alert_id')}")

            # Power level check
            if not await self.check_power_level(room.room_id, event.sender):
                await self.send_thread_reply(
                    room.room_id,
                    event_id,
                    "Insufficient permissions. Power Level 50+ required.",
                    (
                        "\u26d4 <strong>Insufficient permissions.</strong> "
                        "Power Level 50+ required to approve/reject."
                    ),
                )
                return

            if event.key == "\u2705":
                await self.process_approval(
                    room.room_id,
                    event_id,
                    pending,
                    approved=True,
                    user=event.sender,
                )
            elif event.key == "\u274c":
                await self.process_approval(
                    room.room_id,
                    event_id,
                    pending,
                    approved=False,
                    user=event.sender,
                )
            elif event.key == "\U0001f914":  # ðŸ¤”
                # Immediate ack to prevent re-reaction on slow response
                await self.react_to_message(
                    room.room_id, event.event_id, "\U0001f4ac"
                )
                await self.request_more_context(
                    room.room_id, event_id, pending
                )
            elif event.key == "\u23f8\ufe0f":  # â¸ï¸
                await self.react_to_message(
                    room.room_id, event.event_id, "\u23f3"
                )
                await self.pause_execution(
                    room.room_id, event_id, pending
                )

        # â”€â”€ Approval Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

        async def _get_pending_approval(
            self, event_id: str
        ) -> Optional[dict]:
            """Get pending approval from Redis with in-memory fallback."""
            try:
                pending = await self.state.get_approval(event_id)
                if pending:
                    return pending
            except Exception:
                pass
            return self._fallback_approvals.get(event_id)

        async def _store_pending_approval(
            self, event_id: str, data: dict
        ):
            """Store pending approval in Redis + in-memory fallback."""
            self._fallback_approvals[event_id] = data
            try:
                await self.state.store_approval(event_id, data)
            except Exception as e:
                logger.warning(
                    f"Redis store failed, using in-memory fallback: {e}"
                )

        async def _delete_pending_approval(self, event_id: str):
            """Delete pending approval from both stores."""
            self._fallback_approvals.pop(event_id, None)
            try:
                await self.state.delete_approval(event_id)
            except Exception:
                pass

        async def request_more_context(
            self, room_id: str, event_id: str, pending: dict
        ):
            """Handle thinking-face reaction â€” request more info from LangGraph."""
            alert_id = pending.get("alert_id", "unknown")
            alert_name = pending.get("alert_name", "Unknown")

            await self.set_typing(room_id, True)
            try:
                context_query = (
                    f"Provide additional diagnostic context for alert "
                    f"'{alert_name}' (alert_id: {alert_id}). "
                    f"Include relevant metrics, recent events, "
                    f"and potential root causes."
                )
                response = await self.query_gemini(
                    context_query, {"alert_id": alert_id}, []
                )
                card = MessageFormatter.card(
                    f"Additional Context: {alert_name}",
                    "info",
                    f"<p>{self.markdown_to_html(response)}</p>",
                    (
                        "<em>Review complete. React to the original "
                        "message to approve/reject.</em>"
                    ),
                )
                await self.send_thread_reply(
                    room_id,
                    event_id,
                    f"Additional Context: {alert_name}\n{response}",
                    card,
                )
            except Exception as e:
                await self.send_thread_reply(
                    room_id,
                    event_id,
                    f"Failed to fetch additional context: {e}",
                )
            finally:
                await self.set_typing(room_id, False)

        async def pause_execution(
            self, room_id: str, event_id: str, pending: dict
        ):
            """Handle pause reaction â€” extend cooling period."""
            alert_name = pending.get("alert_name", "Unknown")

            try:
                raw = await self.state.redis.get(
                    f"matrix:approval:{event_id}"
                )
                if raw:
                    data = json.loads(raw)
                    data["paused"] = True
                    data["paused_at"] = datetime.now().isoformat()
                    await self.state.redis.setex(
                        f"matrix:approval:{event_id}",
                        self.state.ttl * 2,
                        json.dumps(data),
                    )
            except Exception as e:
                logger.warning(f"Failed to extend TTL: {e}")

            card = MessageFormatter.card(
                f"Paused: {alert_name}",
                "pending",
                (
                    "<p>Execution paused. Cooling period extended.</p>"
                    "<p>React \u2705 to resume and approve, "
                    "or \u274c to reject.</p>"
                ),
            )
            await self.send_thread_reply(
                room_id,
                event_id,
                f"Paused: {alert_name}. Cooling period extended.",
                card,
            )

        async def process_approval(
            self,
            room_id: str,
            event_id: str,
            pending: dict,
            approved: bool,
            user: str,
        ):
            """Process approval reaction with live status updates."""
            alert_id = pending["alert_id"]
            alert_name = pending.get("alert_name", "Unknown")
            action = "Approved" if approved else "Rejected"
            approved_by = (
                user.split(":")[0].lstrip("@") if user else "unknown"
            )

            logger.info(
                f"Processing {action.lower()} for {alert_id} by {approved_by}"
            )

            # Look up alert root for threading
            alert_state = await self.state.get_alert(alert_id)
            thread_id = (
                alert_state.get("root_event_id", event_id)
                if alert_state
                else event_id
            )

            # Send "processing" status
            processing_html = MessageFormatter.card(
                f"Processing: {alert_name}",
                "pending",
                (
                    f"<p>{action} by <strong>{approved_by}</strong>. "
                    f"Executing...</p>"
                ),
            )
            status_resp = await self.send_thread_reply(
                room_id,
                thread_id,
                f"Processing {action.lower()} by {approved_by}...",
                processing_html,
            )
            status_event_id = (
                status_resp.event_id
                if hasattr(status_resp, "event_id")
                else None
            )

            try:
                if approved:
                    response = await self.http_client.post(
                        f"{LANGGRAPH_URL}/approve",
                        json={
                            "alert_id": alert_id,
                            "solution_index": 1,
                            "approved_by": approved_by,
                        },
                    )
                else:
                    try:
                        response = await self.http_client.post(
                            f"{LANGGRAPH_URL}/ignore",
                            json={
                                "alert_id": alert_id,
                                "ignored_by": approved_by,
                            },
                        )
                    except Exception:
                        response = None

                if response and response.status_code == 200:
                    result = response.json()
                    success = result.get("success", True)
                    summary = result.get(
                        "summary", result.get("message", "")
                    )
                    result_severity = "ok" if success else "warning"
                    result_emoji = "\u2705" if success else "\u26a0\ufe0f"

                    result_html = MessageFormatter.card(
                        f"{action}: {alert_name}",
                        result_severity,
                        MessageFormatter.kv_table(
                            {
                                "Action": action,
                                "By": approved_by,
                                "Result": (
                                    "Success" if success else "Warning"
                                ),
                                "Details": summary or "No details",
                            }
                        ),
                    )

                    if status_event_id:
                        await self.edit_message(
                            room_id,
                            status_event_id,
                            f"{result_emoji} {action} by {approved_by}. "
                            f"{summary}",
                            result_html,
                        )

                    await self.react_to_message(
                        room_id, event_id, result_emoji
                    )

                    # Resolve incident room if applicable
                    if (
                        approved
                        and alert_state
                        and alert_state.get("incident_room_id")
                    ):
                        await self.resolve_incident_room(
                            alert_id,
                            summary or f"{action} by {approved_by}",
                        )

                elif response:
                    error_html = MessageFormatter.card(
                        f"Error: {alert_name}",
                        "critical",
                        (
                            f"<p>Failed to process: {response.status_code}"
                            f" - {response.text[:200]}</p>"
                        ),
                    )
                    if status_event_id:
                        await self.edit_message(
                            room_id,
                            status_event_id,
                            f"Failed: {response.status_code}",
                            error_html,
                        )
                else:
                    # Rejection with no /ignore endpoint
                    ack_html = MessageFormatter.card(
                        f"Rejected: {alert_name}",
                        "pending",
                        (
                            f"<p>{action} by "
                            f"<strong>{approved_by}</strong>. "
                            f"Alert dismissed.</p>"
                        ),
                    )
                    if status_event_id:
                        await self.edit_message(
                            room_id,
                            status_event_id,
                            f"{action} by {approved_by}. Alert dismissed.",
                            ack_html,
                        )
                    await self.react_to_message(
                        room_id, event_id, "\u274c"
                    )

                await self._delete_pending_approval(event_id)
                await self.update_presence()

            except Exception as e:
                logger.error(f"Error processing approval: {e}")
                import traceback

                logger.error(traceback.format_exc())
                error_html = MessageFormatter.card(
                    "Error",
                    "critical",
                    f"<p>Error processing approval: {str(e)}</p>",
                )
                if status_event_id:
                    await self.edit_message(
                        room_id,
                        status_event_id,
                        f"Error: {str(e)}",
                        error_html,
                    )

        # â”€â”€ Query Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

        async def query_gemini(
            self, message: str, context: dict, history: list = None
        ) -> str:
            """Query Gemini via LangGraph /query endpoint."""
            try:
                payload = {
                    "prompt": message,
                    "context": context or {},
                    "source": "matrix_bot",
                    "messages": history or [],
                }
                response = await self.http_client.post(
                    f"{LANGGRAPH_URL}/query", json=payload
                )
                if response.status_code == 200:
                    result = response.json()
                    return result.get(
                        "response",
                        result.get("answer", "No response from Gemini"),
                    )
                else:
                    logger.error(
                        f"Gemini query failed: {response.status_code}"
                        f" - {response.text}"
                    )
                    return f"Error querying Gemini: {response.status_code}"
            except Exception as e:
                logger.error(f"Error querying Gemini: {e}")
                return f"Error: {str(e)}"

        async def get_platform_status(self) -> str:
            """Get current platform status as HTML card."""
            try:
                response = await self.http_client.get(
                    f"{LANGGRAPH_URL}/health"
                )
                langgraph_healthy = response.status_code == 200
                pending = await self.get_pending_count()
                redis_ok = await self.state.health_check()

                return MessageFormatter.card(
                    "Platform Status",
                    "ok" if langgraph_healthy else "warning",
                    MessageFormatter.kv_table(
                        {
                            "LangGraph": (
                                "\u2705 Healthy"
                                if langgraph_healthy
                                else "\u274c Unhealthy"
                            ),
                            "Redis": (
                                "\u2705 Connected"
                                if redis_ok
                                else "\u274c Unavailable"
                            ),
                            "Pending Approvals": str(pending),
                        }
                    ),
                )
            except Exception as e:
                return f"Error getting status: {e}"

        async def get_pending_items(self) -> str:
            """Get items pending approval as HTML card."""
            try:
                response = await self.http_client.post(
                    f"{QDRANT_URL}/collections/validations/points/scroll",
                    json={
                        "filter": {
                            "must": [
                                {
                                    "key": "status",
                                    "match": {"value": "pending"},
                                }
                            ]
                        },
                        "limit": 10,
                    },
                )
                if response.status_code == 200:
                    points = (
                        response.json()
                        .get("result", {})
                        .get("points", [])
                    )
                    if not points:
                        return MessageFormatter.card(
                            "Pending Approvals",
                            "ok",
                            "<p>No pending items.</p>",
                        )

                    rows = []
                    for p in points:
                        payload = p.get("payload", {})
                        rows.append(
                            [
                                payload.get("target_type", ""),
                                payload.get("target_id", ""),
                            ]
                        )

                    table = MessageFormatter.table(
                        ["Type", "Target"], rows
                    )
                    return MessageFormatter.card(
                        "Pending Approvals", "info", table
                    )
                return "Could not fetch pending items."
            except Exception as e:
                return f"Error: {e}"

        async def get_pending_count(self) -> int:
            """Get count of pending items."""
            try:
                response = await self.http_client.post(
                    f"{QDRANT_URL}/collections/validations/points/count",
                    json={
                        "filter": {
                            "must": [
                                {
                                    "key": "status",
                                    "match": {"value": "pending"},
                                }
                            ]
                        },
                    },
                )
                if response.status_code == 200:
                    return (
                        response.json()
                        .get("result", {})
                        .get("count", 0)
                    )
                return 0
            except Exception:
                return 0

        async def get_original_message(
            self, room_id: str, event_id: str
        ) -> tuple:
            """Fetch the original message content and sender."""
            try:
                url = (
                    f"{MATRIX_HOMESERVER}/_matrix/client/v3/rooms/"
                    f"{room_id}/event/{event_id}"
                )
                headers = {
                    "Authorization": f"Bearer {self.client.access_token}"
                }
                response = await self.http_client.get(
                    url, headers=headers
                )
                if response.status_code == 200:
                    event_data = response.json()
                    content = event_data.get("content", {})
                    sender = event_data.get("sender", "")
                    body = content.get("body", "")
                    return body, sender
                else:
                    logger.warning(
                        f"Failed to fetch event {event_id}: "
                        f"{response.status_code}"
                    )
                    return None, None
            except Exception as e:
                logger.error(f"Error fetching original message: {e}")
                return None, None

        def markdown_to_html(self, text: str) -> str:
            """Simple markdown to HTML conversion."""
            import re

            text = re.sub(
                r"\*\*(.+?)\*\*", r"<strong>\1</strong>", text
            )
            text = re.sub(r"\*(.+?)\*", r"<em>\1</em>", text)
            text = re.sub(r"`(.+?)`", r"<code>\1</code>", text)
            text = text.replace("\n", "<br/>")
            return text

        async def run(self):
            """Main run loop."""
            if not await self.login():
                return

            await self.setup_callbacks()
            await self.ensure_space_structure()
            await self.update_presence()
            logger.info("Bot started, syncing with sync_forever...")

            await self.client.sync_forever(
                timeout=30000, full_state=True, loop_sleep_time=1000
            )


    # â”€â”€ FastAPI Application â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    bot_instance: Optional[AgenticMatrixBot] = None


    class AlertRequest(BaseModel):
        """Incoming alert from alerting pipeline."""

        name: str
        severity: str = "info"
        description: str
        source: str = "unknown"
        suggested_fix: Optional[str] = None
        context: Optional[str] = None
        room_id: Optional[str] = None


    class MessageRequest(BaseModel):
        """Send a message to a room."""

        room_id: str
        message: str


    class BrainTrustRequest(BaseModel):
        """Brain Trust escalation notification."""

        alert_name: str
        alert_id: str
        severity: str = "info"
        reason: str
        outline_url: str
        outline_doc_id: str
        context_summary: Optional[str] = None
        suggestions: Optional[list] = None
        room_id: Optional[str] = None


    async def poll_reactions_loop(bot: "AgenticMatrixBot", interval: int = 10):
        """Poll for reactions on pending approvals (workaround for Conduit not sending reactions in sync)."""
        logger.info(f"Starting reaction polling loop (interval={interval}s)")
        poll_count = 0
        while True:
            try:
                await asyncio.sleep(interval)
                poll_count += 1
                # Get all pending approvals from Redis
                pending_keys = await bot.state.redis.keys("matrix:approval:*")
                if poll_count % 6 == 0:  # Log every minute
                    logger.info(f"POLL #{poll_count}: Found {len(pending_keys) if pending_keys else 0} pending approvals")
                if not pending_keys:
                    continue

                for key in pending_keys:
                    # Handle both bytes and str keys (depends on redis library version)
                    key_str = key.decode() if isinstance(key, bytes) else str(key)
                    event_id = key_str.replace("matrix:approval:", "")
                    logger.info(f"POLL: Checking event {event_id}")
                    pending = await bot._get_pending_approval(event_id)
                    if not pending:
                        logger.info(f"POLL: No pending data for {event_id}")
                        continue

                    room_id = pending.get("room_id")
                    if not room_id:
                        logger.info(f"POLL: No room_id in pending for {event_id}")
                        continue

                    logger.info(f"POLL: Querying reactions for event {event_id} in room {room_id}")
                    # Query reactions via Matrix relations API using httpx directly
                    try:
                        import urllib.parse
                        encoded_room = urllib.parse.quote(room_id, safe='')
                        encoded_event = urllib.parse.quote(event_id, safe='')
                        url = f"{MATRIX_HOMESERVER}/_matrix/client/v1/rooms/{encoded_room}/relations/{encoded_event}/m.annotation"
                        headers = {"Authorization": f"Bearer {bot.client.access_token}"}
                        async with httpx.AsyncClient() as http_client:
                            response = await http_client.get(url, headers=headers, timeout=10.0)
                            if response.status_code == 200:
                                resp = response.json()
                            else:
                                logger.info(f"POLL: Relations API returned {response.status_code}: {response.text[:200]}")
                                resp = {}
                        logger.info(f"POLL: Relations API response: {resp}")
                        if resp and "chunk" in resp:
                            for reaction in resp["chunk"]:
                                sender = reaction.get("sender", "")
                                key_emoji = reaction.get("content", {}).get("m.relates_to", {}).get("key", "")
                                # Skip bot's own reactions
                                if sender == bot.client.user_id:
                                    continue
                                # Skip if already processed
                                processed_key = f"matrix:reaction_processed:{event_id}:{sender}:{key_emoji}"
                                if await bot.state.redis.exists(processed_key):
                                    continue

                                logger.info(f"POLL: Reaction found: key={key_emoji!r} from={sender} on event={event_id}")

                                # Mark as processed
                                await bot.state.redis.setex(processed_key, 3600, "1")

                                # Process approval reactions
                                if key_emoji == "\u2705":  # âœ…
                                    logger.info(f"POLL: Processing approval from {sender}")
                                    await bot.process_approval(room_id, event_id, pending, approved=True, user=sender)
                                elif key_emoji == "\u274c":  # âŒ
                                    logger.info(f"POLL: Processing rejection from {sender}")
                                    await bot.process_approval(room_id, event_id, pending, approved=False, user=sender)
                    except Exception as e:
                        logger.info(f"POLL: Relations API call failed for {event_id}: {e}")

            except Exception as e:
                logger.error(f"Reaction polling error: {e}")
                await asyncio.sleep(5)


    @asynccontextmanager
    async def lifespan(app: FastAPI):
        """Manage bot lifecycle."""
        global bot_instance
        bot_instance = AgenticMatrixBot()

        if await bot_instance.login():
            await bot_instance.setup_callbacks()
            await bot_instance.ensure_space_structure()
            await bot_instance.update_presence()
            asyncio.create_task(
                bot_instance.client.sync_forever(
                    timeout=30000,
                    full_state=True,
                    loop_sleep_time=1000,
                )
            )
            # Start reaction polling (workaround for Conduit)
            asyncio.create_task(poll_reactions_loop(bot_instance, interval=10))
            logger.info("Matrix bot started and syncing (with reaction polling)")

        yield

        if bot_instance:
            await bot_instance.client.close()


    app = FastAPI(title="Matrix Bot API", lifespan=lifespan)


    @app.get("/health")
    async def health():
        """Health check endpoint."""
        if bot_instance and bot_instance.client.logged_in:
            redis_ok = await bot_instance.state.health_check()
            return {
                "status": "healthy",
                "logged_in": True,
                "redis": redis_ok,
            }
        return {"status": "unhealthy", "logged_in": False}


    @app.post("/alert")
    async def receive_alert(alert: AlertRequest):
        """Receive alert: rich card + Redis + threading + Grafana + incident room."""
        if not bot_instance or not bot_instance.client.logged_in:
            return {"status": "error", "message": "Bot not logged in"}

        room_id = alert.room_id or bot_instance.route_room(
            severity=alert.severity
        )

        # Build alert card
        details = {
            "Severity": MessageFormatter.status_badge(alert.severity),
            "Source": alert.source,
        }
        if alert.suggested_fix:
            details["Suggested Fix"] = alert.suggested_fix

        body = f"<p>{alert.description}</p><br/>"
        body += MessageFormatter.kv_table(details)

        if alert.context:
            body += "<br/>"
            body += MessageFormatter.collapsible(
                "Raw Context", f"<pre>{alert.context[:500]}</pre>"
            )

        card_html = MessageFormatter.card(
            alert.name, alert.severity, body
        )
        plain = (
            f"[{alert.severity.upper()}] {alert.name}: "
            f"{alert.description}"
        )

        try:
            # 1. Send alert card FIRST
            resp = await bot_instance.send_message(
                room_id, plain, card_html
            )
            root_event_id = (
                resp.event_id if hasattr(resp, "event_id") else None
            )

            # React with bell
            if root_event_id:
                await bot_instance.react_to_message(
                    room_id, root_event_id, "\U0001f514"
                )

            # 2. Generate alert_id from name
            alert_id = alert.name.lower().replace(" ", "-")

            # 3. Store in Redis + create incident room for critical
            incident_room_id = None
            if root_event_id:
                if alert.severity.lower() == "critical":
                    incident_room_id = (
                        await bot_instance.create_incident_room(
                            alert_id,
                            alert.name,
                            alert.severity,
                            alert.description,
                        )
                    )

                await bot_instance.state.store_alert(
                    alert_id,
                    {
                        "room_id": room_id,
                        "root_event_id": root_event_id,
                        "incident_room_id": incident_room_id,
                        "alert_name": alert.name,
                        "severity": alert.severity,
                        "created_at": datetime.now().isoformat(),
                    },
                )

                # 4. Grafana snapshot (fire-and-forget)
                asyncio.create_task(
                    bot_instance._attach_grafana_snapshot(
                        room_id, root_event_id, alert.name
                    )
                )

            await bot_instance.update_presence()

            return {
                "status": "sent",
                "room_id": room_id,
                "event_id": root_event_id,
                "alert_id": alert_id,
                "incident_room_id": incident_room_id,
            }
        except Exception as e:
            logger.error(f"Failed to send alert: {e}")
            return {"status": "error", "message": str(e)}


    @app.post("/message")
    async def send_message_endpoint(req: MessageRequest):
        """Send a message to a specific room."""
        if not bot_instance or not bot_instance.client.logged_in:
            return {"status": "error", "message": "Bot not logged in"}

        try:
            await bot_instance.send_message(req.room_id, req.message)
            return {"status": "sent", "room_id": req.room_id}
        except Exception as e:
            logger.error(f"Failed to send message: {e}")
            return {"status": "error", "message": str(e)}


    @app.post("/approval")
    async def request_approval(request: Request):
        """Receive approval request: rich card + thread under alert + Redis."""
        if not bot_instance or not bot_instance.client.logged_in:
            return {"status": "error", "message": "Bot not logged in"}

        try:
            payload = await request.json()
        except Exception as e:
            return {"status": "error", "message": str(e)}

        logger.info(
            f"Received approval request: {json.dumps(payload)[:500]}"
        )

        alert_id = payload.get("alert_id")
        if not alert_id:
            return {"status": "error", "message": "alert_id is required"}

        alert_name = (
            payload.get("alert_name")
            or payload.get("alertname")
            or payload.get("name")
            or payload.get("title")
            or "Unknown Alert"
        )
        severity = (
            payload.get("severity") or payload.get("level") or "info"
        )
        description = (
            payload.get("description")
            or payload.get("message")
            or payload.get("summary")
            or ""
        )
        assessment = (
            payload.get("assessment")
            or payload.get("analysis")
            or payload.get("ai_response")
            or ""
        )
        suggested_action = (
            payload.get("suggested_action")
            or payload.get("action")
            or payload.get("recommendation")
            or payload.get("suggested_fix")
            or None
        )
        solutions = payload.get("solutions", [])
        runbook = (
            payload.get("runbook")
            or payload.get("runbook_url")
            or None
        )
        room_id = payload.get("room_id") or bot_instance.route_room(
            severity=severity
        )

        # Build approval card
        details = {
            "Alert ID": f"<code>{alert_id}</code>",
            "Severity": MessageFormatter.status_badge(severity),
        }
        body = MessageFormatter.kv_table(details)

        if description:
            body += f"<br/><h4>Description</h4><p>{description}</p>"
        if assessment:
            body += f"<br/><h4>AI Assessment</h4><p>{assessment}</p>"
        if suggested_action:
            body += f"<br/><h4>Suggested Action</h4><p>{suggested_action}</p>"
        if runbook:
            body += f"<br/><p><strong>Runbook:</strong> {runbook}</p>"

        footer = (
            "<em>React: \u2705 approve \u00b7 \u274c reject "
            "\u00b7 \U0001f914 more info \u00b7 \u23f8\ufe0f pause</em>"
        )
        card_html = MessageFormatter.card(
            f"Approval Needed: {alert_name}", severity, body, footer
        )
        plain = (
            f"[{severity.upper()}] Approval Needed: "
            f"{alert_name} ({alert_id})"
        )

        try:
            # Thread under existing alert if available
            alert_state = await bot_instance.state.get_alert(alert_id)
            if alert_state and alert_state.get("root_event_id"):
                response = await bot_instance.send_thread_reply(
                    alert_state["room_id"],
                    alert_state["root_event_id"],
                    plain,
                    card_html,
                )
                room_id = alert_state["room_id"]
            else:
                response = await bot_instance.send_message(
                    room_id, plain, card_html
                )

            event_id = (
                response.event_id
                if hasattr(response, "event_id")
                else None
            )

            if event_id:
                await bot_instance._store_pending_approval(
                    event_id,
                    {
                        "alert_id": alert_id,
                        "alert_name": alert_name,
                        "solutions": solutions,
                        "room_id": room_id,
                        "created_at": time.time(),
                    },
                )

            logger.info(
                f"Approval sent: {alert_name} "
                f"(event={event_id}, alert={alert_id})"
            )

            return {
                "status": "sent",
                "room_id": room_id,
                "event_id": event_id,
                "alert_id": alert_id,
                "alert_name": alert_name,
            }
        except Exception as e:
            logger.error(f"Failed to send approval: {e}")
            import traceback

            logger.error(traceback.format_exc())
            return {"status": "error", "message": str(e)}


    @app.post("/brain-trust")
    async def brain_trust_escalation(request: BrainTrustRequest):
        """Brain Trust escalation: rich card threaded under alert."""
        if not bot_instance or not bot_instance.client.logged_in:
            return {"status": "error", "message": "Bot not logged in"}

        logger.info(
            f"Brain Trust escalation: {request.alert_name} "
            f"-> {request.outline_url}"
        )

        room_id = request.room_id or bot_instance.route_room(
            msg_type="brain-trust"
        )

        # Build card
        details = {
            "Alert": request.alert_name,
            "Alert ID": f"<code>{request.alert_id}</code>",
            "Severity": MessageFormatter.status_badge(request.severity),
        }
        body = MessageFormatter.kv_table(details)
        body += f"<br/><h4>Why Escalated</h4><p>{request.reason}</p>"

        if request.context_summary:
            body += "<br/>"
            body += MessageFormatter.collapsible(
                "Context Gathered",
                f"<p>{request.context_summary[:500]}</p>",
            )

        if request.suggestions:
            body += "<br/><h4>Ollama's Suggestions</h4><ol>"
            for s in request.suggestions[:3]:
                name = s.get("name", "Option")
                desc = s.get("description", "")[:200]
                body += f"<li><strong>{name}</strong>: {desc}</li>"
            body += "</ol>"

        body += (
            f'<br/><p><strong>Review in Outline:</strong> '
            f'<a href="{request.outline_url}">'
            f"{request.outline_url}</a></p>"
        )

        footer = (
            "<em>After Brain Trust decision, bring implementation "
            "tasks to Claude Code.</em>"
        )
        card_html = MessageFormatter.card(
            "\U0001f9e0 Brain Trust Review Needed",
            request.severity,
            body,
            footer,
        )
        plain = (
            f"[Brain Trust] {request.alert_name}: {request.reason}"
        )

        try:
            # Thread under alert if it exists
            alert_state = await bot_instance.state.get_alert(
                request.alert_id
            )
            if alert_state and alert_state.get("root_event_id"):
                response = await bot_instance.send_thread_reply(
                    alert_state["room_id"],
                    alert_state["root_event_id"],
                    plain,
                    card_html,
                )
            else:
                response = await bot_instance.send_message(
                    room_id, plain, card_html
                )

            event_id = (
                response.event_id
                if hasattr(response, "event_id")
                else None
            )

            return {
                "status": "sent",
                "room_id": room_id,
                "event_id": event_id,
                "alert_id": request.alert_id,
                "outline_doc_id": request.outline_doc_id,
            }
        except Exception as e:
            logger.error(
                f"Failed to send Brain Trust notification: {e}"
            )
            return {"status": "error", "message": str(e)}


    @app.post("/runbook-proposal")
    async def runbook_proposal(request: Request):
        """Runbook update proposal: rich card."""
        if not bot_instance or not bot_instance.client.logged_in:
            return {"status": "error", "message": "Bot not logged in"}

        try:
            payload = await request.json()
        except Exception as e:
            return {"status": "error", "message": str(e)}

        logger.info(
            f"Runbook proposal: {json.dumps(payload)[:300]}"
        )

        alert_name = payload.get("alert_name", "Unknown Alert")
        runbook_title = payload.get("runbook_title", "Unknown Runbook")
        tweaks_made = payload.get(
            "tweaks_made", "No details provided"
        )
        outline_url = payload.get("outline_url", "")
        success = payload.get("execution_success", True)
        room_id = payload.get(
            "room_id"
        ) or bot_instance.route_room(msg_type="brain-trust")

        status_text = "Successful" if success else "Partial"
        status_severity = "ok" if success else "warning"

        exec_emoji = "\u2705" if success else "\u26a0\ufe0f"
        details = {
            "Alert": alert_name,
            "Matched Runbook": runbook_title,
            "Execution": f"{exec_emoji} {status_text}",
        }
        body = MessageFormatter.kv_table(details)
        body += f"<br/><h4>Tweaks Made</h4><p>{tweaks_made[:500]}</p>"

        if outline_url:
            body += (
                f'<br/><p><strong>Review Proposal:</strong> '
                f'<a href="{outline_url}">{outline_url}</a></p>'
            )

        footer = (
            "<em>Approve in Brain Trust to update the runbook "
            "for future use.</em>"
        )
        card_html = MessageFormatter.card(
            "\U0001f4dd Runbook Update Proposal",
            status_severity,
            body,
            footer,
        )
        plain = (
            f"[Runbook Proposal] {alert_name}: "
            f"{runbook_title} - {status_text}"
        )

        try:
            await bot_instance.send_message(room_id, plain, card_html)
            return {"status": "sent", "room_id": room_id}
        except Exception as e:
            logger.error(f"Failed to send runbook proposal: {e}")
            return {"status": "error", "message": str(e)}


    if __name__ == "__main__":
        uvicorn.run(app, host="0.0.0.0", port=8000)

  requirements.txt: |
    matrix-nio[e2e]>=0.24.0
    httpx>=0.27.0
    aiohttp>=3.9.0
    fastapi>=0.109.0
    uvicorn>=0.27.0
    redis[hiredis]>=5.0.0
