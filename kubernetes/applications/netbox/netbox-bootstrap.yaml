---
# NetBox Bootstrap Job
# Creates foundational data model: Custom Fields, Manufacturers, Device Types, Device Roles, Sites, Prefixes
# Run once after NetBox deployment to establish the schema
apiVersion: v1
kind: ConfigMap
metadata:
  name: netbox-bootstrap-code
  namespace: ai-platform
data:
  bootstrap.py: |
    #!/usr/bin/env python3
    """
    NetBox Bootstrap Script

    Establishes the foundational data model for the Kernow homelab.
    Creates objects in dependency order per NetBox requirements:
    1. Custom Fields
    2. Manufacturers
    3. Device Types
    4. Device Roles
    5. Sites
    6. Prefixes

    All operations are idempotent - safe to run multiple times.
    """
    import os
    import json
    import logging
    import urllib.request
    import urllib.error
    import time

    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
    logger = logging.getLogger(__name__)

    NETBOX_URL = os.environ.get("NETBOX_URL", "http://netbox:8080")
    NETBOX_TOKEN = os.environ.get("NETBOX_TOKEN", "")

    # ===========================================
    # DATA DEFINITIONS
    # ===========================================

    CUSTOM_FIELDS = [
        {
            "name": "mac_address",
            "type": "text",
            "label": "MAC Address",
            "description": "Device MAC address",
            "object_types": ["dcim.device", "dcim.interface"]
        },
        {
            "name": "credentials_path",
            "type": "text",
            "label": "Credentials Path",
            "description": "Infisical path for credentials",
            "object_types": ["dcim.device", "ipam.service"]
        },
        {
            "name": "api_endpoint",
            "type": "url",
            "label": "API Endpoint",
            "description": "API/UI endpoint URL",
            "object_types": ["dcim.device", "ipam.service"]
        },
        {
            "name": "discovery_source",
            "type": "text",
            "label": "Discovery Source",
            "description": "How device was discovered (seed, nmap, dhcp, unifi, etc.)",
            "object_types": ["dcim.device", "ipam.ipaddress"]
        },
        {
            "name": "last_discovered",
            "type": "datetime",
            "label": "Last Discovered",
            "description": "When device was last seen by discovery",
            "object_types": ["dcim.device", "ipam.ipaddress"]
        },
        {
            "name": "k8s_cluster",
            "type": "text",
            "label": "K8s Cluster",
            "description": "Which Kubernetes cluster this device belongs to",
            "object_types": ["dcim.device"]
        },
        {
            "name": "unifi_client_mac",
            "type": "text",
            "label": "UniFi Client MAC",
            "description": "UniFi client MAC if this is a WiFi device",
            "object_types": ["dcim.device"]
        }
    ]

    MANUFACTURERS = [
        {"name": "Proxmox", "slug": "proxmox", "description": "Proxmox VE Hypervisor"},
        {"name": "Sidero Labs", "slug": "sidero-labs", "description": "Talos Linux OS"},
        {"name": "Ubiquiti", "slug": "ubiquiti", "description": "UniFi Network Equipment"},
        {"name": "Deciso", "slug": "deciso", "description": "OPNsense Firewall"},
        {"name": "iXsystems", "slug": "ixsystems", "description": "TrueNAS Storage"},
        {"name": "Minisforum", "slug": "minisforum", "description": "Mini PC Hardware"},
        {"name": "Generic", "slug": "generic", "description": "Generic/Unknown Hardware"}
    ]

    DEVICE_TYPES = [
        {
            "manufacturer": "proxmox",
            "model": "Proxmox VE 8.x",
            "slug": "proxmox-ve-host",
            "part_number": "PVE-8",
            "u_height": 0,
            "is_full_depth": False,
            "description": "Proxmox hypervisor node"
        },
        {
            "manufacturer": "sidero-labs",
            "model": "Talos Control Plane",
            "slug": "talos-control-plane",
            "part_number": "TALOS-CP",
            "u_height": 0,
            "is_full_depth": False,
            "description": "Kubernetes control plane node running Talos"
        },
        {
            "manufacturer": "sidero-labs",
            "model": "Talos Worker",
            "slug": "talos-worker",
            "part_number": "TALOS-WORKER",
            "u_height": 0,
            "is_full_depth": False,
            "description": "Kubernetes worker node running Talos"
        },
        {
            "manufacturer": "ubiquiti",
            "model": "UniFi Access Point",
            "slug": "unifi-access-point",
            "part_number": "UAP-GENERIC",
            "u_height": 0,
            "is_full_depth": False,
            "description": "UniFi WiFi access point"
        },
        {
            "manufacturer": "ubiquiti",
            "model": "UniFi Switch",
            "slug": "unifi-switch",
            "part_number": "USW-GENERIC",
            "u_height": 0,
            "is_full_depth": False,
            "description": "UniFi network switch"
        },
        {
            "manufacturer": "deciso",
            "model": "OPNsense Firewall",
            "slug": "opnsense-firewall",
            "part_number": "OPNS-FW",
            "u_height": 0,
            "is_full_depth": False,
            "description": "OPNsense router/firewall appliance"
        },
        {
            "manufacturer": "ixsystems",
            "model": "TrueNAS Scale",
            "slug": "truenas-scale",
            "part_number": "TNAS-SCALE",
            "u_height": 0,
            "is_full_depth": False,
            "description": "TrueNAS SCALE storage appliance"
        },
        {
            "manufacturer": "minisforum",
            "model": "UM690L",
            "slug": "um690l",
            "part_number": "UM690L",
            "u_height": 0,
            "is_full_depth": False,
            "description": "Minisforum UM690L AMD Ryzen mini PC"
        },
        {
            "manufacturer": "generic",
            "model": "Unknown Device",
            "slug": "unknown-device",
            "part_number": "UNKNOWN",
            "u_height": 0,
            "is_full_depth": False,
            "description": "Discovered but unclassified device"
        },
        {
            "manufacturer": "generic",
            "model": "Virtual Machine",
            "slug": "virtual-machine",
            "part_number": "VM",
            "u_height": 0,
            "is_full_depth": False,
            "description": "Virtual machine instance"
        }
    ]

    DEVICE_ROLES = [
        {"name": "Hypervisor", "slug": "hypervisor", "color": "00bcd4", "vm_role": False, "description": "Proxmox/ESXi hosts"},
        {"name": "K8s Control Plane", "slug": "k8s-control-plane", "color": "3f51b5", "vm_role": True, "description": "Kubernetes control plane nodes"},
        {"name": "K8s Worker", "slug": "k8s-worker", "color": "2196f3", "vm_role": True, "description": "Kubernetes worker nodes"},
        {"name": "Router/Firewall", "slug": "router-firewall", "color": "f44336", "vm_role": False, "description": "OPNsense, routers, firewalls"},
        {"name": "Storage", "slug": "storage", "color": "4caf50", "vm_role": False, "description": "TrueNAS, NAS devices"},
        {"name": "Access Point", "slug": "access-point", "color": "9c27b0", "vm_role": False, "description": "WiFi access points"},
        {"name": "WiFi Client", "slug": "wifi-client", "color": "e91e63", "vm_role": False, "description": "Connected WiFi devices"},
        {"name": "Infrastructure", "slug": "infrastructure", "color": "795548", "vm_role": False, "description": "General infrastructure devices"},
        {"name": "IoT Device", "slug": "iot-device", "color": "ff9800", "vm_role": False, "description": "Smart home/IoT devices"},
        {"name": "Workstation", "slug": "workstation", "color": "607d8b", "vm_role": False, "description": "Desktops, laptops"}
    ]

    SITES = [
        {
            "name": "Production Cluster",
            "slug": "prod-cluster",
            "status": "active",
            "description": "Ruapehu Proxmox host with production K8s cluster (10.10.0.0/24)"
        },
        {
            "name": "Agentic Cluster",
            "slug": "agentic-cluster",
            "status": "active",
            "description": "UM690L bare metal AI platform cluster (10.20.0.0/24)"
        },
        {
            "name": "Monitoring Cluster",
            "slug": "monit-cluster",
            "status": "active",
            "description": "Carrick Proxmox host with monitoring K8s (10.30.0.0/24)"
        }
    ]

    PREFIXES = [
        {"prefix": "10.10.0.0/24", "site": "prod-cluster", "status": "active", "description": "Production network"},
        {"prefix": "10.20.0.0/24", "site": "agentic-cluster", "status": "active", "description": "Agentic AI platform network"},
        {"prefix": "10.30.0.0/24", "site": "monit-cluster", "status": "active", "description": "Monitoring network"},
        {"prefix": "10.40.0.0/24", "site": "prod-cluster", "status": "active", "description": "NFS/Storage network (vmbr3)"},
        {"prefix": "10.50.0.0/24", "site": "prod-cluster", "status": "active", "description": "Mayastor replication network (vmbr4)"}
    ]

    # ===========================================
    # API HELPERS
    # ===========================================

    def netbox_api(endpoint: str, method: str = "GET", data: dict = None) -> dict:
        """Make NetBox API call with error handling."""
        url = f"{NETBOX_URL}/api{endpoint}"
        headers = {
            "Authorization": f"Token {NETBOX_TOKEN}",
            "Content-Type": "application/json",
            "Accept": "application/json"
        }

        req = urllib.request.Request(url, headers=headers, method=method)
        if data:
            req.data = json.dumps(data).encode()

        try:
            with urllib.request.urlopen(req, timeout=30) as resp:
                return json.loads(resp.read())
        except urllib.error.HTTPError as e:
            body = e.read().decode()[:500]
            logger.warning(f"NetBox API error: {e.code} - {body}")
            return None
        except Exception as e:
            logger.error(f"NetBox API error: {e}")
            return None

    def get_or_create(endpoint: str, lookup_field: str, lookup_value: str, data: dict) -> dict:
        """Get existing object or create new one. Returns the object."""
        # Try to find existing
        existing = netbox_api(f"{endpoint}?{lookup_field}={lookup_value}")
        if existing and existing.get("results"):
            logger.info(f"  Found existing: {lookup_value}")
            return existing["results"][0]

        # Create new
        result = netbox_api(endpoint, "POST", data)
        if result:
            logger.info(f"  Created: {lookup_value}")
            return result
        else:
            logger.error(f"  Failed to create: {lookup_value}")
            return None

    # ===========================================
    # BOOTSTRAP FUNCTIONS
    # ===========================================

    def create_custom_fields():
        """Create custom fields for device metadata."""
        logger.info("Creating custom fields...")
        for cf in CUSTOM_FIELDS:
            # Check if exists
            existing = netbox_api(f"/extras/custom-fields/?name={cf['name']}")
            if existing and existing.get("results"):
                logger.info(f"  Custom field exists: {cf['name']}")
                continue

            # Create custom field
            cf_data = {
                "name": cf["name"],
                "type": cf["type"],
                "label": cf["label"],
                "description": cf["description"],
                "object_types": cf["object_types"],
                "filter_logic": "loose",
                "ui_visible": "always",
                "ui_editable": "yes",
                "is_cloneable": True
            }
            result = netbox_api("/extras/custom-fields/", "POST", cf_data)
            if result:
                logger.info(f"  Created custom field: {cf['name']}")
            else:
                logger.error(f"  Failed to create custom field: {cf['name']}")

        time.sleep(0.5)  # Brief pause between operations

    def create_manufacturers():
        """Create manufacturers."""
        logger.info("Creating manufacturers...")
        for mfr in MANUFACTURERS:
            get_or_create("/dcim/manufacturers/", "slug", mfr["slug"], mfr)
        time.sleep(0.5)

    def create_device_types():
        """Create device types (requires manufacturers to exist)."""
        logger.info("Creating device types...")

        # Cache manufacturer IDs
        mfr_cache = {}
        mfrs = netbox_api("/dcim/manufacturers/")
        if mfrs and mfrs.get("results"):
            for m in mfrs["results"]:
                mfr_cache[m["slug"]] = m["id"]

        for dt in DEVICE_TYPES:
            mfr_id = mfr_cache.get(dt["manufacturer"])
            if not mfr_id:
                logger.error(f"  Manufacturer not found: {dt['manufacturer']}")
                continue

            dt_data = {
                "manufacturer": mfr_id,
                "model": dt["model"],
                "slug": dt["slug"],
                "part_number": dt.get("part_number", ""),
                "u_height": dt.get("u_height", 0),
                "is_full_depth": dt.get("is_full_depth", False),
                "description": dt.get("description", "")
            }
            get_or_create("/dcim/device-types/", "slug", dt["slug"], dt_data)

        time.sleep(0.5)

    def create_device_roles():
        """Create device roles."""
        logger.info("Creating device roles...")
        for role in DEVICE_ROLES:
            get_or_create("/dcim/device-roles/", "slug", role["slug"], role)
        time.sleep(0.5)

    def create_sites():
        """Create sites."""
        logger.info("Creating sites...")
        for site in SITES:
            get_or_create("/dcim/sites/", "slug", site["slug"], site)
        time.sleep(0.5)

    def create_prefixes():
        """Create IP prefixes (requires sites to exist)."""
        logger.info("Creating prefixes...")

        # Cache site IDs
        site_cache = {}
        sites = netbox_api("/dcim/sites/")
        if sites and sites.get("results"):
            for s in sites["results"]:
                site_cache[s["slug"]] = s["id"]

        for prefix in PREFIXES:
            site_id = site_cache.get(prefix["site"])
            if not site_id:
                logger.warning(f"  Site not found for prefix: {prefix['prefix']}")
                continue

            prefix_data = {
                "prefix": prefix["prefix"],
                "site": site_id,
                "status": prefix["status"],
                "description": prefix["description"]
            }
            get_or_create("/ipam/prefixes/", "prefix", prefix["prefix"], prefix_data)

        time.sleep(0.5)

    # ===========================================
    # MAIN
    # ===========================================

    def main():
        logger.info("=" * 60)
        logger.info("NetBox Bootstrap - Kernow Homelab")
        logger.info("=" * 60)

        if not NETBOX_TOKEN:
            logger.error("NETBOX_TOKEN not set!")
            return

        # Test connection
        result = netbox_api("/status/")
        if not result:
            logger.error("Cannot connect to NetBox API")
            return
        logger.info(f"Connected to NetBox {result.get('netbox-version', 'unknown')}")

        # Create objects in dependency order
        create_custom_fields()
        create_manufacturers()
        create_device_types()
        create_device_roles()
        create_sites()
        create_prefixes()

        logger.info("=" * 60)
        logger.info("Bootstrap complete!")
        logger.info("=" * 60)

    if __name__ == "__main__":
        main()
---
apiVersion: batch/v1
kind: Job
metadata:
  name: netbox-bootstrap
  namespace: ai-platform
  annotations:
    argocd.argoproj.io/hook: PostSync
    argocd.argoproj.io/hook-delete-policy: BeforeHookCreation
spec:
  ttlSecondsAfterFinished: 3600
  backoffLimit: 3
  template:
    spec:
      restartPolicy: OnFailure
      initContainers:
        - name: wait-for-netbox
          image: busybox:1.36
          command: ['sh', '-c']
          args:
            - |
              echo "Waiting for NetBox to be ready..."
              for i in $(seq 1 60); do
                if wget -q -O- http://netbox:8080/api/status/ 2>/dev/null | grep -q netbox-version; then
                  echo "NetBox is ready!"
                  exit 0
                fi
                echo "Attempt $i/60 - NetBox not ready yet..."
                sleep 5
              done
              echo "Timeout waiting for NetBox"
              exit 1
      containers:
        - name: bootstrap
          image: python:3.11-slim
          command: ["python", "/app/bootstrap.py"]
          env:
            - name: NETBOX_URL
              value: "http://netbox:8080"
            - name: NETBOX_TOKEN
              valueFrom:
                secretKeyRef:
                  name: netbox-credentials
                  key: API_TOKEN
          volumeMounts:
            - name: code
              mountPath: /app
          resources:
            requests:
              memory: "128Mi"
              cpu: "100m"
            limits:
              memory: "256Mi"
              cpu: "500m"
      volumes:
        - name: code
          configMap:
            name: netbox-bootstrap-code
