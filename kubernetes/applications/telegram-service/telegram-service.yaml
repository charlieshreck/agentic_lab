apiVersion: v1
kind: ConfigMap
metadata:
  name: telegram-service-code
  namespace: ai-platform
  labels:
    app: telegram-service
data:
  main.py: |
    #!/usr/bin/env python3
    """Telegram Service for Human-in-the-Loop Workflows."""
    import os
    import logging
    import uuid
    from typing import Optional, Dict, List, Any
    from datetime import datetime

    from fastapi import FastAPI, Request, HTTPException
    from pydantic import BaseModel
    import httpx
    import uvicorn
    import asyncio

    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger(__name__)

    BOT_TOKEN = os.environ.get("TELEGRAM_BOT_TOKEN", "")
    FORUM_CHAT_ID = os.environ.get("TELEGRAM_FORUM_CHAT_ID", "")
    WEBHOOK_URL = os.environ.get("WEBHOOK_URL", "")
    USE_POLLING = os.environ.get("USE_POLLING", "true").lower() == "true"
    LANGGRAPH_URL = os.environ.get("LANGGRAPH_URL", "http://langgraph:8000")
    CLAUDE_AGENT_URL = os.environ.get("CLAUDE_AGENT_URL", "http://claude-agent:8000")
    KNOWLEDGE_MCP_URL = os.environ.get("KNOWLEDGE_MCP_URL", "http://knowledge-mcp:8000")

    TELEGRAM_API = "https://api.telegram.org/bot" + BOT_TOKEN

    topics = {}
    polling_task = None
    last_update_id = 0
    app = FastAPI(title="Telegram Service")

    # Session store for conversation continuity
    # Key: "{chat_id}:{topic_id}" -> {session_id, messages: [], last_response, status}
    planning_sessions = {}

    class ApprovalRequest(BaseModel):
        alert_id: str
        alert: dict
        solutions: list
        context: dict
        topic: str = "infrastructure"

    class TelegramUpdate(BaseModel):
        update_id: int
        message: Optional[dict] = None
        callback_query: Optional[dict] = None

    async def telegram_request(method, data=None):
        async with httpx.AsyncClient(timeout=30.0) as client:
            try:
                response = await client.post(TELEGRAM_API + "/" + method, json=data or {})
                result = response.json()
                if not result.get("ok"):
                    logger.error("Telegram API error: %s", result)
                return result
            except Exception as e:
                logger.error("Telegram request failed: %s", e)
                return {"ok": False, "error": str(e)}

    async def send_message(chat_id, text, topic_id=None, reply_markup=None, parse_mode="Markdown"):
        data = {"chat_id": chat_id, "text": text, "parse_mode": parse_mode}
        if topic_id:
            data["message_thread_id"] = topic_id
        if reply_markup:
            data["reply_markup"] = reply_markup
        return await telegram_request("sendMessage", data)

    async def create_forum_topic(name):
        result = await telegram_request("createForumTopic", {"chat_id": FORUM_CHAT_ID, "name": name})
        if result.get("ok"):
            return result["result"]["message_thread_id"]
        return 0

    async def close_forum_topic(topic_id):
        await telegram_request("closeForumTopic", {"chat_id": FORUM_CHAT_ID, "message_thread_id": topic_id})

    async def initialize_standing_topics():
        global topics
        standing = [
            {"key": "critical", "name": "Critical Alerts"},
            {"key": "arr_suite", "name": "Arr Suite"},
            {"key": "infrastructure", "name": "Infrastructure"},
            {"key": "home_assistant", "name": "Home Assistant"},
            {"key": "weekly_reports", "name": "Weekly Reports"},
            {"key": "resolved", "name": "Resolved"}
        ]
        for topic in standing:
            topics[topic["key"]] = {"name": topic["name"], "topic_id": 1}
        logger.info("Initialized %d standing topics", len(topics))

    async def build_approval_keyboard(alert_id, solutions):
        buttons = []
        row = []
        for i, sol in enumerate(solutions, 1):
            name = sol.get("name", "Option")[:12]
            row.append({"text": str(i) + " " + name, "callback_data": "approve:" + alert_id + ":" + str(i)})
            if len(row) == 2:
                buttons.append(row)
                row = []
        if row:
            buttons.append(row)
        buttons.append([
            {"text": "Ignore", "callback_data": "ignore:" + alert_id},
            {"text": "Details", "callback_data": "details:" + alert_id}
        ])
        return {"inline_keyboard": buttons}

    async def poll_updates():
        global last_update_id
        logger.info("Starting long-polling for Telegram updates")
        while True:
            try:
                async with httpx.AsyncClient(timeout=60.0) as client:
                    response = await client.get(
                        TELEGRAM_API + "/getUpdates",
                        params={"offset": last_update_id + 1, "timeout": 30, "allowed_updates": ["message", "callback_query"]}
                    )
                    data = response.json()
                    if data.get("ok") and data.get("result"):
                        for update in data["result"]:
                            last_update_id = update["update_id"]
                            logger.info("Received update: %s", last_update_id)
                            if "callback_query" in update:
                                await handle_callback(update["callback_query"])
                            elif "message" in update:
                                await handle_message(update["message"])
            except asyncio.CancelledError:
                logger.info("Polling cancelled")
                break
            except Exception as e:
                logger.error("Polling error: %s", e)
                await asyncio.sleep(5)

    @app.on_event("startup")
    async def startup():
        global polling_task
        await initialize_standing_topics()
        if USE_POLLING and BOT_TOKEN:
            await telegram_request("deleteWebhook", {"drop_pending_updates": True})
            polling_task = asyncio.create_task(poll_updates())
            logger.info("Started polling mode")
        elif WEBHOOK_URL and BOT_TOKEN:
            result = await telegram_request("setWebhook", {
                "url": WEBHOOK_URL,
                "allowed_updates": ["message", "callback_query"],
                "drop_pending_updates": True
            })
            logger.info("Webhook registration: %s", result)

    @app.on_event("shutdown")
    async def shutdown():
        global polling_task
        if polling_task:
            polling_task.cancel()
            try:
                await polling_task
            except asyncio.CancelledError:
                pass
            logger.info("Polling stopped")

    @app.post("/webhook/telegram")
    async def telegram_webhook(request: Request):
        try:
            data = await request.json()
            logger.info("Received update: %s", data.get("update_id"))
            if "callback_query" in data:
                await handle_callback(data["callback_query"])
            elif "message" in data:
                await handle_message(data["message"])
            return {"ok": True}
        except Exception as e:
            logger.error("Webhook error: %s", e)
            raise HTTPException(status_code=500, detail=str(e))

    async def handle_callback(callback):
        callback_id = callback["id"]
        data = callback.get("data", "")
        user = callback.get("from", {}).get("username", "unknown")
        logger.info("Callback from @%s: %s", user, data)

        parts = data.split(":")
        action = parts[0]

        # Handle planning workflow callbacks
        if action == "plan" and len(parts) >= 3:
            plan_action = parts[1]  # continue, approve, decline
            session_id = parts[2]
            await handle_planning_callback(callback, plan_action, session_id)
            return

        # Default: answer callback for other actions
        await telegram_request("answerCallbackQuery", {"callback_query_id": callback_id})

        alert_id = parts[1] if len(parts) > 1 else None
        option = parts[2] if len(parts) > 2 else None
        if action == "approve" and alert_id and option:
            await process_approval(callback, alert_id, int(option), user)
        elif action == "ignore" and alert_id:
            await process_ignore(callback, alert_id, user)
        elif action == "details" and alert_id:
            await show_details(callback, alert_id)

    async def process_approval(callback, alert_id, option, user):
        message = callback.get("message", {})
        async with httpx.AsyncClient(timeout=120.0) as client:
            try:
                response = await client.post(
                    LANGGRAPH_URL + "/approve",
                    json={"alert_id": alert_id, "solution_index": option, "approved_by": user}
                )
                result = response.json()
                await telegram_request("editMessageText", {
                    "chat_id": message.get("chat", {}).get("id"),
                    "message_id": message.get("message_id"),
                    "text": message.get("text", "") + "\n\n*Approved by @" + user + "*: Option " + str(option),
                    "parse_mode": "Markdown"
                })
                chat_id = message.get("chat", {}).get("id")
                topic_id = message.get("message_thread_id")
                if result.get("success"):
                    summary = result.get("summary", "")
                    runbook = result.get("runbook_id", "pending")
                    await send_message(chat_id, "*Executed successfully*\n\n" + summary + "\n\nRunbook: `" + runbook + "`", topic_id=topic_id)
                else:
                    error = result.get("error", "Unknown error")
                    await send_message(chat_id, "*Execution failed*\n\n" + error, topic_id=topic_id)
            except Exception as e:
                logger.error("Approval failed: %s", e)
                await send_message(message.get("chat", {}).get("id"), "*Error processing approval*: " + str(e), topic_id=message.get("message_thread_id"))

    async def process_ignore(callback, alert_id, user):
        message = callback.get("message", {})
        async with httpx.AsyncClient(timeout=30.0) as client:
            await client.post(LANGGRAPH_URL + "/ignore", json={"alert_id": alert_id, "ignored_by": user})
        await telegram_request("editMessageText", {
            "chat_id": message.get("chat", {}).get("id"),
            "message_id": message.get("message_id"),
            "text": message.get("text", "") + "\n\n*Ignored by @" + user + "*",
            "parse_mode": "Markdown"
        })

    async def show_details(callback, alert_id):
        message = callback.get("message", {})
        async with httpx.AsyncClient(timeout=30.0) as client:
            response = await client.get(LANGGRAPH_URL + "/pending/" + alert_id)
            pending = response.json()
        if pending:
            alert = pending.get("alert", {})
            assessment = pending.get("assessment", {})
            details = "*Details for Alert " + alert_id + "*\n\n"
            details += "*Alert:* " + str(alert.get("alertname", "Unknown")) + "\n"
            details += "*Severity:* " + str(alert.get("severity", "warning")) + "\n"
            details += "*Namespace:* " + str(alert.get("namespace", "default")) + "\n"
            details += "*Description:* " + str(alert.get("description", "N/A")) + "\n\n"
            details += "*Assessment:*\n"
            details += "- Domain: " + str(assessment.get("domain", "unknown")) + "\n"
            details += "- Complexity: " + str(assessment.get("complexity", "unknown")) + "\n"
            details += "- Similar runbook: " + str(assessment.get("similar_runbook", "none")) + "\n"
            await send_message(message.get("chat", {}).get("id"), details, topic_id=message.get("message_thread_id"))
        else:
            await send_message(message.get("chat", {}).get("id"), "Alert " + alert_id + " not found or expired", topic_id=message.get("message_thread_id"))

    async def handle_message(message):
        import re
        raw_text = message.get("text", "").strip()
        # Strip bot mentions and leading slashes for command detection
        text = re.sub(r'@\w+', '', raw_text).strip().lstrip('/').lower()
        chat_id = message.get("chat", {}).get("id")
        topic_id = message.get("message_thread_id")
        session_key = f"{chat_id}:{topic_id}"
        username = message.get("from", {}).get("username", "unknown")
        logger.info("Processing message: '%s' (parsed: '%s') chat=%s", raw_text[:50], text[:50], chat_id)

        if not text:
            logger.info("Empty text, ignoring")
            return

        # Check for active planning session waiting for continuation
        session = planning_sessions.get(session_key)
        if session and session.get("status") == "awaiting_input":
            logger.info("Continuing session %s", session["session_id"][:8])
            await continue_planning_session(chat_id, topic_id, raw_text, username, session)
            return

        if text == "status":
            async with httpx.AsyncClient(timeout=30.0) as client:
                response = await client.get(LANGGRAPH_URL + "/status")
                status = response.json()
            status_text = "*System Status*\n\n"
            status_text += "*Pending Approvals:* " + str(status.get("pending_count", 0)) + "\n"
            status_text += "*Auto-executed (24h):* " + str(status.get("auto_executed", 0)) + "\n"
            status_text += "*Active Runbooks:* " + str(status.get("active_runbooks", 0)) + "\n"
            status_text += "*Learning Queue:* " + str(status.get("learning_queue", 0)) + "\n"
            await send_message(chat_id, status_text, topic_id=topic_id)
        elif text == "help":
            help_text = "*Available Commands*\n\n"
            help_text += "- `status` - Show system status\n"
            help_text += "- `help` - Show this help\n"
            help_text += "- `cancel` - Cancel current planning session\n"
            help_text += "- Or just ask any question to start a planning session\n"
            await send_message(chat_id, help_text, topic_id=topic_id)
        elif text == "cancel":
            if session_key in planning_sessions:
                del planning_sessions[session_key]
                await send_message(chat_id, "Planning session cancelled.", topic_id=topic_id)
            else:
                await send_message(chat_id, "No active planning session.", topic_id=topic_id)
        else:
            # Start new planning session with Claude Agent
            logger.info("Starting new planning session...")
            try:
                await process_agent_query(chat_id, topic_id, raw_text, username)
            except Exception as e:
                logger.error("Failed to forward to agent: %s", e)
                await send_message(chat_id, "*Error:* Failed to process query: " + str(e), topic_id=topic_id)

    def build_planning_keyboard(session_id: str) -> dict:
        """Build inline keyboard for planning approval workflow."""
        return {
            "inline_keyboard": [
                [
                    {"text": "✏️ Continue Planning", "callback_data": f"plan:continue:{session_id}"},
                    {"text": "✅ Approve & Deploy", "callback_data": f"plan:approve:{session_id}"}
                ],
                [
                    {"text": "❌ Decline", "callback_data": f"plan:decline:{session_id}"}
                ]
            ]
        }

    async def process_agent_query(chat_id, topic_id, query, username, session=None):
        """Forward query to Claude Agent using async mode with polling."""
        logger.info("Agent query from @%s: %s", username, query[:100])
        session_key = f"{chat_id}:{topic_id}"

        # Create or update session
        if session is None:
            session_id = str(uuid.uuid4())
            session = {
                "session_id": session_id,
                "messages": [],
                "last_response": None,
                "status": "processing",
                "username": username
            }
            planning_sessions[session_key] = session
        else:
            session_id = session["session_id"]
            session["status"] = "processing"

        # Add user message to history
        session["messages"].append({"role": "user", "content": query})

        # Build prompt with conversation history for continuations
        if len(session["messages"]) > 1:
            prompt = "Previous conversation:\n"
            for msg in session["messages"][:-1]:
                role = "User" if msg["role"] == "user" else "Assistant"
                prompt += f"\n{role}: {msg['content']}\n"
            prompt += f"\nUser's follow-up: {query}\n\nPlease continue the planning based on this feedback."
        else:
            prompt = query

        # Send "thinking" indicator
        thinking_msg = await send_message(chat_id, "_Processing your request..._", topic_id=topic_id)
        thinking_msg_id = thinking_msg.get("result", {}).get("message_id")

        try:
            async with httpx.AsyncClient(timeout=30.0) as client:
                # Submit task in async mode
                response = await client.post(
                    CLAUDE_AGENT_URL + "/agent/run",
                    json={
                        "prompt": prompt,
                        "context": {"username": username, "source": "telegram", "session_id": session_id},
                        "max_turns": 10,
                        "working_directory": "/workspace",
                        "async_mode": True,
                        "timeout": 900  # 15 minutes for deep research
                    }
                )
                result = response.json()

                if not result.get("success") or not result.get("task_id"):
                    raise Exception(result.get("error", "Failed to queue task"))

                task_id = result.get("task_id")
                logger.info("Task queued: %s", task_id)

                # Update thinking message
                await telegram_request("editMessageText", {
                    "chat_id": chat_id,
                    "message_id": thinking_msg_id,
                    "text": "_Working on your request... (task: " + task_id[:8] + ")_",
                    "parse_mode": "Markdown"
                })

                # Poll for completion (check every 5 seconds, max 15 minutes)
                max_polls = 180  # 15 min / 5 sec
                success = False
                for i in range(max_polls):
                    await asyncio.sleep(5)
                    status_resp = await client.get(CLAUDE_AGENT_URL + "/task/" + task_id)
                    status = status_resp.json()

                    if status.get("status") == "completed":
                        answer = status.get("result", "No response generated")
                        success = True
                        break
                    elif status.get("status") == "failed":
                        answer = "Error: " + status.get("error", "Unknown error")
                        break
                    # Update progress every 30 seconds
                    if i > 0 and i % 6 == 0:
                        await telegram_request("editMessageText", {
                            "chat_id": chat_id,
                            "message_id": thinking_msg_id,
                            "text": "_Still working... (" + str((i * 5) // 60) + " min elapsed)_",
                            "parse_mode": "Markdown"
                        })
                else:
                    answer = "Timeout: Task took too long (15 min limit). Task ID: " + task_id

                # Delete thinking message
                if thinking_msg_id:
                    await telegram_request("deleteMessage", {"chat_id": chat_id, "message_id": thinking_msg_id})

                # Store response in session
                if success:
                    session["messages"].append({"role": "assistant", "content": answer})
                    session["last_response"] = answer
                    session["status"] = "awaiting_decision"

                # Truncate for Telegram if needed
                display_answer = answer
                if len(display_answer) > 3800:
                    display_answer = display_answer[:3800] + "\n\n...truncated"

                # Send response with approval keyboard (only on success)
                if success:
                    keyboard = build_planning_keyboard(session_id)
                    msg_data = {
                        "chat_id": chat_id,
                        "text": display_answer + "\n\n---\n_What would you like to do?_",
                        "reply_markup": keyboard
                    }
                    if topic_id:
                        msg_data["message_thread_id"] = topic_id
                    await telegram_request("sendMessage", msg_data)
                else:
                    # Error - no keyboard
                    session["status"] = "failed"
                    msg_data = {"chat_id": chat_id, "text": display_answer}
                    if topic_id:
                        msg_data["message_thread_id"] = topic_id
                    await telegram_request("sendMessage", msg_data)

        except Exception as e:
            logger.error("Agent query failed: %s", e)
            session["status"] = "failed"
            if thinking_msg_id:
                await telegram_request("deleteMessage", {"chat_id": chat_id, "message_id": thinking_msg_id})
            await send_message(chat_id, "*Error:* " + str(e), topic_id=topic_id)

    async def continue_planning_session(chat_id, topic_id, query, username, session):
        """Continue an existing planning session with additional input."""
        logger.info("Continuing session %s with: %s", session["session_id"][:8], query[:50])
        await process_agent_query(chat_id, topic_id, query, username, session)

    async def handle_planning_callback(callback, action, session_id):
        """Handle planning workflow callbacks (continue/approve/decline)."""
        message = callback.get("message", {})
        chat_id = message.get("chat", {}).get("id")
        topic_id = message.get("message_thread_id")
        session_key = f"{chat_id}:{topic_id}"
        user = callback.get("from", {}).get("username", "unknown")

        # Find session
        session = planning_sessions.get(session_key)
        if not session or session.get("session_id") != session_id:
            await telegram_request("answerCallbackQuery", {
                "callback_query_id": callback["id"],
                "text": "Session expired or not found",
                "show_alert": True
            })
            return

        if action == "continue":
            # Set session to await input
            session["status"] = "awaiting_input"
            await telegram_request("answerCallbackQuery", {
                "callback_query_id": callback["id"],
                "text": "Send your feedback or changes..."
            })
            # Update message to remove keyboard and prompt for input
            await telegram_request("editMessageText", {
                "chat_id": chat_id,
                "message_id": message.get("message_id"),
                "text": message.get("text", "").replace("\n\n---\n_What would you like to do?_", "") + "\n\n---\n_Send your feedback or changes to continue planning..._"
            })

        elif action == "approve":
            session["status"] = "approved"
            await telegram_request("answerCallbackQuery", {
                "callback_query_id": callback["id"],
                "text": "Approved! Starting deployment..."
            })
            # Update message
            await telegram_request("editMessageText", {
                "chat_id": chat_id,
                "message_id": message.get("message_id"),
                "text": message.get("text", "").replace("\n\n---\n_What would you like to do?_", "") + f"\n\n---\n✅ *Approved by @{user}*\n_Starting deployment..._",
                "parse_mode": "Markdown"
            })
            # TODO: Trigger actual deployment via Claude Agent with "execute" flag
            # For now, send the plan back to Claude to execute
            await send_message(chat_id, "_Deployment feature coming soon. Plan saved for reference._", topic_id=topic_id)
            del planning_sessions[session_key]

        elif action == "decline":
            await telegram_request("answerCallbackQuery", {
                "callback_query_id": callback["id"],
                "text": "Plan declined"
            })
            # Update message
            await telegram_request("editMessageText", {
                "chat_id": chat_id,
                "message_id": message.get("message_id"),
                "text": message.get("text", "").replace("\n\n---\n_What would you like to do?_", "") + f"\n\n---\n❌ *Declined by @{user}*",
                "parse_mode": "Markdown"
            })
            del planning_sessions[session_key]

    @app.post("/approval")
    async def send_approval_request(request: ApprovalRequest):
        alert = request.alert
        solutions = request.solutions
        context = request.context
        topic_key = request.topic
        topic_id = topics.get(topic_key, {}).get("topic_id", 1)
        text = "*" + str(alert.get("alertname", "Alert")) + "*\n\n"
        text += str(alert.get("description", "")) + "\n\n"
        similar = context.get("similar_runbook")
        if similar:
            similarity = str(context.get("similarity", 0))
            text += "Similar to: `" + str(similar) + "` (" + similarity + "% match)\n\n"
        text += "*Solutions:*\n"
        for i, sol in enumerate(solutions, 1):
            text += "\n" + str(i) + ". *" + str(sol.get("name", "Option")) + "*\n"
            text += "   Impact: " + str(sol.get("impact", "unknown")) + "\n"
            text += "   Risk: " + str(sol.get("risk", "unknown")) + "\n"
        keyboard = await build_approval_keyboard(request.alert_id, solutions)
        result = await send_message(FORUM_CHAT_ID, text, topic_id=topic_id, reply_markup=keyboard)
        return {"message_id": result.get("result", {}).get("message_id"), "topic_id": topic_id}

    @app.post("/notify")
    async def send_notification(topic: str, message: str):
        topic_id = topics.get(topic, {}).get("topic_id", 1)
        result = await send_message(FORUM_CHAT_ID, message, topic_id=topic_id)
        return {"ok": result.get("ok", False)}

    @app.get("/health")
    async def health():
        return {"status": "healthy", "bot_configured": bool(BOT_TOKEN)}

    def main():
        port = int(os.environ.get("PORT", "8000"))
        logger.info("Starting Telegram service on port %d", port)
        uvicorn.run(app, host="0.0.0.0", port=port)

    if __name__ == "__main__":
        main()

  requirements.txt: |
    fastapi>=0.115.0
    uvicorn>=0.34.0
    httpx>=0.28.0
    pydantic>=2.11.0
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: telegram-topic-policies
  namespace: ai-platform
  labels:
    app: telegram-service
data:
  policies.yaml: |
    standing_topics:
      - key: critical
        name: "Critical Alerts"
        description: "High-priority alerts requiring immediate attention"
        pinned: true
      - key: arr_suite
        name: "Arr Suite"
        description: "Sonarr, Radarr, Prowlarr, SABnzbd notifications"
        domains: ["sonarr", "radarr", "prowlarr", "sabnzbd", "plex"]
      - key: infrastructure
        name: "Infrastructure"
        description: "Kubernetes, ArgoCD, storage, network"
        domains: ["k8s", "argocd", "storage", "network", "proxmox", "talos"]
      - key: home_assistant
        name: "Home Assistant"
        description: "Home automation, Tasmota, sensors"
        domains: ["homeassistant", "tasmota", "mqtt", "zigbee"]
      - key: weekly_reports
        name: "Weekly Reports"
        description: "Scheduled summaries and learning digests"
      - key: resolved
        name: "Resolved"
        description: "Archive of closed incidents"
    routing_rules:
      - match:
          alertname: ".*OOM.*|.*Memory.*"
          namespace: "apps"
        route_to: arr_suite
      - match:
          alertname: ".*"
          severity: critical
        route_to: critical
      - match:
          source: renovate
        route_to: infrastructure
      - match:
          domain: homeassistant
        route_to: home_assistant
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: telegram-service
  namespace: ai-platform
  labels:
    app: telegram-service
    component: hitl
spec:
  replicas: 1
  strategy:
    type: Recreate
  selector:
    matchLabels:
      app: telegram-service
  template:
    metadata:
      labels:
        app: telegram-service
        component: hitl
    spec:
      initContainers:
        - name: install-deps
          image: python:3.11-slim
          command: ['sh', '-c', 'pip install --target=/app/deps -r /code/requirements.txt']
          volumeMounts:
            - name: code
              mountPath: /code
            - name: deps
              mountPath: /app/deps
      containers:
        - name: telegram-service
          image: python:3.11-slim
          command: ['sh', '-c', 'cd /app && PYTHONPATH=/app/deps python /code/main.py']
          ports:
            - containerPort: 8000
              name: http
          env:
            - name: PORT
              value: "8000"
            - name: TELEGRAM_BOT_TOKEN
              valueFrom:
                secretKeyRef:
                  name: mcp-telegram
                  key: BOT_TOKEN
            - name: TELEGRAM_FORUM_CHAT_ID
              valueFrom:
                secretKeyRef:
                  name: mcp-telegram
                  key: CHAT_ID
            - name: WEBHOOK_URL
              value: "https://telegram-webhook.kernow.io/webhook/telegram"
            - name: USE_POLLING
              value: "true"
            - name: LANGGRAPH_URL
              value: "http://langgraph:8000"
            - name: KNOWLEDGE_MCP_URL
              value: "http://knowledge-mcp:8000"
          volumeMounts:
            - name: code
              mountPath: /code
            - name: deps
              mountPath: /app/deps
            - name: policies
              mountPath: /config
          resources:
            requests:
              memory: "128Mi"
              cpu: "100m"
            limits:
              memory: "256Mi"
              cpu: "500m"
          readinessProbe:
            httpGet:
              path: /health
              port: 8000
            initialDelaySeconds: 30
            periodSeconds: 10
            timeoutSeconds: 5
          livenessProbe:
            httpGet:
              path: /health
              port: 8000
            initialDelaySeconds: 60
            periodSeconds: 30
            timeoutSeconds: 5
      volumes:
        - name: code
          configMap:
            name: telegram-service-code
        - name: deps
          emptyDir: {}
        - name: policies
          configMap:
            name: telegram-topic-policies
---
apiVersion: v1
kind: Service
metadata:
  name: telegram-service
  namespace: ai-platform
  labels:
    app: telegram-service
    component: hitl
spec:
  selector:
    app: telegram-service
  ports:
    - port: 8000
      targetPort: 8000
      name: http
