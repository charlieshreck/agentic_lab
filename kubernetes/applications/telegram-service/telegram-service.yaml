apiVersion: v1
kind: ConfigMap
metadata:
  name: telegram-service-code
  namespace: ai-platform
  labels:
    app: telegram-service
data:
  main.py: |
    #!/usr/bin/env python3
    """Telegram Service for Human-in-the-Loop Workflows."""
    import os
    import logging
    import uuid
    from typing import Optional, Dict, List, Any
    from datetime import datetime

    from fastapi import FastAPI, Request, HTTPException
    from pydantic import BaseModel
    import httpx
    import uvicorn
    import asyncio

    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger(__name__)

    BOT_TOKEN = os.environ.get("TELEGRAM_BOT_TOKEN", "")
    FORUM_CHAT_ID = os.environ.get("TELEGRAM_FORUM_CHAT_ID", "")
    WEBHOOK_URL = os.environ.get("WEBHOOK_URL", "")
    USE_POLLING = os.environ.get("USE_POLLING", "true").lower() == "true"
    LANGGRAPH_URL = os.environ.get("LANGGRAPH_URL", "http://langgraph:8000")
    CLAUDE_AGENT_URL = os.environ.get("CLAUDE_AGENT_URL", "http://claude-agent:8000")
    KNOWLEDGE_MCP_URL = os.environ.get("KNOWLEDGE_MCP_URL", "http://knowledge-mcp:8000")

    TELEGRAM_API = "https://api.telegram.org/bot" + BOT_TOKEN

    topics = {}
    polling_task = None
    last_update_id = 0
    app = FastAPI(title="Telegram Service")

    # Session store for conversation continuity
    # Key: "{chat_id}:{topic_id}" -> {session_id, messages: [], last_response, status}
    planning_sessions = {}

    # Alert store for AI-raised alerts
    # Key: alert_id -> {alert_id, name, severity, description, suggested_fix, topic_id, status, raised_at}
    active_alerts = {}

    class ApprovalRequest(BaseModel):
        alert_id: str
        alert: dict
        solutions: list
        context: dict
        topic: str = "infrastructure"

    class AIAlertRequest(BaseModel):
        name: str
        severity: str = "warning"  # warning, critical
        description: str
        suggested_fix: Optional[str] = None
        source: str = "unknown"
        context: Optional[str] = None

    class TelegramUpdate(BaseModel):
        update_id: int
        message: Optional[dict] = None
        callback_query: Optional[dict] = None

    async def telegram_request(method, data=None):
        async with httpx.AsyncClient(timeout=30.0) as client:
            try:
                response = await client.post(TELEGRAM_API + "/" + method, json=data or {})
                result = response.json()
                if not result.get("ok"):
                    logger.error("Telegram API error: %s", result)
                return result
            except Exception as e:
                logger.error("Telegram request failed: %s", e)
                return {"ok": False, "error": str(e)}

    async def send_message(chat_id, text, topic_id=None, reply_markup=None, parse_mode="Markdown"):
        data = {"chat_id": chat_id, "text": text, "parse_mode": parse_mode}
        if topic_id:
            data["message_thread_id"] = topic_id
        if reply_markup:
            data["reply_markup"] = reply_markup
        return await telegram_request("sendMessage", data)

    async def create_forum_topic(name, icon_color=None):
        """Create a new forum topic. Returns topic_id or 0 on failure."""
        data = {"chat_id": FORUM_CHAT_ID, "name": name[:128]}  # Telegram limit
        if icon_color:
            data["icon_color"] = icon_color
        result = await telegram_request("createForumTopic", data)
        if result.get("ok"):
            topic_id = result["result"]["message_thread_id"]
            logger.info("Created topic '%s' with id %s", name[:30], topic_id)
            return topic_id
        logger.error("Failed to create topic: %s", result)
        return 0

    async def close_forum_topic(topic_id):
        """Close a forum topic."""
        await telegram_request("closeForumTopic", {"chat_id": FORUM_CHAT_ID, "message_thread_id": topic_id})

    async def reopen_forum_topic(topic_id):
        """Reopen a closed forum topic."""
        await telegram_request("reopenForumTopic", {"chat_id": FORUM_CHAT_ID, "message_thread_id": topic_id})

    async def create_design_topic(query: str, username: str) -> int:
        """Create a dedicated topic for a user design/planning session."""
        # Truncate query for topic name
        short_query = query[:60] + "..." if len(query) > 60 else query
        topic_name = f"ðŸ“ {short_query}"
        topic_id = await create_forum_topic(topic_name, icon_color=0x6FB9F0)  # Blue
        return topic_id

    async def create_alert_topic(alert_name: str, severity: str = "warning") -> int:
        """Create a dedicated topic for an AI-raised alert."""
        icon = "ðŸš¨" if severity == "critical" else "âš ï¸"
        topic_name = f"{icon} {alert_name[:100]}"
        color = 0xFF0000 if severity == "critical" else 0xFFD700  # Red or Yellow
        topic_id = await create_forum_topic(topic_name, icon_color=color)
        return topic_id

    async def initialize_standing_topics():
        """Create standing forum topics if they don't exist."""
        global topics
        standing = [
            {"key": "critical", "name": "ðŸš¨ Critical Alerts", "color": 0xFF0000},
            {"key": "arr_suite", "name": "ðŸ“º Arr Suite", "color": 0x6FB9F0},
            {"key": "infrastructure", "name": "ðŸ”§ Infrastructure", "color": 0x8EEE98},
            {"key": "home_assistant", "name": "ðŸ  Home Assistant", "color": 0xFFD700},
            {"key": "weekly_reports", "name": "ðŸ“Š Weekly Reports", "color": 0xE066FF},
            {"key": "resolved", "name": "âœ… Resolved", "color": 0x808080}
        ]

        if not FORUM_CHAT_ID:
            logger.warning("No FORUM_CHAT_ID set, skipping topic creation")
            for topic in standing:
                topics[topic["key"]] = {"name": topic["name"], "topic_id": None}
            return

        for topic in standing:
            try:
                # Try to create the topic (will fail if already exists with same name)
                topic_id = await create_forum_topic(topic["name"], icon_color=topic.get("color"))
                if topic_id:
                    topics[topic["key"]] = {"name": topic["name"], "topic_id": topic_id}
                    logger.info(f"Created topic '{topic['key']}' with id {topic_id}")
                else:
                    # Topic creation failed (might already exist) - use None to send to General
                    topics[topic["key"]] = {"name": topic["name"], "topic_id": None}
                    logger.warning(f"Could not create topic '{topic['name']}', will use General")
            except Exception as e:
                logger.error(f"Error creating topic '{topic['name']}': {e}")
                topics[topic["key"]] = {"name": topic["name"], "topic_id": None}

        logger.info("Initialized %d standing topics", len(topics))

    async def build_approval_keyboard(alert_id, solutions):
        """Build keyboard for legacy alert approvals."""
        buttons = []
        row = []
        for i, sol in enumerate(solutions, 1):
            name = sol.get("name", "Option")[:12]
            row.append({"text": str(i) + " " + name, "callback_data": "approve:" + alert_id + ":" + str(i)})
            if len(row) == 2:
                buttons.append(row)
                row = []
        if row:
            buttons.append(row)
        buttons.append([
            {"text": "Ignore", "callback_data": "ignore:" + alert_id},
            {"text": "Details", "callback_data": "details:" + alert_id}
        ])
        return {"inline_keyboard": buttons}

    def build_alert_keyboard(alert_id: str, has_fix: bool = True) -> dict:
        """Build keyboard for AI-raised alerts."""
        buttons = []
        if has_fix:
            buttons.append([
                {"text": "ðŸ”§ Execute Fix", "callback_data": f"alert:fix:{alert_id}"},
                {"text": "ðŸ” More Details", "callback_data": f"alert:details:{alert_id}"}
            ])
        buttons.append([
            {"text": "â¸ï¸ Ignore", "callback_data": f"alert:ignore:{alert_id}"},
            {"text": "ðŸ“¢ Escalate", "callback_data": f"alert:escalate:{alert_id}"}
        ])
        return {"inline_keyboard": buttons}

    async def poll_updates():
        global last_update_id
        logger.info("Starting long-polling for Telegram updates")
        while True:
            try:
                async with httpx.AsyncClient(timeout=60.0) as client:
                    response = await client.get(
                        TELEGRAM_API + "/getUpdates",
                        params={"offset": last_update_id + 1, "timeout": 30, "allowed_updates": ["message", "callback_query"]}
                    )
                    data = response.json()
                    if data.get("ok") and data.get("result"):
                        for update in data["result"]:
                            last_update_id = update["update_id"]
                            logger.info("Received update: %s", last_update_id)
                            if "callback_query" in update:
                                await handle_callback(update["callback_query"])
                            elif "message" in update:
                                await handle_message(update["message"])
            except asyncio.CancelledError:
                logger.info("Polling cancelled")
                break
            except Exception as e:
                logger.error("Polling error: %s", e)
                await asyncio.sleep(5)

    @app.on_event("startup")
    async def startup():
        global polling_task
        await initialize_standing_topics()
        if USE_POLLING and BOT_TOKEN:
            await telegram_request("deleteWebhook", {"drop_pending_updates": True})
            polling_task = asyncio.create_task(poll_updates())
            logger.info("Started polling mode")
        elif WEBHOOK_URL and BOT_TOKEN:
            result = await telegram_request("setWebhook", {
                "url": WEBHOOK_URL,
                "allowed_updates": ["message", "callback_query"],
                "drop_pending_updates": True
            })
            logger.info("Webhook registration: %s", result)

    @app.on_event("shutdown")
    async def shutdown():
        global polling_task
        if polling_task:
            polling_task.cancel()
            try:
                await polling_task
            except asyncio.CancelledError:
                pass
            logger.info("Polling stopped")

    @app.post("/webhook/telegram")
    async def telegram_webhook(request: Request):
        try:
            data = await request.json()
            logger.info("Received update: %s", data.get("update_id"))
            if "callback_query" in data:
                await handle_callback(data["callback_query"])
            elif "message" in data:
                await handle_message(data["message"])
            return {"ok": True}
        except Exception as e:
            logger.error("Webhook error: %s", e)
            raise HTTPException(status_code=500, detail=str(e))

    async def handle_callback(callback):
        callback_id = callback["id"]
        data = callback.get("data", "")
        user = callback.get("from", {}).get("username", "unknown")
        logger.info("Callback from @%s: %s", user, data)

        parts = data.split(":")
        action = parts[0]

        # Handle planning workflow callbacks
        if action == "plan" and len(parts) >= 3:
            plan_action = parts[1]  # continue, approve, decline
            session_id = parts[2]
            await handle_planning_callback(callback, plan_action, session_id)
            return

        # Handle AI-raised alert callbacks
        if action == "alert" and len(parts) >= 3:
            alert_action = parts[1]  # fix, ignore, details, escalate
            alert_id = parts[2]
            await handle_alert_callback(callback, alert_action, alert_id)
            return

        # Default: answer callback for other actions
        await telegram_request("answerCallbackQuery", {"callback_query_id": callback_id})

        alert_id = parts[1] if len(parts) > 1 else None
        option = parts[2] if len(parts) > 2 else None
        if action == "approve" and alert_id and option:
            await process_approval(callback, alert_id, int(option), user)
        elif action == "ignore" and alert_id:
            await process_ignore(callback, alert_id, user)
        elif action == "details" and alert_id:
            await show_details(callback, alert_id)

    async def process_approval(callback, alert_id, option, user):
        message = callback.get("message", {})
        async with httpx.AsyncClient(timeout=120.0) as client:
            try:
                response = await client.post(
                    LANGGRAPH_URL + "/approve",
                    json={"alert_id": alert_id, "solution_index": option, "approved_by": user}
                )
                result = response.json()
                await telegram_request("editMessageText", {
                    "chat_id": message.get("chat", {}).get("id"),
                    "message_id": message.get("message_id"),
                    "text": message.get("text", "") + "\n\n*Approved by @" + user + "*: Option " + str(option),
                    "parse_mode": "Markdown"
                })
                chat_id = message.get("chat", {}).get("id")
                topic_id = message.get("message_thread_id")
                if result.get("success"):
                    summary = result.get("summary", "")
                    runbook = result.get("runbook_id", "pending")
                    await send_message(chat_id, "*Executed successfully*\n\n" + summary + "\n\nRunbook: `" + runbook + "`", topic_id=topic_id)
                else:
                    error = result.get("error", "Unknown error")
                    await send_message(chat_id, "*Execution failed*\n\n" + error, topic_id=topic_id)
            except Exception as e:
                logger.error("Approval failed: %s", e)
                await send_message(message.get("chat", {}).get("id"), "*Error processing approval*: " + str(e), topic_id=message.get("message_thread_id"))

    async def process_ignore(callback, alert_id, user):
        message = callback.get("message", {})
        async with httpx.AsyncClient(timeout=30.0) as client:
            await client.post(LANGGRAPH_URL + "/ignore", json={"alert_id": alert_id, "ignored_by": user})
        await telegram_request("editMessageText", {
            "chat_id": message.get("chat", {}).get("id"),
            "message_id": message.get("message_id"),
            "text": message.get("text", "") + "\n\n*Ignored by @" + user + "*",
            "parse_mode": "Markdown"
        })

    async def show_details(callback, alert_id):
        message = callback.get("message", {})
        async with httpx.AsyncClient(timeout=30.0) as client:
            response = await client.get(LANGGRAPH_URL + "/pending/" + alert_id)
            pending = response.json()
        if pending:
            alert = pending.get("alert", {})
            assessment = pending.get("assessment", {})
            details = "*Details for Alert " + alert_id + "*\n\n"
            details += "*Alert:* " + str(alert.get("alertname", "Unknown")) + "\n"
            details += "*Severity:* " + str(alert.get("severity", "warning")) + "\n"
            details += "*Namespace:* " + str(alert.get("namespace", "default")) + "\n"
            details += "*Description:* " + str(alert.get("description", "N/A")) + "\n\n"
            details += "*Assessment:*\n"
            details += "- Domain: " + str(assessment.get("domain", "unknown")) + "\n"
            details += "- Complexity: " + str(assessment.get("complexity", "unknown")) + "\n"
            details += "- Similar runbook: " + str(assessment.get("similar_runbook", "none")) + "\n"
            await send_message(message.get("chat", {}).get("id"), details, topic_id=message.get("message_thread_id"))
        else:
            await send_message(message.get("chat", {}).get("id"), "Alert " + alert_id + " not found or expired", topic_id=message.get("message_thread_id"))

    async def handle_message(message):
        import re
        raw_text = message.get("text", "").strip()
        # Strip bot mentions and leading slashes for command detection
        text = re.sub(r'@\w+', '', raw_text).strip().lstrip('/').lower()
        chat_id = message.get("chat", {}).get("id")
        topic_id = message.get("message_thread_id")
        session_key = f"{chat_id}:{topic_id}"
        username = message.get("from", {}).get("username", "unknown")
        logger.info("Processing message: '%s' (parsed: '%s') chat=%s", raw_text[:50], text[:50], chat_id)

        if not text:
            logger.info("Empty text, ignoring")
            return

        # Check for active planning session waiting for continuation
        session = planning_sessions.get(session_key)
        if session and session.get("status") == "awaiting_input":
            logger.info("Continuing session %s", session["session_id"][:8])
            await continue_planning_session(chat_id, topic_id, raw_text, username, session)
            return

        if text == "status":
            async with httpx.AsyncClient(timeout=30.0) as client:
                response = await client.get(LANGGRAPH_URL + "/status")
                status = response.json()
            status_text = "*System Status*\n\n"
            status_text += "*Pending Approvals:* " + str(status.get("pending_count", 0)) + "\n"
            status_text += "*Auto-executed (24h):* " + str(status.get("auto_executed", 0)) + "\n"
            status_text += "*Active Runbooks:* " + str(status.get("active_runbooks", 0)) + "\n"
            status_text += "*Learning Queue:* " + str(status.get("learning_queue", 0)) + "\n"
            await send_message(chat_id, status_text, topic_id=topic_id)
        elif text == "help":
            help_text = "*Available Commands*\n\n"
            help_text += "- `status` - Show system status\n"
            help_text += "- `help` - Show this help\n"
            help_text += "- `cancel` - Cancel current planning session\n"
            help_text += "- Or just ask any question to start a planning session\n"
            await send_message(chat_id, help_text, topic_id=topic_id)
        elif text == "cancel":
            if session_key in planning_sessions:
                del planning_sessions[session_key]
                await send_message(chat_id, "Planning session cancelled.", topic_id=topic_id)
            else:
                await send_message(chat_id, "No active planning session.", topic_id=topic_id)
        else:
            # Start new planning session with Claude Agent
            logger.info("Starting new planning session...")
            try:
                # Create a dedicated topic for this design if in the forum chat
                design_topic_id = topic_id
                if str(chat_id) == FORUM_CHAT_ID:
                    # Create new topic for this design
                    new_topic_id = await create_design_topic(raw_text, username)
                    if new_topic_id:
                        design_topic_id = new_topic_id
                        await send_message(chat_id, f"_Starting design session in new topic..._", topic_id=topic_id)

                await process_agent_query(chat_id, design_topic_id, raw_text, username, create_topic=False)
            except Exception as e:
                logger.error("Failed to forward to agent: %s", e)
                await send_message(chat_id, "*Error:* Failed to process query: " + str(e), topic_id=topic_id)

    def build_planning_keyboard(session_id: str) -> dict:
        """Build inline keyboard for planning approval workflow."""
        return {
            "inline_keyboard": [
                [
                    {"text": "âœï¸ Continue Planning", "callback_data": f"plan:continue:{session_id}"},
                    {"text": "âœ… Approve & Deploy", "callback_data": f"plan:approve:{session_id}"}
                ],
                [
                    {"text": "âŒ Decline", "callback_data": f"plan:decline:{session_id}"}
                ]
            ]
        }

    async def process_agent_query(chat_id, topic_id, query, username, session=None, create_topic=False):
        """Forward query to Claude Agent using async mode with polling."""
        logger.info("Agent query from @%s: %s", username, query[:100])
        session_key = f"{chat_id}:{topic_id}"

        # Create or update session
        if session is None:
            session_id = str(uuid.uuid4())
            session = {
                "session_id": session_id,
                "messages": [],
                "last_response": None,
                "status": "processing",
                "username": username,
                "topic_id": topic_id,
                "chat_id": chat_id,
                "is_design_topic": create_topic or (str(chat_id) == FORUM_CHAT_ID and topic_id != 1)
            }
            planning_sessions[session_key] = session
        else:
            session_id = session["session_id"]
            session["status"] = "processing"

        # Add user message to history
        session["messages"].append({"role": "user", "content": query})

        # Build prompt with conversation history for continuations
        if len(session["messages"]) > 1:
            prompt = "Previous conversation:\n"
            for msg in session["messages"][:-1]:
                role = "User" if msg["role"] == "user" else "Assistant"
                prompt += f"\n{role}: {msg['content']}\n"
            prompt += f"\nUser's follow-up: {query}\n\nPlease continue the planning based on this feedback."
        else:
            prompt = query

        # Send "thinking" indicator
        thinking_msg = await send_message(chat_id, "_Processing your request..._", topic_id=topic_id)
        thinking_msg_id = thinking_msg.get("result", {}).get("message_id")

        try:
            async with httpx.AsyncClient(timeout=30.0) as client:
                # Submit task in async mode
                response = await client.post(
                    CLAUDE_AGENT_URL + "/agent/run",
                    json={
                        "prompt": prompt,
                        "context": {"username": username, "source": "telegram", "session_id": session_id},
                        "max_turns": 10,
                        "working_directory": "/workspace",
                        "async_mode": True,
                        "timeout": 900  # 15 minutes for deep research
                    }
                )
                result = response.json()

                if not result.get("success") or not result.get("task_id"):
                    raise Exception(result.get("error", "Failed to queue task"))

                task_id = result.get("task_id")
                logger.info("Task queued: %s", task_id)

                # Update thinking message
                await telegram_request("editMessageText", {
                    "chat_id": chat_id,
                    "message_id": thinking_msg_id,
                    "text": "_Working on your request... (task: " + task_id[:8] + ")_",
                    "parse_mode": "Markdown"
                })

                # Poll for completion (check every 5 seconds, max 15 minutes)
                max_polls = 180  # 15 min / 5 sec
                success = False
                for i in range(max_polls):
                    await asyncio.sleep(5)
                    status_resp = await client.get(CLAUDE_AGENT_URL + "/task/" + task_id)
                    status = status_resp.json()

                    if status.get("status") == "completed":
                        answer = status.get("result", "No response generated")
                        success = True
                        break
                    elif status.get("status") == "failed":
                        answer = "Error: " + status.get("error", "Unknown error")
                        break
                    # Update progress every 30 seconds
                    if i > 0 and i % 6 == 0:
                        await telegram_request("editMessageText", {
                            "chat_id": chat_id,
                            "message_id": thinking_msg_id,
                            "text": "_Still working... (" + str((i * 5) // 60) + " min elapsed)_",
                            "parse_mode": "Markdown"
                        })
                else:
                    answer = "Timeout: Task took too long (15 min limit). Task ID: " + task_id

                # Delete thinking message
                if thinking_msg_id:
                    await telegram_request("deleteMessage", {"chat_id": chat_id, "message_id": thinking_msg_id})

                # Store response in session
                if success:
                    session["messages"].append({"role": "assistant", "content": answer})
                    session["last_response"] = answer
                    session["status"] = "awaiting_decision"

                # Truncate for Telegram if needed
                display_answer = answer
                if len(display_answer) > 3800:
                    display_answer = display_answer[:3800] + "\n\n...truncated"

                # Send response with approval keyboard (only on success)
                if success:
                    keyboard = build_planning_keyboard(session_id)
                    msg_data = {
                        "chat_id": chat_id,
                        "text": display_answer + "\n\n---\n_What would you like to do?_",
                        "reply_markup": keyboard
                    }
                    if topic_id:
                        msg_data["message_thread_id"] = topic_id
                    await telegram_request("sendMessage", msg_data)
                else:
                    # Error - no keyboard
                    session["status"] = "failed"
                    msg_data = {"chat_id": chat_id, "text": display_answer}
                    if topic_id:
                        msg_data["message_thread_id"] = topic_id
                    await telegram_request("sendMessage", msg_data)

        except Exception as e:
            logger.error("Agent query failed: %s", e)
            session["status"] = "failed"
            if thinking_msg_id:
                await telegram_request("deleteMessage", {"chat_id": chat_id, "message_id": thinking_msg_id})
            await send_message(chat_id, "*Error:* " + str(e), topic_id=topic_id)

    async def continue_planning_session(chat_id, topic_id, query, username, session):
        """Continue an existing planning session with additional input."""
        logger.info("Continuing session %s with: %s", session["session_id"][:8], query[:50])
        await process_agent_query(chat_id, topic_id, query, username, session)

    async def handle_planning_callback(callback, action, session_id):
        """Handle planning workflow callbacks (continue/approve/decline)."""
        message = callback.get("message", {})
        chat_id = message.get("chat", {}).get("id")
        topic_id = message.get("message_thread_id")
        session_key = f"{chat_id}:{topic_id}"
        user = callback.get("from", {}).get("username", "unknown")

        # Find session
        session = planning_sessions.get(session_key)
        if not session or session.get("session_id") != session_id:
            await telegram_request("answerCallbackQuery", {
                "callback_query_id": callback["id"],
                "text": "Session expired or not found",
                "show_alert": True
            })
            return

        if action == "continue":
            # Set session to await input
            session["status"] = "awaiting_input"
            await telegram_request("answerCallbackQuery", {
                "callback_query_id": callback["id"],
                "text": "Send your feedback or changes..."
            })
            # Update message to remove keyboard and prompt for input
            await telegram_request("editMessageText", {
                "chat_id": chat_id,
                "message_id": message.get("message_id"),
                "text": message.get("text", "").replace("\n\n---\n_What would you like to do?_", "") + "\n\n---\n_Send your feedback or changes to continue planning..._"
            })

        elif action == "approve":
            session["status"] = "approved"
            is_design_topic = session.get("is_design_topic", False)
            await telegram_request("answerCallbackQuery", {
                "callback_query_id": callback["id"],
                "text": "Approved! Starting deployment..."
            })
            # Update message
            await telegram_request("editMessageText", {
                "chat_id": chat_id,
                "message_id": message.get("message_id"),
                "text": message.get("text", "").replace("\n\n---\n_What would you like to do?_", "") + f"\n\n---\nâœ… *Approved by @{user}*\n_Starting deployment..._",
                "parse_mode": "Markdown"
            })
            # TODO: Trigger actual deployment via Claude Agent with "execute" flag
            # For now, send the plan back to Claude to execute
            await send_message(chat_id, "_Deployment feature coming soon. Plan saved for reference._", topic_id=topic_id)
            # Close the design topic if it was created for this session
            if is_design_topic and topic_id:
                await send_message(chat_id, "_Closing topic - design approved._", topic_id=topic_id)
                await close_forum_topic(topic_id)
            del planning_sessions[session_key]

        elif action == "decline":
            is_design_topic = session.get("is_design_topic", False)
            await telegram_request("answerCallbackQuery", {
                "callback_query_id": callback["id"],
                "text": "Plan declined"
            })
            # Update message
            await telegram_request("editMessageText", {
                "chat_id": chat_id,
                "message_id": message.get("message_id"),
                "text": message.get("text", "").replace("\n\n---\n_What would you like to do?_", "") + f"\n\n---\nâŒ *Declined by @{user}*",
                "parse_mode": "Markdown"
            })
            # Close the design topic if it was created for this session
            if is_design_topic and topic_id:
                await send_message(chat_id, "_Closing topic - design declined._", topic_id=topic_id)
                await close_forum_topic(topic_id)
            del planning_sessions[session_key]

    async def handle_alert_callback(callback, action, alert_id):
        """Handle AI-raised alert callbacks (fix/ignore/details/escalate)."""
        message = callback.get("message", {})
        chat_id = message.get("chat", {}).get("id")
        topic_id = message.get("message_thread_id")
        user = callback.get("from", {}).get("username", "unknown")

        # Find alert
        alert = active_alerts.get(alert_id)
        if not alert:
            await telegram_request("answerCallbackQuery", {
                "callback_query_id": callback["id"],
                "text": "Alert not found or expired",
                "show_alert": True
            })
            return

        if action == "fix":
            alert["status"] = "executing_fix"
            await telegram_request("answerCallbackQuery", {
                "callback_query_id": callback["id"],
                "text": "Executing suggested fix..."
            })
            # Update message
            await telegram_request("editMessageText", {
                "chat_id": chat_id,
                "message_id": message.get("message_id"),
                "text": message.get("text", "") + f"\n\n---\nðŸ”§ *Fix approved by @{user}*\n_Executing..._",
                "parse_mode": "Markdown"
            })
            # Execute fix via Claude Agent
            try:
                async with httpx.AsyncClient(timeout=30.0) as client:
                    response = await client.post(
                        CLAUDE_AGENT_URL + "/agent/run",
                        json={
                            "prompt": f"Execute the following fix for alert '{alert['name']}':\n\n{alert.get('suggested_fix', 'No fix specified')}\n\nBe careful and report the result.",
                            "context": {"alert_id": alert_id, "approved_by": user, "source": "alert_fix"},
                            "max_turns": 5,
                            "working_directory": "/workspace",
                            "async_mode": True,
                            "timeout": 300
                        }
                    )
                    result = response.json()
                    if result.get("success"):
                        await send_message(chat_id, f"_Fix execution started. Task: {result.get('task_id', 'unknown')[:8]}_", topic_id=topic_id)
                    else:
                        await send_message(chat_id, f"*Error starting fix:* {result.get('error', 'Unknown')}", topic_id=topic_id)
            except Exception as e:
                await send_message(chat_id, f"*Error:* {str(e)}", topic_id=topic_id)
            # Close topic after fix initiated
            alert["status"] = "fix_initiated"
            await close_forum_topic(topic_id)
            del active_alerts[alert_id]

        elif action == "ignore":
            await telegram_request("answerCallbackQuery", {
                "callback_query_id": callback["id"],
                "text": "Alert ignored"
            })
            await telegram_request("editMessageText", {
                "chat_id": chat_id,
                "message_id": message.get("message_id"),
                "text": message.get("text", "") + f"\n\n---\nâ¸ï¸ *Ignored by @{user}*",
                "parse_mode": "Markdown"
            })
            alert["status"] = "ignored"
            await close_forum_topic(topic_id)
            del active_alerts[alert_id]

        elif action == "details":
            await telegram_request("answerCallbackQuery", {
                "callback_query_id": callback["id"]
            })
            # Send detailed info
            details = f"*Alert Details: {alert['name']}*\n\n"
            details += f"*Severity:* {alert.get('severity', 'warning')}\n"
            details += f"*Source:* {alert.get('source', 'unknown')}\n"
            details += f"*Raised:* {alert.get('raised_at', 'unknown')}\n\n"
            details += f"*Description:*\n{alert.get('description', 'No description')}\n\n"
            if alert.get('suggested_fix'):
                details += f"*Suggested Fix:*\n```\n{alert.get('suggested_fix')}\n```\n"
            if alert.get('context'):
                details += f"\n*Context:*\n{alert.get('context')}"
            await send_message(chat_id, details, topic_id=topic_id)

        elif action == "escalate":
            await telegram_request("answerCallbackQuery", {
                "callback_query_id": callback["id"],
                "text": "Alert escalated to critical"
            })
            await telegram_request("editMessageText", {
                "chat_id": chat_id,
                "message_id": message.get("message_id"),
                "text": message.get("text", "") + f"\n\n---\nðŸ“¢ *Escalated by @{user}*",
                "parse_mode": "Markdown"
            })
            # Notify in critical topic
            critical_topic_id = topics.get("critical", {}).get("topic_id")
            await send_message(
                FORUM_CHAT_ID,
                f"ðŸš¨ *ESCALATED ALERT*\n\n*{alert['name']}*\n\nEscalated by @{user}\nOriginal topic: {topic_id}",
                topic_id=critical_topic_id
            )
            alert["status"] = "escalated"

    @app.post("/approval")
    async def send_approval_request(request: ApprovalRequest):
        alert = request.alert
        solutions = request.solutions
        context = request.context
        topic_key = request.topic
        topic_id = topics.get(topic_key, {}).get("topic_id")
        text = "*" + str(alert.get("alertname", "Alert")) + "*\n\n"
        text += str(alert.get("description", "")) + "\n\n"
        similar = context.get("similar_runbook")
        if similar:
            similarity = str(context.get("similarity", 0))
            text += "Similar to: `" + str(similar) + "` (" + similarity + "% match)\n\n"
        text += "*Solutions:*\n"
        for i, sol in enumerate(solutions, 1):
            text += "\n" + str(i) + ". *" + str(sol.get("name", "Option")) + "*\n"
            text += "   Impact: " + str(sol.get("impact", "unknown")) + "\n"
            text += "   Risk: " + str(sol.get("risk", "unknown")) + "\n"
        keyboard = await build_approval_keyboard(request.alert_id, solutions)
        result = await send_message(FORUM_CHAT_ID, text, topic_id=topic_id, reply_markup=keyboard)
        return {"message_id": result.get("result", {}).get("message_id"), "topic_id": topic_id}

    @app.post("/notify")
    async def send_notification(topic: str, message: str):
        topic_id = topics.get(topic, {}).get("topic_id")
        result = await send_message(FORUM_CHAT_ID, message, topic_id=topic_id)
        return {"ok": result.get("ok", False)}

    @app.post("/alert/raise")
    async def raise_ai_alert(request: AIAlertRequest):
        """
        Raise an AI-detected alert with its own dedicated topic.
        Used by MCP servers and the alerting pipeline to notify about issues.
        """
        alert_id = str(uuid.uuid4())

        # Create dedicated topic for this alert
        topic_id = await create_alert_topic(request.name, request.severity)
        if not topic_id:
            # Fallback to infrastructure topic
            topic_id = topics.get("infrastructure", {}).get("topic_id")

        # Store alert
        active_alerts[alert_id] = {
            "alert_id": alert_id,
            "name": request.name,
            "severity": request.severity,
            "description": request.description,
            "suggested_fix": request.suggested_fix,
            "source": request.source,
            "context": request.context,
            "topic_id": topic_id,
            "status": "pending",
            "raised_at": datetime.utcnow().isoformat()
        }

        # Build message - escape markdown special chars in user content
        def escape_md(text: str) -> str:
            if not text:
                return ""
            # Escape markdown special characters
            for char in ['*', '_', '`', '[', ']']:
                text = text.replace(char, '\\' + char)
            return text

        icon = "ðŸš¨" if request.severity == "critical" else "âš ï¸"
        msg = f"{icon} *AI Alert:* {escape_md(request.name)}\n\n"
        msg += f"*Severity:* {request.severity}\n"
        msg += f"*Source:* {escape_md(request.source)}\n\n"
        msg += f"*Description:*\n{escape_md(request.description)}\n"
        if request.suggested_fix:
            # Truncate long fixes and escape
            fix_text = request.suggested_fix[:500] if len(request.suggested_fix) > 500 else request.suggested_fix
            msg += f"\n*Suggested Fix:*\n{escape_md(fix_text)}"

        # Build keyboard with appropriate options
        has_fix = bool(request.suggested_fix)
        keyboard = build_alert_keyboard(alert_id, has_fix)

        # Send to topic - use HTML parse mode to avoid markdown issues, or no parse mode
        result = await send_message(FORUM_CHAT_ID, msg, topic_id=topic_id, reply_markup=keyboard, parse_mode="Markdown")

        return {
            "alert_id": alert_id,
            "topic_id": topic_id,
            "message_id": result.get("result", {}).get("message_id")
        }

    @app.get("/alert/{alert_id}")
    async def get_alert_status(alert_id: str):
        """Get status of an AI-raised alert."""
        alert = active_alerts.get(alert_id)
        if not alert:
            raise HTTPException(status_code=404, detail="Alert not found")
        return alert

    @app.get("/alerts")
    async def list_alerts():
        """List all active AI-raised alerts."""
        return {
            "alerts": list(active_alerts.values()),
            "count": len(active_alerts)
        }

    @app.get("/health")
    async def health():
        return {"status": "healthy", "bot_configured": bool(BOT_TOKEN)}

    def main():
        port = int(os.environ.get("PORT", "8000"))
        logger.info("Starting Telegram service on port %d", port)
        uvicorn.run(app, host="0.0.0.0", port=port)

    if __name__ == "__main__":
        main()

  requirements.txt: |
    fastapi>=0.115.0
    uvicorn>=0.34.0
    httpx>=0.28.0
    pydantic>=2.11.0
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: telegram-topic-policies
  namespace: ai-platform
  labels:
    app: telegram-service
data:
  policies.yaml: |
    standing_topics:
      - key: critical
        name: "Critical Alerts"
        description: "High-priority alerts requiring immediate attention"
        pinned: true
      - key: arr_suite
        name: "Arr Suite"
        description: "Sonarr, Radarr, Prowlarr, SABnzbd notifications"
        domains: ["sonarr", "radarr", "prowlarr", "sabnzbd", "plex"]
      - key: infrastructure
        name: "Infrastructure"
        description: "Kubernetes, ArgoCD, storage, network"
        domains: ["k8s", "argocd", "storage", "network", "proxmox", "talos"]
      - key: home_assistant
        name: "Home Assistant"
        description: "Home automation, Tasmota, sensors"
        domains: ["homeassistant", "tasmota", "mqtt", "zigbee"]
      - key: weekly_reports
        name: "Weekly Reports"
        description: "Scheduled summaries and learning digests"
      - key: resolved
        name: "Resolved"
        description: "Archive of closed incidents"
    routing_rules:
      - match:
          alertname: ".*OOM.*|.*Memory.*"
          namespace: "apps"
        route_to: arr_suite
      - match:
          alertname: ".*"
          severity: critical
        route_to: critical
      - match:
          source: renovate
        route_to: infrastructure
      - match:
          domain: homeassistant
        route_to: home_assistant
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: telegram-service
  namespace: ai-platform
  labels:
    app: telegram-service
    component: hitl
spec:
  replicas: 1
  strategy:
    type: Recreate
  selector:
    matchLabels:
      app: telegram-service
  template:
    metadata:
      labels:
        app: telegram-service
        component: hitl
    spec:
      initContainers:
        - name: install-deps
          image: python:3.11-slim
          command: ['sh', '-c', 'pip install --target=/app/deps -r /code/requirements.txt']
          volumeMounts:
            - name: code
              mountPath: /code
            - name: deps
              mountPath: /app/deps
      containers:
        - name: telegram-service
          image: python:3.11-slim
          command: ['sh', '-c', 'cd /app && PYTHONPATH=/app/deps python /code/main.py']
          ports:
            - containerPort: 8000
              name: http
          env:
            - name: PORT
              value: "8000"
            - name: TELEGRAM_BOT_TOKEN
              valueFrom:
                secretKeyRef:
                  name: mcp-telegram
                  key: BOT_TOKEN
            - name: TELEGRAM_FORUM_CHAT_ID
              valueFrom:
                secretKeyRef:
                  name: mcp-telegram
                  key: CHAT_ID
            - name: WEBHOOK_URL
              value: "https://telegram-webhook.kernow.io/webhook/telegram"
            - name: USE_POLLING
              value: "true"
            - name: LANGGRAPH_URL
              value: "http://langgraph:8000"
            - name: KNOWLEDGE_MCP_URL
              value: "http://knowledge-mcp:8000"
            - name: CLAUDE_AGENT_URL
              value: "http://claude-agent:8000"
          volumeMounts:
            - name: code
              mountPath: /code
            - name: deps
              mountPath: /app/deps
            - name: policies
              mountPath: /config
          resources:
            requests:
              memory: "128Mi"
              cpu: "100m"
            limits:
              memory: "256Mi"
              cpu: "500m"
          readinessProbe:
            httpGet:
              path: /health
              port: 8000
            initialDelaySeconds: 30
            periodSeconds: 10
            timeoutSeconds: 5
          livenessProbe:
            httpGet:
              path: /health
              port: 8000
            initialDelaySeconds: 60
            periodSeconds: 30
            timeoutSeconds: 5
      volumes:
        - name: code
          configMap:
            name: telegram-service-code
        - name: deps
          emptyDir: {}
        - name: policies
          configMap:
            name: telegram-topic-policies
---
apiVersion: v1
kind: Service
metadata:
  name: telegram-service
  namespace: ai-platform
  labels:
    app: telegram-service
    component: hitl
spec:
  selector:
    app: telegram-service
  ports:
    - port: 8000
      targetPort: 8000
      name: http
