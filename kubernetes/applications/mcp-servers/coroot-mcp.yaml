apiVersion: v1
kind: ConfigMap
metadata:
  name: coroot-mcp-code
  namespace: ai-platform
  labels:
    app: coroot-mcp
data:
  main.py: |
    #!/usr/bin/env python3
    """Coroot MCP server for observability and anomaly detection."""
    import os
    import logging
    from typing import List, Optional
    from datetime import datetime, timedelta
    import httpx
    from fastmcp import FastMCP
    from pydantic import BaseModel
    from starlette.applications import Starlette
    from starlette.routing import Route, Mount
    from starlette.responses import JSONResponse
    from starlette.requests import Request
    import uvicorn

    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger(__name__)

    COROOT_URL = os.environ.get("COROOT_URL", "http://10.30.0.20:32702")  # Monit cluster NodePort
    COROOT_PROJECT_NAME = os.environ.get("COROOT_PROJECT", "all-clusters")  # Multi-cluster view
    _PROJECT_ID_CACHE = {}

    async def _get_project_id(project_name: str) -> str:
        """Resolve project name to internal ID. Coroot API uses IDs not names."""
        if project_name in _PROJECT_ID_CACHE:
            return _PROJECT_ID_CACHE[project_name]
        try:
            async with httpx.AsyncClient(timeout=10.0) as client:
                response = await client.get(f"{COROOT_URL}/api/user")
                response.raise_for_status()
                data = response.json()
                for proj in data.get("projects", []):
                    _PROJECT_ID_CACHE[proj["name"]] = proj["id"]
                return _PROJECT_ID_CACHE.get(project_name, project_name)
        except Exception as e:
            logger.error(f"Failed to get project ID: {e}")
            return project_name  # Fallback to name

    mcp = FastMCP(
        name="coroot-mcp",
        instructions="MCP server for Coroot observability. Query metrics, anomalies, service dependencies, and alerts."
    )

    class ServiceMetrics(BaseModel):
        service: str
        namespace: str
        cpu_usage: Optional[float] = None
        memory_usage: Optional[float] = None
        latency_p50: Optional[float] = None
        latency_p99: Optional[float] = None
        error_rate: Optional[float] = None

    class Anomaly(BaseModel):
        service: str
        type: str
        severity: str
        message: str
        timestamp: str

    # ============================================================================
    # INTERNAL HELPERS (shared by MCP tools and REST API)
    # ============================================================================

    async def _coroot_request(method: str, endpoint: str, **kwargs) -> dict:
        project_id = await _get_project_id(COROOT_PROJECT_NAME)
        async with httpx.AsyncClient(timeout=30.0) as client:
            url = f"{COROOT_URL}/api/project/{project_id}/{endpoint}"
            try:
                logger.info(f"Coroot request: {method} {url}")
                response = await client.request(method, url, **kwargs)
                response.raise_for_status()
                return response.json()
            except Exception as e:
                logger.error(f"Coroot request failed: {e}")
                return {"error": str(e)}

    async def _get_overview_internal() -> dict:
        """Get infrastructure overview."""
        # Coroot API: /project/{project}/overview/{view} - use 'health' view for service status
        data = await _coroot_request("GET", "overview/health")
        if "error" in data:
            return {"error": data["error"]}
        overview = {"total_services": 0, "healthy": 0, "warning": 0, "critical": 0, "services": {}}
        # Parse the health overview response - structure is context.search.applications
        context = data.get("context", {})
        apps = context.get("search", {}).get("applications", [])
        for app in apps:
            app_id = app.get("id", "unknown")
            # Extract short name from ID format: "project:namespace:kind:name"
            parts = app_id.split(":")
            name = parts[-1] if parts else app_id
            status = app.get("status", "unknown")
            overview["total_services"] += 1
            if status == "ok": overview["healthy"] += 1
            elif status == "warning": overview["warning"] += 1
            elif status in ("critical", "error"): overview["critical"] += 1
            overview["services"][name] = {"health": status, "id": app_id}
        return overview

    async def _get_anomalies_internal(hours: int = 24, severity: Optional[str] = None) -> List[dict]:
        """Get recent anomalies."""
        end_time = datetime.utcnow()
        start_time = end_time - timedelta(hours=hours)
        params = {"from": int(start_time.timestamp()), "to": int(end_time.timestamp())}
        data = await _coroot_request("GET", "incidents", params=params)
        if "error" in data:
            return []
        anomalies = []
        for inc in data.get("incidents", []):
            if severity and inc.get("severity") != severity:
                continue
            anomalies.append({
                "service": inc.get("service", "unknown"),
                "type": inc.get("type", "unknown"),
                "severity": inc.get("severity", "info"),
                "message": inc.get("message", ""),
                "timestamp": inc.get("timestamp", "")
            })
        return anomalies

    async def _get_alerts_internal(status: str = "firing") -> List[dict]:
        """Get current alerts."""
        data = await _coroot_request("GET", "alerts")
        if "error" in data:
            return []
        return [a for a in data.get("alerts", []) if status == "all" or a.get("status") == status]

    # ============================================================================
    # MCP TOOLS
    # ============================================================================

    @mcp.tool()
    async def get_service_metrics(service: str, namespace: str = "ai-platform", timerange_hours: int = 1) -> ServiceMetrics:
        """Get metrics for a specific service (CPU, memory, latency, error rate)."""
        end_time = datetime.utcnow()
        start_time = end_time - timedelta(hours=timerange_hours)
        params = {"from": int(start_time.timestamp()), "to": int(end_time.timestamp()), "service": f"{namespace}/{service}"}
        data = await _coroot_request("GET", "overview", params=params)
        if "error" in data:
            return ServiceMetrics(service=service, namespace=namespace)
        try:
            service_data = data.get("services", {}).get(f"{namespace}/{service}", {})
            metrics = service_data.get("metrics", {})
            return ServiceMetrics(
                service=service, namespace=namespace,
                cpu_usage=metrics.get("cpu_usage"), memory_usage=metrics.get("memory_usage"),
                latency_p50=metrics.get("latency_p50"), latency_p99=metrics.get("latency_p99"),
                error_rate=metrics.get("error_rate")
            )
        except:
            return ServiceMetrics(service=service, namespace=namespace)

    @mcp.tool()
    async def get_recent_anomalies(hours: int = 24, severity: Optional[str] = None) -> List[Anomaly]:
        """Get recent anomalies detected by Coroot (critical, warning, info)."""
        anomalies = await _get_anomalies_internal(hours, severity)
        return [Anomaly(**a) for a in anomalies]

    @mcp.tool()
    async def get_service_dependencies(service: str, namespace: str = "ai-platform") -> List[dict]:
        """Get upstream and downstream service dependencies."""
        data = await _coroot_request("GET", "service/dependencies", params={"service": f"{namespace}/{service}"})
        return data.get("dependencies", []) if "error" not in data else []

    @mcp.tool()
    async def get_alerts(status: str = "firing") -> List[dict]:
        """Get current alerts from Coroot (firing, resolved, all)."""
        return await _get_alerts_internal(status)

    @mcp.tool()
    async def get_infrastructure_overview() -> dict:
        """Get overview of all services and their health status."""
        return await _get_overview_internal()

    # ============================================================================
    # REST API (for langgraph context building)
    # ============================================================================

    async def rest_health(request: Request):
        """Health check endpoint."""
        return JSONResponse({"status": "healthy"})

    async def rest_api_overview(request: Request):
        """Get infrastructure overview for langgraph context."""
        try:
            overview = await _get_overview_internal()
            return JSONResponse({"status": "ok", "data": overview})
        except Exception as e:
            logger.error(f"REST api_overview error: {e}")
            return JSONResponse({"status": "error", "error": str(e)}, status_code=500)

    async def rest_api_anomalies(request: Request):
        """Get anomalies for langgraph context."""
        try:
            hours = int(request.query_params.get("hours", "24"))
            severity = request.query_params.get("severity")
            anomalies = await _get_anomalies_internal(hours, severity)
            return JSONResponse({"status": "ok", "data": anomalies, "count": len(anomalies)})
        except Exception as e:
            logger.error(f"REST api_anomalies error: {e}")
            return JSONResponse({"status": "error", "error": str(e)}, status_code=500)

    async def rest_api_alerts(request: Request):
        """Get alerts for langgraph context."""
        try:
            status = request.query_params.get("status", "firing")
            alerts = await _get_alerts_internal(status)
            return JSONResponse({"status": "ok", "data": alerts, "count": len(alerts)})
        except Exception as e:
            logger.error(f"REST api_alerts error: {e}")
            return JSONResponse({"status": "error", "error": str(e)}, status_code=500)

    # ============================================================================
    # MAIN
    # ============================================================================

    def main():
        port = int(os.environ.get("PORT", "8000"))
        logger.info(f"Starting Coroot MCP on port {port}")

        rest_routes = [
            Route("/health", rest_health, methods=["GET"]),
            Route("/api/overview", rest_api_overview, methods=["GET"]),
            Route("/api/anomalies", rest_api_anomalies, methods=["GET"]),
            Route("/api/alerts", rest_api_alerts, methods=["GET"]),
        ]

        mcp_app = mcp.http_app()
        app = Starlette(
            routes=rest_routes + [Mount("/", app=mcp_app)],
            lifespan=mcp_app.lifespan
        )
        uvicorn.run(app, host="0.0.0.0", port=port)

    if __name__ == "__main__":
        main()

  requirements.txt: |
    fastmcp>=2.7.0
    pydantic>=2.11.0
    uvicorn>=0.34.0
    starlette>=0.40.0
    httpx>=0.28.0
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: coroot-mcp
  namespace: ai-platform
  labels:
    app: coroot-mcp
    component: mcp
spec:
  replicas: 1
  selector:
    matchLabels:
      app: coroot-mcp
  template:
    metadata:
      labels:
        app: coroot-mcp
        component: mcp
    spec:
      initContainers:
        - name: install-deps
          image: python:3.11-slim
          command: ['sh', '-c', 'pip install --target=/app/deps -r /code/requirements.txt']
          volumeMounts:
            - name: code
              mountPath: /code
            - name: deps
              mountPath: /app/deps
      containers:
        - name: mcp-server
          image: python:3.11-slim
          command: ['sh', '-c', 'cd /app && PYTHONPATH=/app/deps python /code/main.py']
          ports:
            - containerPort: 8000
              name: http
          env:
            - name: PORT
              value: "8000"
            - name: COROOT_URL
              value: "http://10.30.0.20:32702"  # Monit cluster NodePort (cross-cluster access)
            - name: COROOT_PROJECT
              value: "all-clusters"  # Multi-cluster aggregated view
          volumeMounts:
            - name: code
              mountPath: /code
            - name: deps
              mountPath: /app/deps
          resources:
            requests:
              memory: "128Mi"
              cpu: "50m"
            limits:
              memory: "256Mi"
              cpu: "250m"
          readinessProbe:
            httpGet:
              path: /health
              port: 8000
            initialDelaySeconds: 30
            periodSeconds: 10
          livenessProbe:
            httpGet:
              path: /health
              port: 8000
            initialDelaySeconds: 60
            periodSeconds: 30
      volumes:
        - name: code
          configMap:
            name: coroot-mcp-code
        - name: deps
          emptyDir: {}
---
apiVersion: v1
kind: Service
metadata:
  name: coroot-mcp
  namespace: ai-platform
  labels:
    app: coroot-mcp
    component: mcp
spec:
  type: NodePort
  selector:
    app: coroot-mcp
  ports:
    - port: 8000
      targetPort: 8000
      nodePort: 31081
      name: http
