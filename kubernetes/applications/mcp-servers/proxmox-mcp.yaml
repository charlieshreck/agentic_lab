---
apiVersion: v1
kind: ConfigMap
metadata:
  name: proxmox-mcp-code
  namespace: ai-platform
data:
  main.py: |
    #!/usr/bin/env python3
    """Proxmox VE MCP server for hypervisor management."""
    import os
    import json
    import logging
    from typing import Optional, List, Dict, Any
    from enum import Enum
    from fastmcp import FastMCP
    from pydantic import BaseModel, Field, ConfigDict
    import httpx

    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger(__name__)

    PROXMOX_HOST = os.environ.get("PROXMOX_HOST", "https://10.10.0.10:8006")
    PROXMOX_USER = os.environ.get("PROXMOX_USER", "root@pam")
    PROXMOX_TOKEN_ID = os.environ.get("PROXMOX_TOKEN_ID", "")
    PROXMOX_TOKEN_SECRET = os.environ.get("PROXMOX_TOKEN_SECRET", "")

    mcp = FastMCP(
        name="proxmox_mcp",
        instructions="MCP server for Proxmox VE hypervisor management. Provides tools to list nodes, VMs, containers, and manage VM lifecycle."
    )

    # Enums
    class ResponseFormat(str, Enum):
        MARKDOWN = "markdown"
        JSON = "json"

    # Pydantic Input Models
    class ListNodesInput(BaseModel):
        model_config = ConfigDict(str_strip_whitespace=True)
        response_format: ResponseFormat = Field(default=ResponseFormat.MARKDOWN, description="Output format: 'markdown' or 'json'")

    class ListVMsInput(BaseModel):
        model_config = ConfigDict(str_strip_whitespace=True)
        node: Optional[str] = Field(default=None, description="Filter by node name (e.g., 'pve1'). If omitted, lists VMs from all nodes.")
        response_format: ResponseFormat = Field(default=ResponseFormat.MARKDOWN, description="Output format: 'markdown' or 'json'")

    class VMOperationInput(BaseModel):
        model_config = ConfigDict(str_strip_whitespace=True)
        node: str = Field(..., description="Node name where the VM is located (e.g., 'pve1')", min_length=1)
        vmid: int = Field(..., description="VM ID number (e.g., 100)", ge=100, le=999999999)

    # Shared utilities
    async def _proxmox_api(endpoint: str, method: str = "GET", data: dict = None) -> Dict[str, Any]:
        """Make authenticated request to Proxmox API."""
        headers = {"Authorization": f"PVEAPIToken={PROXMOX_USER}!{PROXMOX_TOKEN_ID}={PROXMOX_TOKEN_SECRET}"}
        url = f"{PROXMOX_HOST}/api2/json{endpoint}"
        async with httpx.AsyncClient(verify=False, timeout=30.0) as client:
            if method == "GET":
                response = await client.get(url, headers=headers)
            else:
                response = await client.post(url, headers=headers, json=data)
            response.raise_for_status()
            return response.json().get("data", {})

    def _handle_error(e: Exception) -> str:
        """Format errors with actionable messages."""
        if isinstance(e, httpx.HTTPStatusError):
            status = e.response.status_code
            if status == 401:
                return "Error: Authentication failed. Check PROXMOX_TOKEN_ID and PROXMOX_TOKEN_SECRET."
            elif status == 403:
                return "Error: Permission denied. Ensure the API token has sufficient privileges."
            elif status == 404:
                return "Error: Resource not found. Verify the node name and VMID are correct."
            elif status == 500:
                return "Error: Proxmox server error. Check Proxmox logs for details."
            return f"Error: API request failed with status {status}."
        elif isinstance(e, httpx.TimeoutException):
            return "Error: Request timed out. Check network connectivity to Proxmox."
        return f"Error: {type(e).__name__}: {str(e)}"

    # Tools
    @mcp.tool(
        name="proxmox_list_nodes",
        annotations={"readOnlyHint": True, "destructiveHint": False, "idempotentHint": True, "openWorldHint": True}
    )
    async def proxmox_list_nodes(params: ListNodesInput) -> str:
        """List all Proxmox cluster nodes with status and resource usage.

        Returns node names, online status, CPU/memory usage, and uptime.
        Use this to discover available nodes before listing VMs.
        """
        try:
            nodes = await _proxmox_api("/nodes")
            if params.response_format == ResponseFormat.JSON:
                return json.dumps({"nodes": nodes, "count": len(nodes)}, indent=2)

            lines = ["# Proxmox Cluster Nodes", "", f"Found {len(nodes)} node(s)", ""]
            for n in nodes:
                status = "ðŸŸ¢ Online" if n.get("status") == "online" else "ðŸ”´ Offline"
                cpu = f"{n.get('cpu', 0)*100:.1f}%" if n.get('cpu') else "N/A"
                mem_used = n.get('mem', 0) / (1024**3)
                mem_total = n.get('maxmem', 1) / (1024**3)
                lines.append(f"## {n.get('node')} ({status})")
                lines.append(f"- **CPU**: {cpu}")
                lines.append(f"- **Memory**: {mem_used:.1f} / {mem_total:.1f} GB")
                lines.append(f"- **Uptime**: {n.get('uptime', 0) // 3600} hours")
                lines.append("")
            return "\n".join(lines)
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(
        name="proxmox_list_vms",
        annotations={"readOnlyHint": True, "destructiveHint": False, "idempotentHint": True, "openWorldHint": True}
    )
    async def proxmox_list_vms(params: ListVMsInput) -> str:
        """List all QEMU virtual machines across the cluster.

        Returns VM ID, name, status, CPU, memory, and node location.
        Optionally filter by node name to see VMs on a specific host.
        """
        try:
            if params.node:
                vms = await _proxmox_api(f"/nodes/{params.node}/qemu")
                for vm in vms:
                    vm["node"] = params.node
            else:
                nodes = await _proxmox_api("/nodes")
                vms = []
                for n in nodes:
                    node_vms = await _proxmox_api(f"/nodes/{n['node']}/qemu")
                    for vm in node_vms:
                        vm["node"] = n["node"]
                    vms.extend(node_vms)

            if params.response_format == ResponseFormat.JSON:
                return json.dumps({"vms": vms, "count": len(vms)}, indent=2)

            lines = ["# Virtual Machines", "", f"Found {len(vms)} VM(s)", ""]
            for vm in sorted(vms, key=lambda x: x.get("vmid", 0)):
                status_icon = "ðŸŸ¢" if vm.get("status") == "running" else "âš«"
                mem_gb = vm.get("maxmem", 0) / (1024**3)
                lines.append(f"## {vm.get('name', 'unnamed')} (ID: {vm.get('vmid')}) {status_icon}")
                lines.append(f"- **Node**: {vm.get('node')}")
                lines.append(f"- **Status**: {vm.get('status')}")
                lines.append(f"- **CPUs**: {vm.get('cpus', 'N/A')}")
                lines.append(f"- **Memory**: {mem_gb:.1f} GB")
                lines.append("")
            return "\n".join(lines) if vms else "No VMs found."
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(
        name="proxmox_get_vm_status",
        annotations={"readOnlyHint": True, "destructiveHint": False, "idempotentHint": True, "openWorldHint": True}
    )
    async def proxmox_get_vm_status(params: VMOperationInput) -> str:
        """Get detailed status of a specific VM including CPU, memory, disk, and network stats."""
        try:
            status = await _proxmox_api(f"/nodes/{params.node}/qemu/{params.vmid}/status/current")
            return json.dumps(status, indent=2)
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(
        name="proxmox_start_vm",
        annotations={"readOnlyHint": False, "destructiveHint": False, "idempotentHint": False, "openWorldHint": True}
    )
    async def proxmox_start_vm(params: VMOperationInput) -> str:
        """Start a stopped VM. Returns the task ID for tracking the operation."""
        try:
            result = await _proxmox_api(f"/nodes/{params.node}/qemu/{params.vmid}/status/start", "POST")
            return f"âœ… VM {params.vmid} start initiated on {params.node}. Task: {result}"
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(
        name="proxmox_stop_vm",
        annotations={"readOnlyHint": False, "destructiveHint": True, "idempotentHint": False, "openWorldHint": True}
    )
    async def proxmox_stop_vm(params: VMOperationInput) -> str:
        """Stop a running VM (hard stop). For graceful shutdown, use proxmox_shutdown_vm."""
        try:
            result = await _proxmox_api(f"/nodes/{params.node}/qemu/{params.vmid}/status/stop", "POST")
            return f"âš ï¸ VM {params.vmid} stop initiated on {params.node}. Task: {result}"
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(
        name="proxmox_shutdown_vm",
        annotations={"readOnlyHint": False, "destructiveHint": False, "idempotentHint": False, "openWorldHint": True}
    )
    async def proxmox_shutdown_vm(params: VMOperationInput) -> str:
        """Gracefully shutdown a VM via ACPI. Preferred over hard stop."""
        try:
            result = await _proxmox_api(f"/nodes/{params.node}/qemu/{params.vmid}/status/shutdown", "POST")
            return f"âœ… VM {params.vmid} shutdown initiated on {params.node}. Task: {result}"
        except Exception as e:
            return _handle_error(e)

    if __name__ == "__main__":
        import uvicorn
        uvicorn.run(mcp.get_app(), host="0.0.0.0", port=8000)
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: proxmox-mcp
  namespace: ai-platform
spec:
  replicas: 1
  selector:
    matchLabels:
      app: proxmox-mcp
  template:
    metadata:
      labels:
        app: proxmox-mcp
    spec:
      containers:
        - name: proxmox-mcp
          image: python:3.11-slim
          command: ["sh", "-c"]
          args:
            - pip install --no-cache-dir fastmcp httpx pydantic uvicorn && python /app/main.py
          ports:
            - containerPort: 8000
          env:
            - name: PROXMOX_HOST
              value: "https://10.10.0.10:8006"
            - name: PROXMOX_USER
              value: "root@pam"
            - name: PROXMOX_TOKEN_ID
              valueFrom:
                secretKeyRef:
                  name: mcp-proxmox
                  key: TOKEN_ID
            - name: PROXMOX_TOKEN_SECRET
              valueFrom:
                secretKeyRef:
                  name: mcp-proxmox
                  key: API_TOKEN
          volumeMounts:
            - name: code
              mountPath: /app
          resources:
            requests:
              memory: "128Mi"
              cpu: "100m"
            limits:
              memory: "256Mi"
              cpu: "500m"
      volumes:
        - name: code
          configMap:
            name: proxmox-mcp-code
---
apiVersion: v1
kind: Service
metadata:
  name: proxmox-mcp
  namespace: ai-platform
spec:
  selector:
    app: proxmox-mcp
  ports:
    - port: 8000
      targetPort: 8000
