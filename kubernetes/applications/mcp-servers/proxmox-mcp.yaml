---
apiVersion: v1
kind: ConfigMap
metadata:
  name: proxmox-mcp-code
  namespace: ai-platform
data:
  main.py: |
    #!/usr/bin/env python3
    """Proxmox VE MCP server for hypervisor management."""
    import os
    import json
    import logging
    from typing import Optional, List, Dict, Any
    from enum import Enum
    from fastmcp import FastMCP
    from pydantic import BaseModel, Field, ConfigDict
    import httpx

    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger(__name__)

    PROXMOX_HOST = os.environ.get("PROXMOX_HOST", "https://10.10.0.10:8006")
    PROXMOX_USER = os.environ.get("PROXMOX_USER", "root@pam")
    PROXMOX_TOKEN_ID = os.environ.get("PROXMOX_TOKEN_ID", "")
    PROXMOX_TOKEN_SECRET = os.environ.get("PROXMOX_TOKEN_SECRET", "")

    mcp = FastMCP(
        name="proxmox_mcp",
        instructions="MCP server for Proxmox VE hypervisor management. Provides tools to list nodes, VMs, containers, and manage VM lifecycle."
    )

    # Enums
    class ResponseFormat(str, Enum):
        MARKDOWN = "markdown"
        JSON = "json"

    # Pydantic Input Models
    class ListNodesInput(BaseModel):
        model_config = ConfigDict(str_strip_whitespace=True)
        response_format: ResponseFormat = Field(default=ResponseFormat.MARKDOWN, description="Output format: 'markdown' or 'json'")

    class ListVMsInput(BaseModel):
        model_config = ConfigDict(str_strip_whitespace=True)
        node: Optional[str] = Field(default=None, description="Filter by node name (e.g., 'pve1'). If omitted, lists VMs from all nodes.")
        response_format: ResponseFormat = Field(default=ResponseFormat.MARKDOWN, description="Output format: 'markdown' or 'json'")

    class VMOperationInput(BaseModel):
        model_config = ConfigDict(str_strip_whitespace=True)
        node: str = Field(..., description="Node name where the VM is located (e.g., 'pve1')", min_length=1)
        vmid: int = Field(..., description="VM ID number (e.g., 100)", ge=100, le=999999999)

    # Shared utilities
    async def _proxmox_api(endpoint: str, method: str = "GET", data: dict = None) -> Dict[str, Any]:
        """Make authenticated request to Proxmox API."""
        # TOKEN_ID format is already USER@REALM!TOKENNAME, so don't prepend PROXMOX_USER
        headers = {"Authorization": f"PVEAPIToken={PROXMOX_TOKEN_ID}={PROXMOX_TOKEN_SECRET}"}
        url = f"{PROXMOX_HOST}/api2/json{endpoint}"
        async with httpx.AsyncClient(verify=False, timeout=30.0) as client:
            if method == "GET":
                response = await client.get(url, headers=headers)
            else:
                response = await client.post(url, headers=headers, json=data)
            response.raise_for_status()
            return response.json().get("data", {})

    def _handle_error(e: Exception) -> str:
        """Format errors with actionable messages."""
        if isinstance(e, httpx.HTTPStatusError):
            status = e.response.status_code
            if status == 401:
                return "Error: Authentication failed. Check PROXMOX_TOKEN_ID and PROXMOX_TOKEN_SECRET."
            elif status == 403:
                return "Error: Permission denied. Ensure the API token has sufficient privileges."
            elif status == 404:
                return "Error: Resource not found. Verify the node name and VMID are correct."
            elif status == 500:
                return "Error: Proxmox server error. Check Proxmox logs for details."
            return f"Error: API request failed with status {status}."
        elif isinstance(e, httpx.TimeoutException):
            return "Error: Request timed out. Check network connectivity to Proxmox."
        return f"Error: {type(e).__name__}: {str(e)}"

    # Tools
    @mcp.tool(
        name="proxmox_list_nodes",
        annotations={"readOnlyHint": True, "destructiveHint": False, "idempotentHint": True, "openWorldHint": True}
    )
    async def proxmox_list_nodes(params: ListNodesInput) -> str:
        """List all Proxmox cluster nodes with status and resource usage.

        Returns node names, online status, CPU/memory usage, and uptime.
        Use this to discover available nodes before listing VMs.
        """
        try:
            nodes = await _proxmox_api("/nodes")
            if params.response_format == ResponseFormat.JSON:
                return json.dumps({"nodes": nodes, "count": len(nodes)}, indent=2)

            lines = ["# Proxmox Cluster Nodes", "", f"Found {len(nodes)} node(s)", ""]
            for n in nodes:
                status = "[OK] Online" if n.get("status") == "online" else "[ERR] Offline"
                cpu = f"{n.get('cpu', 0)*100:.1f}%" if n.get('cpu') else "N/A"
                mem_used = n.get('mem', 0) / (1024**3)
                mem_total = n.get('maxmem', 1) / (1024**3)
                lines.append(f"## {n.get('node')} ({status})")
                lines.append(f"- **CPU**: {cpu}")
                lines.append(f"- **Memory**: {mem_used:.1f} / {mem_total:.1f} GB")
                lines.append(f"- **Uptime**: {n.get('uptime', 0) // 3600} hours")
                lines.append("")
            return "\n".join(lines)
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(
        name="proxmox_list_vms",
        annotations={"readOnlyHint": True, "destructiveHint": False, "idempotentHint": True, "openWorldHint": True}
    )
    async def proxmox_list_vms(params: ListVMsInput) -> str:
        """List all QEMU virtual machines across the cluster.

        Returns VM ID, name, status, CPU, memory, and node location.
        Optionally filter by node name to see VMs on a specific host.
        """
        try:
            if params.node:
                vms = await _proxmox_api(f"/nodes/{params.node}/qemu")
                for vm in vms:
                    vm["node"] = params.node
            else:
                nodes = await _proxmox_api("/nodes")
                vms = []
                for n in nodes:
                    node_vms = await _proxmox_api(f"/nodes/{n['node']}/qemu")
                    for vm in node_vms:
                        vm["node"] = n["node"]
                    vms.extend(node_vms)

            if params.response_format == ResponseFormat.JSON:
                return json.dumps({"vms": vms, "count": len(vms)}, indent=2)

            lines = ["# Virtual Machines", "", f"Found {len(vms)} VM(s)", ""]
            for vm in sorted(vms, key=lambda x: x.get("vmid", 0)):
                status_icon = "[OK]" if vm.get("status") == "running" else "[ ]"
                mem_gb = vm.get("maxmem", 0) / (1024**3)
                lines.append(f"## {vm.get('name', 'unnamed')} (ID: {vm.get('vmid')}) {status_icon}")
                lines.append(f"- **Node**: {vm.get('node')}")
                lines.append(f"- **Status**: {vm.get('status')}")
                lines.append(f"- **CPUs**: {vm.get('cpus', 'N/A')}")
                lines.append(f"- **Memory**: {mem_gb:.1f} GB")
                lines.append("")
            return "\n".join(lines) if vms else "No VMs found."
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(
        name="proxmox_get_vm_status",
        annotations={"readOnlyHint": True, "destructiveHint": False, "idempotentHint": True, "openWorldHint": True}
    )
    async def proxmox_get_vm_status(params: VMOperationInput) -> str:
        """Get detailed status of a specific VM including CPU, memory, disk, and network stats."""
        try:
            status = await _proxmox_api(f"/nodes/{params.node}/qemu/{params.vmid}/status/current")
            return json.dumps(status, indent=2)
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(
        name="proxmox_start_vm",
        annotations={"readOnlyHint": False, "destructiveHint": False, "idempotentHint": False, "openWorldHint": True}
    )
    async def proxmox_start_vm(params: VMOperationInput) -> str:
        """Start a stopped VM. Returns the task ID for tracking the operation."""
        try:
            result = await _proxmox_api(f"/nodes/{params.node}/qemu/{params.vmid}/status/start", "POST")
            return f" VM {params.vmid} start initiated on {params.node}. Task: {result}"
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(
        name="proxmox_stop_vm",
        annotations={"readOnlyHint": False, "destructiveHint": True, "idempotentHint": False, "openWorldHint": True}
    )
    async def proxmox_stop_vm(params: VMOperationInput) -> str:
        """Stop a running VM (hard stop). For graceful shutdown, use proxmox_shutdown_vm."""
        try:
            result = await _proxmox_api(f"/nodes/{params.node}/qemu/{params.vmid}/status/stop", "POST")
            return f"[!] VM {params.vmid} stop initiated on {params.node}. Task: {result}"
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(
        name="proxmox_shutdown_vm",
        annotations={"readOnlyHint": False, "destructiveHint": False, "idempotentHint": False, "openWorldHint": True}
    )
    async def proxmox_shutdown_vm(params: VMOperationInput) -> str:
        """Gracefully shutdown a VM via ACPI. Preferred over hard stop."""
        try:
            result = await _proxmox_api(f"/nodes/{params.node}/qemu/{params.vmid}/status/shutdown", "POST")
            return f" VM {params.vmid} shutdown initiated on {params.node}. Task: {result}"
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(
        name="proxmox_reboot_vm",
        annotations={"readOnlyHint": False, "destructiveHint": False, "idempotentHint": False, "openWorldHint": True}
    )
    async def proxmox_reboot_vm(params: VMOperationInput) -> str:
        """Gracefully reboot a VM via ACPI."""
        try:
            result = await _proxmox_api(f"/nodes/{params.node}/qemu/{params.vmid}/status/reboot", "POST")
            return f" VM {params.vmid} reboot initiated on {params.node}. Task: {result}"
        except Exception as e:
            return _handle_error(e)

    # ============================================================================
    # LXC CONTAINER TOOLS
    # ============================================================================

    @mcp.tool(
        name="proxmox_list_containers",
        annotations={"readOnlyHint": True, "destructiveHint": False, "idempotentHint": True, "openWorldHint": True}
    )
    async def proxmox_list_containers(params: ListVMsInput) -> str:
        """List all LXC containers across the cluster."""
        try:
            if params.node:
                containers = await _proxmox_api(f"/nodes/{params.node}/lxc")
                for ct in containers:
                    ct["node"] = params.node
            else:
                nodes = await _proxmox_api("/nodes")
                containers = []
                for n in nodes:
                    node_containers = await _proxmox_api(f"/nodes/{n['node']}/lxc")
                    for ct in node_containers:
                        ct["node"] = n["node"]
                    containers.extend(node_containers)

            if params.response_format == ResponseFormat.JSON:
                return json.dumps({"containers": containers, "count": len(containers)}, indent=2)

            lines = ["# LXC Containers", "", f"Found {len(containers)} container(s)", ""]
            for ct in sorted(containers, key=lambda x: x.get("vmid", 0)):
                status_icon = "[OK]" if ct.get("status") == "running" else "[ ]"
                mem_gb = ct.get("maxmem", 0) / (1024**3)
                lines.append(f"## {ct.get('name', 'unnamed')} (ID: {ct.get('vmid')}) {status_icon}")
                lines.append(f"- **Node**: {ct.get('node')}")
                lines.append(f"- **Status**: {ct.get('status')}")
                lines.append(f"- **CPUs**: {ct.get('cpus', 'N/A')}")
                lines.append(f"- **Memory**: {mem_gb:.1f} GB")
                lines.append("")
            return "\n".join(lines) if containers else "No containers found."
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(
        name="proxmox_get_container_status",
        annotations={"readOnlyHint": True, "destructiveHint": False, "idempotentHint": True, "openWorldHint": True}
    )
    async def proxmox_get_container_status(params: VMOperationInput) -> str:
        """Get detailed status of a specific LXC container."""
        try:
            status = await _proxmox_api(f"/nodes/{params.node}/lxc/{params.vmid}/status/current")
            return json.dumps(status, indent=2)
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(
        name="proxmox_start_container",
        annotations={"readOnlyHint": False, "destructiveHint": False, "idempotentHint": False, "openWorldHint": True}
    )
    async def proxmox_start_container(params: VMOperationInput) -> str:
        """Start a stopped LXC container."""
        try:
            result = await _proxmox_api(f"/nodes/{params.node}/lxc/{params.vmid}/status/start", "POST")
            return f" Container {params.vmid} start initiated on {params.node}. Task: {result}"
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(
        name="proxmox_stop_container",
        annotations={"readOnlyHint": False, "destructiveHint": True, "idempotentHint": False, "openWorldHint": True}
    )
    async def proxmox_stop_container(params: VMOperationInput) -> str:
        """Stop a running LXC container (hard stop)."""
        try:
            result = await _proxmox_api(f"/nodes/{params.node}/lxc/{params.vmid}/status/stop", "POST")
            return f"[!] Container {params.vmid} stop initiated on {params.node}. Task: {result}"
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(
        name="proxmox_shutdown_container",
        annotations={"readOnlyHint": False, "destructiveHint": False, "idempotentHint": False, "openWorldHint": True}
    )
    async def proxmox_shutdown_container(params: VMOperationInput) -> str:
        """Gracefully shutdown an LXC container."""
        try:
            result = await _proxmox_api(f"/nodes/{params.node}/lxc/{params.vmid}/status/shutdown", "POST")
            return f" Container {params.vmid} shutdown initiated on {params.node}. Task: {result}"
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(
        name="proxmox_reboot_container",
        annotations={"readOnlyHint": False, "destructiveHint": False, "idempotentHint": False, "openWorldHint": True}
    )
    async def proxmox_reboot_container(params: VMOperationInput) -> str:
        """Reboot an LXC container."""
        try:
            result = await _proxmox_api(f"/nodes/{params.node}/lxc/{params.vmid}/status/reboot", "POST")
            return f" Container {params.vmid} reboot initiated on {params.node}. Task: {result}"
        except Exception as e:
            return _handle_error(e)

    # ============================================================================
    # STORAGE TOOLS
    # ============================================================================

    @mcp.tool(
        name="proxmox_list_storage",
        annotations={"readOnlyHint": True, "destructiveHint": False, "idempotentHint": True, "openWorldHint": True}
    )
    async def proxmox_list_storage(params: ListNodesInput) -> str:
        """List all storage pools across the cluster."""
        try:
            storage = await _proxmox_api("/storage")
            if params.response_format == ResponseFormat.JSON:
                return json.dumps({"storage": storage, "count": len(storage)}, indent=2)

            lines = ["# Storage Pools", "", f"Found {len(storage)} storage pool(s)", ""]
            for s in storage:
                enabled = "[OK]" if s.get("disable") != 1 else "[ERR]"
                lines.append(f"## {s.get('storage')} {enabled}")
                lines.append(f"- **Type**: {s.get('type')}")
                lines.append(f"- **Content**: {s.get('content', 'N/A')}")
                lines.append(f"- **Shared**: {'Yes' if s.get('shared') else 'No'}")
                lines.append("")
            return "\n".join(lines)
        except Exception as e:
            return _handle_error(e)

    class StorageStatusInput(BaseModel):
        model_config = ConfigDict(str_strip_whitespace=True)
        node: str = Field(..., description="Node name", min_length=1)
        storage: str = Field(..., description="Storage name")
        response_format: ResponseFormat = Field(default=ResponseFormat.MARKDOWN)

    @mcp.tool(
        name="proxmox_get_storage_status",
        annotations={"readOnlyHint": True, "destructiveHint": False, "idempotentHint": True, "openWorldHint": True}
    )
    async def proxmox_get_storage_status(params: StorageStatusInput) -> str:
        """Get storage pool status with usage on a specific node."""
        try:
            status = await _proxmox_api(f"/nodes/{params.node}/storage/{params.storage}/status")
            if params.response_format == ResponseFormat.JSON:
                return json.dumps(status, indent=2)

            total = status.get("total", 0) / (1024**3)
            used = status.get("used", 0) / (1024**3)
            avail = status.get("avail", 0) / (1024**3)
            pct = (used / total * 100) if total > 0 else 0

            lines = [f"# Storage: {params.storage}", ""]
            lines.append(f"- **Type**: {status.get('type')}")
            lines.append(f"- **Total**: {total:.1f} GB")
            lines.append(f"- **Used**: {used:.1f} GB ({pct:.1f}%)")
            lines.append(f"- **Available**: {avail:.1f} GB")
            lines.append(f"- **Active**: {'Yes' if status.get('active') else 'No'}")
            return "\n".join(lines)
        except Exception as e:
            return _handle_error(e)

    # ============================================================================
    # SNAPSHOT TOOLS
    # ============================================================================

    class SnapshotInput(BaseModel):
        model_config = ConfigDict(str_strip_whitespace=True)
        node: str = Field(..., description="Node name", min_length=1)
        vmid: int = Field(..., description="VM/Container ID", ge=100)
        snapname: str = Field(..., description="Snapshot name")

    class SnapshotCreateInput(BaseModel):
        model_config = ConfigDict(str_strip_whitespace=True)
        node: str = Field(..., description="Node name", min_length=1)
        vmid: int = Field(..., description="VM/Container ID", ge=100)
        snapname: str = Field(..., description="Snapshot name")
        description: str = Field(default="", description="Snapshot description")
        vmstate: bool = Field(default=False, description="Include VM RAM (only for VMs)")

    @mcp.tool(
        name="proxmox_list_snapshots",
        annotations={"readOnlyHint": True, "destructiveHint": False, "idempotentHint": True, "openWorldHint": True}
    )
    async def proxmox_list_snapshots(params: VMOperationInput) -> str:
        """List all snapshots for a VM or container."""
        try:
            # Try QEMU first, then LXC
            try:
                snapshots = await _proxmox_api(f"/nodes/{params.node}/qemu/{params.vmid}/snapshot")
            except:
                snapshots = await _proxmox_api(f"/nodes/{params.node}/lxc/{params.vmid}/snapshot")

            lines = [f"# Snapshots for {params.vmid}", ""]
            for snap in snapshots:
                if snap.get("name") == "current":
                    continue
                lines.append(f"- **{snap.get('name')}**")
                if snap.get("description"):
                    lines.append(f"  - {snap.get('description')}")
                if snap.get("snaptime"):
                    from datetime import datetime
                    ts = datetime.fromtimestamp(snap.get("snaptime"))
                    lines.append(f"  - Created: {ts.isoformat()}")
            return "\n".join(lines) if len(lines) > 2 else "No snapshots found."
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(
        name="proxmox_create_snapshot",
        annotations={"readOnlyHint": False, "destructiveHint": False, "idempotentHint": False, "openWorldHint": True}
    )
    async def proxmox_create_snapshot(params: SnapshotCreateInput) -> str:
        """Create a snapshot of a VM or container."""
        try:
            data = {"snapname": params.snapname}
            if params.description:
                data["description"] = params.description
            if params.vmstate:
                data["vmstate"] = 1

            # Try QEMU first, then LXC
            try:
                result = await _proxmox_api(f"/nodes/{params.node}/qemu/{params.vmid}/snapshot", "POST", data)
            except:
                result = await _proxmox_api(f"/nodes/{params.node}/lxc/{params.vmid}/snapshot", "POST", data)

            return f" Snapshot '{params.snapname}' created for {params.vmid}. Task: {result}"
        except Exception as e:
            return _handle_error(e)

    # ============================================================================
    # TASK MONITORING
    # ============================================================================

    class TaskInput(BaseModel):
        model_config = ConfigDict(str_strip_whitespace=True)
        node: str = Field(..., description="Node name", min_length=1)
        upid: str = Field(..., description="Task UPID")

    @mcp.tool(
        name="proxmox_get_task_status",
        annotations={"readOnlyHint": True, "destructiveHint": False, "idempotentHint": True, "openWorldHint": True}
    )
    async def proxmox_get_task_status(params: TaskInput) -> str:
        """Get status of a running or completed task."""
        try:
            status = await _proxmox_api(f"/nodes/{params.node}/tasks/{params.upid}/status")
            return json.dumps(status, indent=2)
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(
        name="proxmox_list_tasks",
        annotations={"readOnlyHint": True, "destructiveHint": False, "idempotentHint": True, "openWorldHint": True}
    )
    async def proxmox_list_tasks(params: ListNodesInput) -> str:
        """List recent tasks on all nodes."""
        try:
            nodes = await _proxmox_api("/nodes")
            all_tasks = []
            for n in nodes:
                tasks = await _proxmox_api(f"/nodes/{n['node']}/tasks?limit=10")
                for t in tasks:
                    t["node"] = n["node"]
                all_tasks.extend(tasks)

            if params.response_format == ResponseFormat.JSON:
                return json.dumps({"tasks": all_tasks[:20]}, indent=2)

            lines = ["# Recent Tasks", ""]
            for t in sorted(all_tasks, key=lambda x: x.get("starttime", 0), reverse=True)[:15]:
                status_icon = "" if t.get("status") == "OK" else "[SYNC]" if t.get("status") is None else "[ERR]"
                lines.append(f"- {status_icon} **{t.get('type')}** on {t.get('node')}")
                lines.append(f"  - ID: {t.get('id', 'N/A')} | Status: {t.get('status', 'running')}")
            return "\n".join(lines)
        except Exception as e:
            return _handle_error(e)

    # ============================================================================
    # CLUSTER OVERVIEW
    # ============================================================================

    @mcp.tool(
        name="proxmox_get_cluster_status",
        annotations={"readOnlyHint": True, "destructiveHint": False, "idempotentHint": True, "openWorldHint": True}
    )
    async def proxmox_get_cluster_status(params: ListNodesInput) -> str:
        """Get overall cluster status including quorum and node health."""
        try:
            status = await _proxmox_api("/cluster/status")
            if params.response_format == ResponseFormat.JSON:
                return json.dumps(status, indent=2)

            lines = ["# Cluster Status", ""]
            for item in status:
                if item.get("type") == "cluster":
                    lines.append(f"## Cluster: {item.get('name')}")
                    lines.append(f"- **Quorum**: {'Yes' if item.get('quorate') else 'No'}")
                    lines.append(f"- **Nodes**: {item.get('nodes')}")
                    lines.append("")
                elif item.get("type") == "node":
                    online = "[OK]" if item.get("online") else "[ERR]"
                    lines.append(f"- {online} **{item.get('name')}** (ID: {item.get('nodeid')})")

            return "\n".join(lines)
        except Exception as e:
            return _handle_error(e)

    # ============================================================================
    # REST API
    # ============================================================================

    from starlette.applications import Starlette
    from starlette.routing import Route, Mount
    from starlette.responses import JSONResponse

    async def rest_health(request):
        """Health check endpoint."""
        return JSONResponse({"status": "healthy"})

    if __name__ == "__main__":
        import uvicorn
        rest_routes = [Route("/health", rest_health, methods=["GET"])]
        mcp_app = mcp.http_app()
        app = Starlette(
            routes=rest_routes + [Mount("/", app=mcp_app)],
            lifespan=mcp_app.lifespan
        )
        uvicorn.run(app, host="0.0.0.0", port=8000)
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: proxmox-mcp
  namespace: ai-platform
spec:
  replicas: 1
  selector:
    matchLabels:
      app: proxmox-mcp
  template:
    metadata:
      labels:
        app: proxmox-mcp
    spec:
      containers:
        - name: proxmox-mcp
          image: python:3.11-slim
          command: ["sh", "-c"]
          args:
            - pip install --no-cache-dir fastmcp httpx pydantic uvicorn starlette && python /app/main.py
          ports:
            - containerPort: 8000
          env:
            - name: PROXMOX_HOST
              value: "https://10.10.0.10:8006"
            - name: PROXMOX_USER
              value: "root@pam"
            - name: PROXMOX_TOKEN_ID
              valueFrom:
                secretKeyRef:
                  name: mcp-proxmox
                  key: TOKEN_ID
            - name: PROXMOX_TOKEN_SECRET
              valueFrom:
                secretKeyRef:
                  name: mcp-proxmox
                  key: API_TOKEN
          volumeMounts:
            - name: code
              mountPath: /app
          resources:
            requests:
              memory: "128Mi"
              cpu: "100m"
            limits:
              memory: "256Mi"
              cpu: "500m"
      volumes:
        - name: code
          configMap:
            name: proxmox-mcp-code
---
apiVersion: v1
kind: Service
metadata:
  name: proxmox-mcp
  namespace: ai-platform
spec:
  type: NodePort
  selector:
    app: proxmox-mcp
  ports:
    - port: 8000
      targetPort: 8000
      nodePort: 31082
