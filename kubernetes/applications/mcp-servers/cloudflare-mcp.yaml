---
apiVersion: v1
kind: ConfigMap
metadata:
  name: cloudflare-mcp-code
  namespace: ai-platform
data:
  main.py: |
    #!/usr/bin/env python3
    """Cloudflare MCP server for DNS and tunnel management."""
    import os
    import json
    import logging
    from typing import Optional, List, Dict, Any
    from enum import Enum
    from fastmcp import FastMCP
    from pydantic import BaseModel, Field, ConfigDict
    import httpx

    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger(__name__)

    CF_API_TOKEN = os.environ.get("CLOUDFLARE_API_TOKEN", "")
    CF_ACCOUNT_ID = os.environ.get("CLOUDFLARE_ACCOUNT_ID", "")

    mcp = FastMCP(
        name="cloudflare_mcp",
        instructions="MCP server for Cloudflare. Provides tools for DNS zone management, DNS records, and Cloudflare Tunnel status.",
        stateless_http=True
    )

    class ResponseFormat(str, Enum):
        MARKDOWN = "markdown"
        JSON = "json"

    class BaseInput(BaseModel):
        model_config = ConfigDict(str_strip_whitespace=True)
        response_format: ResponseFormat = Field(default=ResponseFormat.MARKDOWN, description="Output format")

    class ZoneInput(BaseModel):
        model_config = ConfigDict(str_strip_whitespace=True)
        zone_id: str = Field(..., description="Zone ID (32-char hex string)", min_length=32, max_length=32)
        response_format: ResponseFormat = Field(default=ResponseFormat.MARKDOWN, description="Output format")

    class TunnelInput(BaseModel):
        model_config = ConfigDict(str_strip_whitespace=True)
        tunnel_id: str = Field(..., description="Tunnel UUID", min_length=36, max_length=36)

    async def _cf_api(endpoint: str, method: str = "GET", data: dict = None) -> Dict[str, Any]:
        headers = {"Authorization": f"Bearer {CF_API_TOKEN}", "Content-Type": "application/json"}
        async with httpx.AsyncClient(timeout=30.0) as client:
            url = f"https://api.cloudflare.com/client/v4{endpoint}"
            if method == "GET":
                response = await client.get(url, headers=headers)
            elif method == "POST":
                response = await client.post(url, headers=headers, json=data)
            elif method == "PUT":
                response = await client.put(url, headers=headers, json=data)
            elif method == "DELETE":
                response = await client.delete(url, headers=headers)
            response.raise_for_status()
            return response.json()

    def _handle_error(e: Exception) -> str:
        if isinstance(e, httpx.HTTPStatusError):
            status = e.response.status_code
            if status == 401:
                return "Error: Invalid API token. Check CLOUDFLARE_API_TOKEN."
            elif status == 403:
                return "Error: Token lacks required permissions for this operation."
            elif status == 404:
                return "Error: Resource not found. Check zone_id or tunnel_id."
            return f"Error: Cloudflare API returned status {status}."
        elif isinstance(e, httpx.TimeoutException):
            return "Error: Request timed out connecting to Cloudflare API."
        return f"Error: {type(e).__name__}: {str(e)}"

    @mcp.tool(
        name="cloudflare_list_zones",
        annotations={"readOnlyHint": True, "destructiveHint": False, "idempotentHint": True, "openWorldHint": True}
    )
    async def cloudflare_list_zones(params: BaseInput) -> str:
        """List all DNS zones in the Cloudflare account with status and nameservers."""
        try:
            result = await _cf_api("/zones")
            zones = result.get("result", [])
            if params.response_format == ResponseFormat.JSON:
                return json.dumps({"zones": zones, "count": len(zones)}, indent=2)

            lines = ["# Cloudflare DNS Zones", "", f"Found {len(zones)} zone(s)", ""]
            for z in zones:
                status = "[OK] Active" if z.get("status") == "active" else f"[!] {z.get('status')}"
                lines.append(f"## {z.get('name')} ({status})")
                lines.append(f"- ID: `{z.get('id')}`")
                lines.append(f"- Plan: {z.get('plan', {}).get('name', 'Unknown')}")
                lines.append(f"- Nameservers: {', '.join(z.get('name_servers', []))}")
                lines.append("")
            return "\n".join(lines)
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(
        name="cloudflare_list_dns_records",
        annotations={"readOnlyHint": True, "destructiveHint": False, "idempotentHint": True, "openWorldHint": True}
    )
    async def cloudflare_list_dns_records(params: ZoneInput) -> str:
        """List all DNS records for a specific zone. Use cloudflare_list_zones first to get zone_id."""
        try:
            result = await _cf_api(f"/zones/{params.zone_id}/dns_records")
            records = result.get("result", [])
            if params.response_format == ResponseFormat.JSON:
                return json.dumps({"records": records, "count": len(records)}, indent=2)

            lines = ["# DNS Records", "", f"Found {len(records)} record(s)", ""]
            for r in records:
                proxied = "☁️" if r.get("proxied") else "⚡"
                lines.append(f"- {proxied} **{r.get('type')}** `{r.get('name')}` → `{r.get('content')[:50]}` (TTL: {r.get('ttl')})")
            return "\n".join(lines)
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(
        name="cloudflare_list_tunnels",
        annotations={"readOnlyHint": True, "destructiveHint": False, "idempotentHint": True, "openWorldHint": True}
    )
    async def cloudflare_list_tunnels(params: BaseInput) -> str:
        """List all Cloudflare Tunnels in the account with status and connections."""
        try:
            result = await _cf_api(f"/accounts/{CF_ACCOUNT_ID}/cfd_tunnel")
            tunnels = result.get("result", [])
            if params.response_format == ResponseFormat.JSON:
                return json.dumps({"tunnels": tunnels, "count": len(tunnels)}, indent=2)

            lines = ["# Cloudflare Tunnels", "", f"Found {len(tunnels)} tunnel(s)", ""]
            for t in tunnels:
                status = "[OK]" if t.get("status") == "healthy" else "[ERR]"
                conns = len(t.get("connections", []))
                lines.append(f"## {t.get('name')} {status}")
                lines.append(f"- ID: `{t.get('id')}`")
                lines.append(f"- Status: {t.get('status')}")
                lines.append(f"- Connections: {conns}")
                lines.append("")
            return "\n".join(lines)
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(
        name="cloudflare_get_tunnel_status",
        annotations={"readOnlyHint": True, "destructiveHint": False, "idempotentHint": True, "openWorldHint": True}
    )
    async def cloudflare_get_tunnel_status(params: TunnelInput) -> str:
        """Get detailed status of a specific Cloudflare Tunnel including active connections."""
        try:
            result = await _cf_api(f"/accounts/{CF_ACCOUNT_ID}/cfd_tunnel/{params.tunnel_id}")
            tunnel = result.get("result", {})
            return json.dumps(tunnel, indent=2)
        except Exception as e:
            return _handle_error(e)

    # ============================================================================
    # DNS RECORD MANAGEMENT
    # ============================================================================

    class DNSRecordCreateInput(BaseModel):
        model_config = ConfigDict(str_strip_whitespace=True)
        zone_id: str = Field(..., description="Zone ID", min_length=32, max_length=32)
        record_type: str = Field(..., description="Record type: A, AAAA, CNAME, TXT, MX, etc.")
        name: str = Field(..., description="Record name (e.g., 'www' or 'sub.domain.com')")
        content: str = Field(..., description="Record content (IP, target, etc.)")
        ttl: int = Field(default=1, description="TTL in seconds (1 = auto)")
        proxied: bool = Field(default=False, description="Enable Cloudflare proxy (orange cloud)")
        priority: Optional[int] = Field(default=None, description="Priority for MX records")

    class DNSRecordUpdateInput(BaseModel):
        model_config = ConfigDict(str_strip_whitespace=True)
        zone_id: str = Field(..., description="Zone ID", min_length=32, max_length=32)
        record_id: str = Field(..., description="Record ID to update")
        record_type: Optional[str] = Field(default=None, description="Record type")
        name: Optional[str] = Field(default=None, description="Record name")
        content: Optional[str] = Field(default=None, description="Record content")
        ttl: Optional[int] = Field(default=None, description="TTL")
        proxied: Optional[bool] = Field(default=None, description="Proxy status")

    class DNSRecordDeleteInput(BaseModel):
        model_config = ConfigDict(str_strip_whitespace=True)
        zone_id: str = Field(..., description="Zone ID", min_length=32, max_length=32)
        record_id: str = Field(..., description="Record ID to delete")
        confirmation: bool = Field(default=False, description="Must be true to delete")

    class DNSRecordSearchInput(BaseModel):
        model_config = ConfigDict(str_strip_whitespace=True)
        zone_id: str = Field(..., description="Zone ID", min_length=32, max_length=32)
        name: Optional[str] = Field(default=None, description="Filter by name")
        record_type: Optional[str] = Field(default=None, description="Filter by type")
        response_format: ResponseFormat = Field(default=ResponseFormat.MARKDOWN)

    @mcp.tool(
        name="cloudflare_search_dns_records",
        annotations={"readOnlyHint": True, "destructiveHint": False, "idempotentHint": True, "openWorldHint": True}
    )
    async def cloudflare_search_dns_records(params: DNSRecordSearchInput) -> str:
        """Search DNS records by name or type."""
        try:
            endpoint = f"/zones/{params.zone_id}/dns_records"
            query_params = []
            if params.name:
                query_params.append(f"name={params.name}")
            if params.record_type:
                query_params.append(f"type={params.record_type}")
            if query_params:
                endpoint += "?" + "&".join(query_params)

            result = await _cf_api(endpoint)
            records = result.get("result", [])

            if params.response_format == ResponseFormat.JSON:
                return json.dumps({"records": records, "count": len(records)}, indent=2)

            if not records:
                return "No matching DNS records found."

            lines = [f"# DNS Records ({len(records)} found)", ""]
            for r in records:
                proxied = "☁️" if r.get("proxied") else "⚡"
                lines.append(f"- {proxied} **{r.get('type')}** `{r.get('name')}` → `{r.get('content')[:50]}`")
                lines.append(f"  - ID: `{r.get('id')}`")
            return "\n".join(lines)
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(
        name="cloudflare_add_dns_record",
        annotations={"readOnlyHint": False, "destructiveHint": False, "idempotentHint": False, "openWorldHint": True}
    )
    async def cloudflare_add_dns_record(params: DNSRecordCreateInput) -> str:
        """Create a new DNS record."""
        try:
            data = {
                "type": params.record_type.upper(),
                "name": params.name,
                "content": params.content,
                "ttl": params.ttl,
                "proxied": params.proxied
            }
            if params.priority is not None:
                data["priority"] = params.priority

            result = await _cf_api(f"/zones/{params.zone_id}/dns_records", "POST", data)
            record = result.get("result", {})

            return (f"# DNS Record Created\n\n"
                    f"- Type: {record.get('type')}\n"
                    f"- Name: {record.get('name')}\n"
                    f"- Content: {record.get('content')}\n"
                    f"- Proxied: {record.get('proxied')}\n"
                    f"- ID: `{record.get('id')}`\n\n"
                    f"Record is now active.")
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(
        name="cloudflare_update_dns_record",
        annotations={"readOnlyHint": False, "destructiveHint": False, "idempotentHint": False, "openWorldHint": True}
    )
    async def cloudflare_update_dns_record(params: DNSRecordUpdateInput) -> str:
        """Update an existing DNS record."""
        try:
            # Get current record first
            current = await _cf_api(f"/zones/{params.zone_id}/dns_records/{params.record_id}")
            record = current.get("result", {})

            # Build update payload with current values as defaults
            data = {
                "type": params.record_type or record.get("type"),
                "name": params.name or record.get("name"),
                "content": params.content or record.get("content"),
                "ttl": params.ttl if params.ttl is not None else record.get("ttl", 1),
                "proxied": params.proxied if params.proxied is not None else record.get("proxied", False)
            }

            result = await _cf_api(f"/zones/{params.zone_id}/dns_records/{params.record_id}", "PUT", data)
            updated = result.get("result", {})

            return (f"# DNS Record Updated\n\n"
                    f"- Type: {updated.get('type')}\n"
                    f"- Name: {updated.get('name')}\n"
                    f"- Content: {updated.get('content')}\n"
                    f"- Proxied: {updated.get('proxied')}\n"
                    f"- ID: `{updated.get('id')}`")
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(
        name="cloudflare_delete_dns_record",
        annotations={"readOnlyHint": False, "destructiveHint": True, "idempotentHint": False, "openWorldHint": True}
    )
    async def cloudflare_delete_dns_record(params: DNSRecordDeleteInput) -> str:
        """Delete a DNS record. DESTRUCTIVE - requires confirmation=true."""
        if not params.confirmation:
            try:
                # Get record info for preview
                current = await _cf_api(f"/zones/{params.zone_id}/dns_records/{params.record_id}")
                record = current.get("result", {})
                return (f"# WARNING: DNS Record Deletion\n\n"
                        f"**This is a DESTRUCTIVE operation. Set confirmation=true to proceed.**\n\n"
                        f"## Target Record\n"
                        f"- Type: {record.get('type')}\n"
                        f"- Name: {record.get('name')}\n"
                        f"- Content: {record.get('content')}\n"
                        f"- ID: `{params.record_id}`\n\n"
                        f"To delete this record, call again with `confirmation=true`")
            except Exception as e:
                return _handle_error(e)

        try:
            await _cf_api(f"/zones/{params.zone_id}/dns_records/{params.record_id}", "DELETE")
            return f"# DNS Record Deleted\n\n- ID: `{params.record_id}`\n\nThe record has been removed."
        except Exception as e:
            return _handle_error(e)

    # ============================================================================
    # CACHE MANAGEMENT
    # ============================================================================

    class PurgeCacheInput(BaseModel):
        model_config = ConfigDict(str_strip_whitespace=True)
        zone_id: str = Field(..., description="Zone ID", min_length=32, max_length=32)
        purge_everything: bool = Field(default=False, description="Purge all cached content")
        files: Optional[List[str]] = Field(default=None, description="List of URLs to purge")
        tags: Optional[List[str]] = Field(default=None, description="Cache tags to purge")
        confirmation: bool = Field(default=False, description="Must be true to purge")

    @mcp.tool(
        name="cloudflare_purge_cache",
        annotations={"readOnlyHint": False, "destructiveHint": True, "idempotentHint": False, "openWorldHint": True}
    )
    async def cloudflare_purge_cache(params: PurgeCacheInput) -> str:
        """Purge Cloudflare cache. Requires confirmation=true."""
        if not params.confirmation:
            action = "EVERYTHING" if params.purge_everything else f"{len(params.files or [])} files"
            return (f"# WARNING: Cache Purge\n\n"
                    f"**Set confirmation=true to proceed.**\n\n"
                    f"## Purge Target\n"
                    f"- Zone: {params.zone_id}\n"
                    f"- Scope: {action}\n\n"
                    f"To purge, call again with `confirmation=true`")

        try:
            data = {}
            if params.purge_everything:
                data["purge_everything"] = True
            elif params.files:
                data["files"] = params.files
            elif params.tags:
                data["tags"] = params.tags
            else:
                return "Error: Specify purge_everything, files, or tags"

            await _cf_api(f"/zones/{params.zone_id}/purge_cache", "POST", data)
            return "# Cache Purged\n\nCache has been purged. Changes may take a few seconds to propagate."
        except Exception as e:
            return _handle_error(e)

    # ============================================================================
    # ZONE SETTINGS
    # ============================================================================

    class ZoneSettingInput(BaseModel):
        model_config = ConfigDict(str_strip_whitespace=True)
        zone_id: str = Field(..., description="Zone ID", min_length=32, max_length=32)

    @mcp.tool(
        name="cloudflare_get_zone_settings",
        annotations={"readOnlyHint": True, "destructiveHint": False, "idempotentHint": True, "openWorldHint": True}
    )
    async def cloudflare_get_zone_settings(params: ZoneSettingInput) -> str:
        """Get zone security and performance settings."""
        try:
            result = await _cf_api(f"/zones/{params.zone_id}/settings")
            settings = result.get("result", [])

            # Extract key settings
            key_settings = {}
            for s in settings:
                if s.get("id") in ["ssl", "always_use_https", "min_tls_version", "security_level", "waf", "development_mode"]:
                    key_settings[s.get("id")] = s.get("value")

            lines = ["# Zone Settings", ""]
            lines.append(f"- SSL Mode: {key_settings.get('ssl', 'N/A')}")
            lines.append(f"- Always HTTPS: {key_settings.get('always_use_https', 'N/A')}")
            lines.append(f"- Min TLS: {key_settings.get('min_tls_version', 'N/A')}")
            lines.append(f"- Security Level: {key_settings.get('security_level', 'N/A')}")
            lines.append(f"- Dev Mode: {key_settings.get('development_mode', 'N/A')}")

            return "\n".join(lines)
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(
        name="cloudflare_get_analytics",
        annotations={"readOnlyHint": True, "destructiveHint": False, "idempotentHint": True, "openWorldHint": True}
    )
    async def cloudflare_get_analytics(params: ZoneSettingInput) -> str:
        """Get zone analytics summary (requests, bandwidth, threats)."""
        try:
            # Get analytics for last 24 hours
            result = await _cf_api(f"/zones/{params.zone_id}/analytics/dashboard?since=-1440")
            data = result.get("result", {})
            totals = data.get("totals", {})
            requests = totals.get("requests", {})
            bandwidth = totals.get("bandwidth", {})
            threats = totals.get("threats", {})

            lines = ["# Zone Analytics (24h)", ""]
            lines.append("## Requests")
            lines.append(f"- Total: {requests.get('all', 0):,}")
            lines.append(f"- Cached: {requests.get('cached', 0):,}")
            lines.append(f"- Uncached: {requests.get('uncached', 0):,}")
            lines.append("")
            lines.append("## Bandwidth")
            lines.append(f"- Total: {bandwidth.get('all', 0) / (1024**3):.2f} GB")
            lines.append(f"- Cached: {bandwidth.get('cached', 0) / (1024**3):.2f} GB")
            lines.append("")
            lines.append("## Threats")
            lines.append(f"- Total Blocked: {threats.get('all', 0):,}")

            return "\n".join(lines)
        except Exception as e:
            return _handle_error(e)

    # ============================================================================
    # REST API
    # ============================================================================

    from starlette.applications import Starlette
    from starlette.routing import Route, Mount
    from starlette.responses import JSONResponse

    async def rest_health(request):
        """Health check endpoint."""
        return JSONResponse({"status": "healthy"})

    if __name__ == "__main__":
        import uvicorn
        rest_routes = [Route("/health", rest_health, methods=["GET"])]
        mcp_app = mcp.http_app()
        app = Starlette(
            routes=rest_routes + [Mount("/", app=mcp_app)],
            lifespan=mcp_app.lifespan
        )
        uvicorn.run(app, host="0.0.0.0", port=8000)
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: cloudflare-mcp
  namespace: ai-platform
spec:
  replicas: 1
  selector:
    matchLabels:
      app: cloudflare-mcp
  template:
    metadata:
      labels:
        app: cloudflare-mcp
    spec:
      containers:
        - name: cloudflare-mcp
          image: python:3.11-slim
          command: ["sh", "-c"]
          args:
            - pip install --no-cache-dir fastmcp httpx uvicorn starlette && python /app/main.py
          ports:
            - containerPort: 8000
          env:
            - name: CLOUDFLARE_API_TOKEN
              valueFrom:
                secretKeyRef:
                  name: mcp-cloudflare
                  key: API_TOKEN
            - name: CLOUDFLARE_ACCOUNT_ID
              valueFrom:
                secretKeyRef:
                  name: mcp-cloudflare
                  key: ACCOUNT_ID
          volumeMounts:
            - name: code
              mountPath: /app
          resources:
            requests: {memory: "128Mi", cpu: "100m"}
            limits: {memory: "256Mi", cpu: "500m"}
      volumes:
        - name: code
          configMap:
            name: cloudflare-mcp-code
---
apiVersion: v1
kind: Service
metadata:
  name: cloudflare-mcp
  namespace: ai-platform
spec:
  type: NodePort
  selector:
    app: cloudflare-mcp
  ports:
    - port: 8000
      targetPort: 8000
      nodePort: 31087
