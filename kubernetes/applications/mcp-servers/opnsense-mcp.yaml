---
apiVersion: v1
kind: ConfigMap
metadata:
  name: opnsense-mcp-code
  namespace: ai-platform
data:
  main.py: |
    #!/usr/bin/env python3
    """OPNsense MCP server for firewall management."""
    import os
    import json
    import logging
    from typing import Optional, List, Dict, Any
    from enum import Enum
    from fastmcp import FastMCP
    from pydantic import BaseModel, Field, ConfigDict
    import httpx

    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger(__name__)

    OPNSENSE_HOST = os.environ.get("OPNSENSE_HOST", "https://10.10.0.1")
    OPNSENSE_KEY = os.environ.get("OPNSENSE_KEY", "")
    OPNSENSE_SECRET = os.environ.get("OPNSENSE_SECRET", "")

    mcp = FastMCP(
        name="opnsense_mcp",
        instructions="MCP server for OPNsense firewall. Provides tools for interface stats, firewall rules, DHCP leases, and gateway status."
    )

    class ResponseFormat(str, Enum):
        MARKDOWN = "markdown"
        JSON = "json"

    class BaseInput(BaseModel):
        model_config = ConfigDict(str_strip_whitespace=True)
        response_format: ResponseFormat = Field(default=ResponseFormat.MARKDOWN, description="Output format")

    class DHCPSearchInput(BaseModel):
        model_config = ConfigDict(str_strip_whitespace=True)
        response_format: ResponseFormat = Field(default=ResponseFormat.MARKDOWN, description="Output format")
        search: Optional[str] = Field(default=None, description="Filter leases by hostname or IP")

    import ssl

    def _get_ssl_context():
        """Create SSL context that works with OPNsense self-signed certs."""
        ctx = ssl.create_default_context()
        ctx.check_hostname = False
        ctx.verify_mode = ssl.CERT_NONE
        ctx.set_ciphers('DEFAULT@SECLEVEL=1')
        return ctx

    async def _opnsense_api(endpoint: str, method: str = "GET", data: dict = None) -> Dict[str, Any]:
        async with httpx.AsyncClient(verify=_get_ssl_context(), timeout=30.0) as client:
            if method == "GET":
                response = await client.get(f"{OPNSENSE_HOST}/api{endpoint}", auth=(OPNSENSE_KEY, OPNSENSE_SECRET))
            else:
                response = await client.post(f"{OPNSENSE_HOST}/api{endpoint}", auth=(OPNSENSE_KEY, OPNSENSE_SECRET), json=data)
            response.raise_for_status()
            return response.json()

    def _handle_error(e: Exception) -> str:
        if isinstance(e, httpx.HTTPStatusError):
            status = e.response.status_code
            if status == 401:
                return "Error: Authentication failed. Check OPNSENSE_KEY and OPNSENSE_SECRET."
            elif status == 403:
                return "Error: Permission denied. API key lacks required privileges."
            return f"Error: OPNsense API returned status {status}."
        elif isinstance(e, httpx.TimeoutException):
            return "Error: Request timed out. Check connectivity to OPNsense."
        return f"Error: {type(e).__name__}: {str(e)}"

    @mcp.tool(
        name="opnsense_get_interfaces",
        annotations={"readOnlyHint": True, "destructiveHint": False, "idempotentHint": True, "openWorldHint": True}
    )
    async def opnsense_get_interfaces(params: BaseInput) -> str:
        """Get network interface statistics including traffic, packets, and errors."""
        try:
            data = await _opnsense_api("/diagnostics/interface/getInterfaceStatistics")
            if params.response_format == ResponseFormat.JSON:
                return json.dumps(data, indent=2)

            lines = ["# OPNsense Interfaces", ""]
            for iface, stats in data.items():
                if isinstance(stats, dict):
                    lines.append(f"## {iface}")
                    lines.append(f"- **Status**: {'ðŸŸ¢ Up' if stats.get('status') == 'up' else 'ðŸ”´ Down'}")
                    lines.append(f"- **IPv4**: {stats.get('ipv4', 'N/A')}")
                    lines.append(f"- **In**: {stats.get('bytes received', 0):,} bytes")
                    lines.append(f"- **Out**: {stats.get('bytes transmitted', 0):,} bytes")
                    lines.append("")
            return "\n".join(lines)
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(
        name="opnsense_get_firewall_rules",
        annotations={"readOnlyHint": True, "destructiveHint": False, "idempotentHint": True, "openWorldHint": True}
    )
    async def opnsense_get_firewall_rules(params: BaseInput) -> str:
        """List all firewall filter rules with action, interface, source, and destination."""
        try:
            data = await _opnsense_api("/firewall/filter/searchRule")
            rules = data.get("rows", [])
            if params.response_format == ResponseFormat.JSON:
                return json.dumps({"rules": rules, "count": len(rules)}, indent=2)

            lines = ["# Firewall Rules", "", f"Found {len(rules)} rule(s)", ""]
            for r in rules[:20]:  # Limit output
                action = "âœ… Pass" if r.get("action") == "pass" else "ðŸš« Block"
                lines.append(f"- {action} | {r.get('interface', 'any')} | {r.get('source_net', 'any')} â†’ {r.get('destination_net', 'any')} ({r.get('description', 'No desc')})")
            if len(rules) > 20:
                lines.append(f"\n... and {len(rules) - 20} more rules")
            return "\n".join(lines)
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(
        name="opnsense_get_dhcp_leases",
        annotations={"readOnlyHint": True, "destructiveHint": False, "idempotentHint": True, "openWorldHint": True}
    )
    async def opnsense_get_dhcp_leases(params: DHCPSearchInput) -> str:
        """List active DHCP leases with hostname, IP, MAC, and lease time."""
        try:
            data = await _opnsense_api("/dhcpv4/leases/searchLease")
            leases = data.get("rows", [])
            if params.search:
                leases = [l for l in leases if params.search.lower() in str(l).lower()]

            if params.response_format == ResponseFormat.JSON:
                return json.dumps({"leases": leases, "count": len(leases)}, indent=2)

            lines = ["# DHCP Leases", "", f"Found {len(leases)} lease(s)", ""]
            for l in leases:
                lines.append(f"- **{l.get('hostname', 'unknown')}**: {l.get('address')} ({l.get('mac')}) - {l.get('status', 'active')}")
            return "\n".join(lines) if leases else "No DHCP leases found."
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(
        name="opnsense_get_gateway_status",
        annotations={"readOnlyHint": True, "destructiveHint": False, "idempotentHint": True, "openWorldHint": True}
    )
    async def opnsense_get_gateway_status(params: BaseInput) -> str:
        """Get status of all configured gateways including latency and packet loss."""
        try:
            data = await _opnsense_api("/routes/gateway/status")
            if params.response_format == ResponseFormat.JSON:
                return json.dumps(data, indent=2)

            lines = ["# Gateway Status", ""]
            items = data.get("items", data) if isinstance(data, dict) else []
            for gw in (items if isinstance(items, list) else [items]):
                if isinstance(gw, dict):
                    status = "ðŸŸ¢" if gw.get("status_translated", "").lower() == "online" else "ðŸ”´"
                    lines.append(f"## {gw.get('name', 'Unknown')} {status}")
                    lines.append(f"- **Gateway**: {gw.get('gateway', 'N/A')}")
                    lines.append(f"- **RTT**: {gw.get('delay', 'N/A')}")
                    lines.append(f"- **Loss**: {gw.get('loss', 'N/A')}")
                    lines.append("")
            return "\n".join(lines) if lines else json.dumps(data, indent=2)
        except Exception as e:
            return _handle_error(e)

    # ============================================================================
    # Caddy Reverse Proxy Management
    # ============================================================================

    @mcp.tool(
        name="caddy_list_reverse_proxies",
        annotations={"readOnlyHint": True, "destructiveHint": False, "idempotentHint": True, "openWorldHint": True}
    )
    async def caddy_list_reverse_proxies(params: BaseInput) -> str:
        """List all Caddy reverse proxy configurations."""
        try:
            data = await _opnsense_api("/caddy/reverse_proxy/search_reverse_proxy")
            rows = data.get("rows", [])
            if params.response_format == ResponseFormat.JSON:
                return json.dumps({"proxies": rows, "count": len(rows)}, indent=2)

            lines = ["# Caddy Reverse Proxies", "", f"Found {len(rows)} proxy(s)", ""]
            for r in rows:
                enabled = "âœ…" if r.get("enabled") == "1" else "âš«"
                from_domain = r.get("FromDomain", "")
                to_addr = r.get("ToDomain", "") + ":" + r.get("ToPort", "")
                desc = r.get("description", "")
                lines.append(f"- {enabled} `{from_domain}` â†’ `{to_addr}` ({desc})")
            return "\n".join(lines)
        except Exception as e:
            return _handle_error(e)

    class CaddyProxyInput(BaseModel):
        model_config = ConfigDict(str_strip_whitespace=True)
        from_domain: str = Field(description="Source domain (e.g., qdrant.kernow.io)")
        to_addr: str = Field(description="Target address (e.g., 10.20.0.40)")
        to_port: str = Field(description="Target port (e.g., 30633)")
        description: str = Field(default="", description="Optional description")

    @mcp.tool(
        name="caddy_add_reverse_proxy",
        annotations={"readOnlyHint": False, "destructiveHint": False, "idempotentHint": False, "openWorldHint": True}
    )
    async def caddy_add_reverse_proxy(params: CaddyProxyInput) -> str:
        """Add a new Caddy reverse proxy configuration with Let's Encrypt TLS."""
        try:
            # Add the reverse proxy entry (domain config)
            add_data = {
                "reverse": {
                    "enabled": "1",
                    "FromDomain": params.from_domain,
                    "FromPort": "",
                    "accesslist": "",
                    "basicauth": "",
                    "description": params.description or f"Auto-added: {params.from_domain}",
                    "DnsChallenge": "1",
                    "DnsChallengeOverrideDomain": "",
                    "CustomCertificate": "",
                    "AccessLog": "0",
                    "DynDns": "0",
                    "AcmePassthrough": "",
                    "DisableTls": "0",
                    "ClientAuthMode": "",
                    "ClientAuthTrustPool": ""
                }
            }
            result = await _opnsense_api("/caddy/reverse_proxy/add_reverse_proxy", method="POST", data=add_data)
            uuid = result.get("uuid", "")
            if not uuid:
                return f"Error: Failed to add reverse proxy - {result}"

            # Add a handle (upstream target)
            handle_data = {
                "handle": {
                    "enabled": "1",
                    "reverse": uuid,
                    "subdomain": "",
                    "HandleType": "handle",
                    "HandlePath": "",
                    "accesslist": "",
                    "basicauth": "",
                    "header": "",
                    "HandleDirective": "reverse_proxy",
                    "ToDomain": params.to_addr,
                    "ToPort": params.to_port,
                    "ToPath": "",
                    "ForwardAuth": "0",
                    "HttpTls": "0",
                    "HttpVersion": "",
                    "HttpKeepalive": "",
                    "HttpNtlm": "0",
                    "HttpTlsInsecureSkipVerify": "0",
                    "HttpTlsTrustedCaCerts": "",
                    "HttpTlsServerName": "",
                    "description": f"{params.from_domain} upstream"
                }
            }
            handle_result = await _opnsense_api("/caddy/reverse_proxy/add_handle", method="POST", data=handle_data)

            # Apply the configuration
            await _opnsense_api("/caddy/service/reconfigure", method="POST")

            return f"âœ… Added Caddy reverse proxy:\n  `{params.from_domain}` â†’ `{params.to_addr}:{params.to_port}`\n  UUID: {uuid}\n  Configuration applied."
        except Exception as e:
            return _handle_error(e)

    class CaddyDeleteInput(BaseModel):
        model_config = ConfigDict(str_strip_whitespace=True)
        uuid: str = Field(description="UUID of the reverse proxy to delete")

    @mcp.tool(
        name="caddy_delete_reverse_proxy",
        annotations={"readOnlyHint": False, "destructiveHint": True, "idempotentHint": False, "openWorldHint": True}
    )
    async def caddy_delete_reverse_proxy(params: CaddyDeleteInput) -> str:
        """Delete a Caddy reverse proxy configuration by UUID."""
        try:
            await _opnsense_api(f"/caddy/reverse_proxy/del_reverse_proxy/{params.uuid}", method="POST")
            await _opnsense_api("/caddy/service/reconfigure", method="POST")
            return f"âœ… Deleted reverse proxy {params.uuid} and applied configuration."
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(
        name="caddy_apply_config",
        annotations={"readOnlyHint": False, "destructiveHint": False, "idempotentHint": True, "openWorldHint": True}
    )
    async def caddy_apply_config(params: BaseInput) -> str:
        """Apply/reload Caddy configuration."""
        try:
            result = await _opnsense_api("/caddy/service/reconfigure", method="POST")
            return f"âœ… Caddy configuration applied: {json.dumps(result)}"
        except Exception as e:
            return _handle_error(e)

    # ============================================================================
    # REST API
    # ============================================================================

    from starlette.applications import Starlette
    from starlette.routing import Route, Mount
    from starlette.responses import JSONResponse

    async def rest_health(request):
        """Health check endpoint."""
        return JSONResponse({"status": "healthy"})

    async def rest_caddy_proxies(request):
        """REST endpoint to list Caddy proxies."""
        try:
            data = await _opnsense_api("/caddy/reverse_proxy/search_reverse_proxy")
            return JSONResponse({"status": "ok", "data": data.get("rows", [])})
        except Exception as e:
            return JSONResponse({"status": "error", "message": str(e)}, status_code=500)

    if __name__ == "__main__":
        import uvicorn
        rest_routes = [
            Route("/health", rest_health, methods=["GET"]),
            Route("/api/caddy/proxies", rest_caddy_proxies, methods=["GET"]),
        ]
        mcp_app = mcp.http_app()
        app = Starlette(routes=rest_routes + [Mount("/mcp", app=mcp_app)])
        uvicorn.run(app, host="0.0.0.0", port=8000)
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: opnsense-mcp
  namespace: ai-platform
spec:
  replicas: 1
  selector:
    matchLabels:
      app: opnsense-mcp
  template:
    metadata:
      labels:
        app: opnsense-mcp
    spec:
      containers:
        - name: opnsense-mcp
          image: python:3.11-slim
          command: ["sh", "-c"]
          args:
            - pip install --no-cache-dir fastmcp httpx uvicorn starlette && python /app/main.py
          ports:
            - containerPort: 8000
          env:
            - name: OPNSENSE_HOST
              value: "https://10.10.0.1:8443"
            - name: OPNSENSE_KEY
              valueFrom:
                secretKeyRef:
                  name: mcp-opnsense
                  key: key
            - name: OPNSENSE_SECRET
              valueFrom:
                secretKeyRef:
                  name: mcp-opnsense
                  key: secret
          volumeMounts:
            - name: code
              mountPath: /app
          resources:
            requests: {memory: "128Mi", cpu: "100m"}
            limits: {memory: "256Mi", cpu: "500m"}
      volumes:
        - name: code
          configMap:
            name: opnsense-mcp-code
---
apiVersion: v1
kind: Service
metadata:
  name: opnsense-mcp
  namespace: ai-platform
spec:
  selector:
    app: opnsense-mcp
  ports:
    - port: 8000
      targetPort: 8000
