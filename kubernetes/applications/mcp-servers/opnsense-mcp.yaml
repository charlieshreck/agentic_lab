---
apiVersion: v1
kind: ConfigMap
metadata:
  name: opnsense-mcp-code
  namespace: ai-platform
data:
  main.py: |
    #!/usr/bin/env python3
    """OPNsense MCP server for firewall management."""
    import os
    import json
    import logging
    from typing import Optional, List, Dict, Any
    from enum import Enum
    from fastmcp import FastMCP
    from pydantic import BaseModel, Field, ConfigDict
    import httpx

    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger(__name__)

    OPNSENSE_HOST = os.environ.get("OPNSENSE_HOST", "https://10.10.0.1")
    OPNSENSE_KEY = os.environ.get("OPNSENSE_KEY", "")
    OPNSENSE_SECRET = os.environ.get("OPNSENSE_SECRET", "")

    mcp = FastMCP(
        name="opnsense_mcp",
        instructions="MCP server for OPNsense firewall. Provides tools for interface stats, firewall rules, DHCP leases, and gateway status."
    )

    class ResponseFormat(str, Enum):
        MARKDOWN = "markdown"
        JSON = "json"

    class BaseInput(BaseModel):
        model_config = ConfigDict(str_strip_whitespace=True)
        response_format: ResponseFormat = Field(default=ResponseFormat.MARKDOWN, description="Output format")

    class DHCPSearchInput(BaseModel):
        model_config = ConfigDict(str_strip_whitespace=True)
        response_format: ResponseFormat = Field(default=ResponseFormat.MARKDOWN, description="Output format")
        search: Optional[str] = Field(default=None, description="Filter leases by hostname or IP")

    async def _opnsense_api(endpoint: str, method: str = "GET", data: dict = None) -> Dict[str, Any]:
        async with httpx.AsyncClient(verify=False, timeout=30.0) as client:
            if method == "GET":
                response = await client.get(f"{OPNSENSE_HOST}/api{endpoint}", auth=(OPNSENSE_KEY, OPNSENSE_SECRET))
            else:
                response = await client.post(f"{OPNSENSE_HOST}/api{endpoint}", auth=(OPNSENSE_KEY, OPNSENSE_SECRET), json=data)
            response.raise_for_status()
            return response.json()

    def _handle_error(e: Exception) -> str:
        if isinstance(e, httpx.HTTPStatusError):
            status = e.response.status_code
            if status == 401:
                return "Error: Authentication failed. Check OPNSENSE_KEY and OPNSENSE_SECRET."
            elif status == 403:
                return "Error: Permission denied. API key lacks required privileges."
            return f"Error: OPNsense API returned status {status}."
        elif isinstance(e, httpx.TimeoutException):
            return "Error: Request timed out. Check connectivity to OPNsense."
        return f"Error: {type(e).__name__}: {str(e)}"

    @mcp.tool(
        name="opnsense_get_interfaces",
        annotations={"readOnlyHint": True, "destructiveHint": False, "idempotentHint": True, "openWorldHint": True}
    )
    async def opnsense_get_interfaces(params: BaseInput) -> str:
        """Get network interface statistics including traffic, packets, and errors."""
        try:
            data = await _opnsense_api("/diagnostics/interface/getInterfaceStatistics")
            if params.response_format == ResponseFormat.JSON:
                return json.dumps(data, indent=2)

            lines = ["# OPNsense Interfaces", ""]
            for iface, stats in data.items():
                if isinstance(stats, dict):
                    lines.append(f"## {iface}")
                    lines.append(f"- **Status**: {'ðŸŸ¢ Up' if stats.get('status') == 'up' else 'ðŸ”´ Down'}")
                    lines.append(f"- **IPv4**: {stats.get('ipv4', 'N/A')}")
                    lines.append(f"- **In**: {stats.get('bytes received', 0):,} bytes")
                    lines.append(f"- **Out**: {stats.get('bytes transmitted', 0):,} bytes")
                    lines.append("")
            return "\n".join(lines)
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(
        name="opnsense_get_firewall_rules",
        annotations={"readOnlyHint": True, "destructiveHint": False, "idempotentHint": True, "openWorldHint": True}
    )
    async def opnsense_get_firewall_rules(params: BaseInput) -> str:
        """List all firewall filter rules with action, interface, source, and destination."""
        try:
            data = await _opnsense_api("/firewall/filter/searchRule")
            rules = data.get("rows", [])
            if params.response_format == ResponseFormat.JSON:
                return json.dumps({"rules": rules, "count": len(rules)}, indent=2)

            lines = ["# Firewall Rules", "", f"Found {len(rules)} rule(s)", ""]
            for r in rules[:20]:  # Limit output
                action = "âœ… Pass" if r.get("action") == "pass" else "ðŸš« Block"
                lines.append(f"- {action} | {r.get('interface', 'any')} | {r.get('source_net', 'any')} â†’ {r.get('destination_net', 'any')} ({r.get('description', 'No desc')})")
            if len(rules) > 20:
                lines.append(f"\n... and {len(rules) - 20} more rules")
            return "\n".join(lines)
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(
        name="opnsense_get_dhcp_leases",
        annotations={"readOnlyHint": True, "destructiveHint": False, "idempotentHint": True, "openWorldHint": True}
    )
    async def opnsense_get_dhcp_leases(params: DHCPSearchInput) -> str:
        """List active DHCP leases with hostname, IP, MAC, and lease time."""
        try:
            data = await _opnsense_api("/dhcpv4/leases/searchLease")
            leases = data.get("rows", [])
            if params.search:
                leases = [l for l in leases if params.search.lower() in str(l).lower()]

            if params.response_format == ResponseFormat.JSON:
                return json.dumps({"leases": leases, "count": len(leases)}, indent=2)

            lines = ["# DHCP Leases", "", f"Found {len(leases)} lease(s)", ""]
            for l in leases:
                lines.append(f"- **{l.get('hostname', 'unknown')}**: {l.get('address')} ({l.get('mac')}) - {l.get('status', 'active')}")
            return "\n".join(lines) if leases else "No DHCP leases found."
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(
        name="opnsense_get_gateway_status",
        annotations={"readOnlyHint": True, "destructiveHint": False, "idempotentHint": True, "openWorldHint": True}
    )
    async def opnsense_get_gateway_status(params: BaseInput) -> str:
        """Get status of all configured gateways including latency and packet loss."""
        try:
            data = await _opnsense_api("/routes/gateway/status")
            if params.response_format == ResponseFormat.JSON:
                return json.dumps(data, indent=2)

            lines = ["# Gateway Status", ""]
            items = data.get("items", data) if isinstance(data, dict) else []
            for gw in (items if isinstance(items, list) else [items]):
                if isinstance(gw, dict):
                    status = "ðŸŸ¢" if gw.get("status_translated", "").lower() == "online" else "ðŸ”´"
                    lines.append(f"## {gw.get('name', 'Unknown')} {status}")
                    lines.append(f"- **Gateway**: {gw.get('gateway', 'N/A')}")
                    lines.append(f"- **RTT**: {gw.get('delay', 'N/A')}")
                    lines.append(f"- **Loss**: {gw.get('loss', 'N/A')}")
                    lines.append("")
            return "\n".join(lines) if lines else json.dumps(data, indent=2)
        except Exception as e:
            return _handle_error(e)

    # ============================================================================
    # REST API
    # ============================================================================

    from starlette.applications import Starlette
    from starlette.routing import Route, Mount
    from starlette.responses import JSONResponse

    async def rest_health(request):
        """Health check endpoint."""
        return JSONResponse({"status": "healthy"})

    if __name__ == "__main__":
        import uvicorn
        rest_routes = [Route("/health", rest_health, methods=["GET"])]
        mcp_app = mcp.http_app()
        app = Starlette(routes=rest_routes + [Mount("/mcp", app=mcp_app)])
        uvicorn.run(app, host="0.0.0.0", port=8000)
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: opnsense-mcp
  namespace: ai-platform
spec:
  replicas: 1
  selector:
    matchLabels:
      app: opnsense-mcp
  template:
    metadata:
      labels:
        app: opnsense-mcp
    spec:
      containers:
        - name: opnsense-mcp
          image: python:3.11-slim
          command: ["sh", "-c"]
          args:
            - pip install --no-cache-dir fastmcp httpx uvicorn starlette && python /app/main.py
          ports:
            - containerPort: 8000
          env:
            - name: OPNSENSE_HOST
              value: "https://10.10.0.1"
            - name: OPNSENSE_KEY
              valueFrom:
                secretKeyRef:
                  name: mcp-opnsense
                  key: key
            - name: OPNSENSE_SECRET
              valueFrom:
                secretKeyRef:
                  name: mcp-opnsense
                  key: secret
          volumeMounts:
            - name: code
              mountPath: /app
          resources:
            requests: {memory: "128Mi", cpu: "100m"}
            limits: {memory: "256Mi", cpu: "500m"}
      volumes:
        - name: code
          configMap:
            name: opnsense-mcp-code
---
apiVersion: v1
kind: Service
metadata:
  name: opnsense-mcp
  namespace: ai-platform
spec:
  selector:
    app: opnsense-mcp
  ports:
    - port: 8000
      targetPort: 8000
