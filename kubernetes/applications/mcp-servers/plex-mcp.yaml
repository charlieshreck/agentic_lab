---
apiVersion: v1
kind: ConfigMap
metadata:
  name: plex-mcp-code
  namespace: ai-platform
  labels:
    app: plex-mcp
data:
  main.py: |
    #!/usr/bin/env python3
    """Plex Media Server MCP for library management, session monitoring, and GPU transcoding."""
    import os
    import json
    import logging
    import httpx
    import subprocess
    from typing import Optional, Any
    from fastmcp import FastMCP
    from starlette.applications import Starlette
    from starlette.routing import Route, Mount
    from starlette.responses import JSONResponse
    from starlette.requests import Request
    import uvicorn

    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger(__name__)

    PLEX_URL = os.environ.get("PLEX_URL", "http://10.10.0.50:32400")
    PLEX_TOKEN = os.environ.get("PLEX_TOKEN", "")
    PLEX_HOST = os.environ.get("PLEX_HOST", "10.10.0.50")

    mcp = FastMCP(
        name="plex-mcp",
        instructions="""Plex Media Server management MCP.
        Capabilities: server status, library management, active sessions,
        transcode monitoring, GPU utilization, and library refresh.
        Use get_server_status first to verify connectivity."""
    )

    # ============================================================================
    # HELPERS
    # ============================================================================

    async def plex_request(endpoint: str, method: str = "GET") -> Any:
        """Make request to Plex API."""
        if not PLEX_TOKEN:
            return {"error": "PLEX_TOKEN not configured"}
        try:
            headers = {
                "X-Plex-Token": PLEX_TOKEN,
                "Accept": "application/json"
            }
            async with httpx.AsyncClient(timeout=30.0) as client:
                if method == "GET":
                    response = await client.get(f"{PLEX_URL}{endpoint}", headers=headers)
                else:
                    response = await client.request(method, f"{PLEX_URL}{endpoint}", headers=headers)
                response.raise_for_status()
                return response.json() if response.content else {}
        except httpx.HTTPStatusError as e:
            logger.error(f"Plex request failed: {e}")
            return {"error": f"HTTP {e.response.status_code}"}
        except Exception as e:
            logger.error(f"Plex request error: {e}")
            return {"error": str(e)}

    # ============================================================================
    # READ-ONLY TOOLS
    # ============================================================================

    @mcp.tool()
    async def get_server_status() -> dict:
        """Get Plex server identity, version, and claim status."""
        try:
            data = await plex_request("/identity")
            if "error" in data:
                return data
            mc = data.get("MediaContainer", data)
            return {
                "version": mc.get("version", "Unknown"),
                "machine_id": mc.get("machineIdentifier", "Unknown")[:16] + "...",
                "claimed": mc.get("claimed", False),
                "platform": mc.get("platform", "Unknown")
            }
        except Exception as e:
            return {"error": str(e)}

    @mcp.tool()
    async def list_libraries() -> list:
        """List all Plex libraries with item counts."""
        try:
            data = await plex_request("/library/sections")
            if "error" in data:
                return [data]
            dirs = data.get("MediaContainer", {}).get("Directory", [])
            return [{
                "key": d.get("key"),
                "title": d.get("title"),
                "type": d.get("type"),
                "agent": d.get("agent"),
                "scanner": d.get("scanner")
            } for d in dirs]
        except Exception as e:
            return [{"error": str(e)}]

    @mcp.tool()
    async def get_library_details(library_key: str) -> dict:
        """Get detailed info for a specific library including item counts."""
        try:
            data = await plex_request(f"/library/sections/{library_key}/all")
            if "error" in data:
                return data
            mc = data.get("MediaContainer", {})
            return {
                "title": mc.get("title1", "Unknown"),
                "total_items": mc.get("size", 0),
                "view_group": mc.get("viewGroup"),
                "library_section_id": library_key
            }
        except Exception as e:
            return {"error": str(e)}

    @mcp.tool()
    async def get_active_sessions() -> list:
        """Get currently active playback sessions."""
        try:
            data = await plex_request("/status/sessions")
            if "error" in data:
                return [data]
            mc = data.get("MediaContainer", {})
            size = mc.get("size", 0)
            if size == 0:
                return []
            sessions = mc.get("Metadata", [])
            return [{
                "title": s.get("title", "Unknown"),
                "user": s.get("User", {}).get("title", "Unknown"),
                "player": s.get("Player", {}).get("product", "Unknown"),
                "state": s.get("Player", {}).get("state", "Unknown"),
                "progress_percent": round(s.get("viewOffset", 0) / max(s.get("duration", 1), 1) * 100, 1),
                "transcode": "Session" in s.get("TranscodeSession", {}) if isinstance(s.get("TranscodeSession"), dict) else False
            } for s in sessions]
        except Exception as e:
            return [{"error": str(e)}]

    @mcp.tool()
    async def get_transcode_sessions() -> list:
        """Get active transcode sessions with codec info."""
        try:
            data = await plex_request("/transcode/sessions")
            if "error" in data:
                return [data]
            mc = data.get("MediaContainer", {})
            sessions = mc.get("TranscodeSession", [])
            if not sessions:
                return []
            return [{
                "video_codec_in": s.get("videoCodec"),
                "video_codec_out": s.get("transcodeVideoCodec"),
                "hw_requested": s.get("transcodeHwRequested", False),
                "hw_full_pipeline": s.get("transcodeHwFullPipeline", False),
                "progress": round(s.get("progress", 0), 1),
                "speed": round(s.get("speed", 0), 2),
                "throttled": s.get("throttled", False)
            } for s in sessions]
        except Exception as e:
            return [{"error": str(e)}]

    @mcp.tool()
    async def get_recently_added(limit: int = 10) -> list:
        """Get recently added content."""
        try:
            data = await plex_request(f"/library/recentlyAdded")
            if "error" in data:
                return [data]
            items = data.get("MediaContainer", {}).get("Metadata", [])[:limit]
            return [{
                "title": i.get("title"),
                "year": i.get("year", "N/A"),
                "type": i.get("type"),
                "added_at": i.get("addedAt")
            } for i in items]
        except Exception as e:
            return [{"error": str(e)}]

    @mcp.tool()
    async def search_library(query: str) -> list:
        """Search across all Plex libraries."""
        try:
            import urllib.parse
            encoded_query = urllib.parse.quote(query)
            data = await plex_request(f"/search?query={encoded_query}")
            if "error" in data:
                return [data]
            items = data.get("MediaContainer", {}).get("Metadata", [])[:15]
            return [{
                "title": i.get("title"),
                "year": i.get("year", "N/A"),
                "type": i.get("type"),
                "library": i.get("librarySectionTitle")
            } for i in items]
        except Exception as e:
            return [{"error": str(e)}]

    @mcp.tool()
    async def get_on_deck() -> list:
        """Get on-deck items (continue watching)."""
        try:
            data = await plex_request("/library/onDeck")
            if "error" in data:
                return [data]
            items = data.get("MediaContainer", {}).get("Metadata", [])[:10]
            return [{
                "title": i.get("title"),
                "grandparent_title": i.get("grandparentTitle"),
                "progress_percent": round(i.get("viewOffset", 0) / max(i.get("duration", 1), 1) * 100, 1),
                "type": i.get("type")
            } for i in items]
        except Exception as e:
            return [{"error": str(e)}]

    # ============================================================================
    # GPU MONITORING (via SSH)
    # ============================================================================

    @mcp.tool()
    async def get_gpu_status() -> dict:
        """Get GPU status from Plex VM via nvidia-smi."""
        try:
            result = subprocess.run(
                ["ssh", "-o", "StrictHostKeyChecking=no", "-o", "ConnectTimeout=5",
                 f"root@{PLEX_HOST}", "nvidia-smi", "--query-gpu=name,driver_version,memory.used,memory.total,temperature.gpu,utilization.gpu,utilization.encoder,utilization.decoder", "--format=csv,noheader,nounits"],
                capture_output=True, text=True, timeout=10
            )
            if result.returncode == 0:
                parts = [p.strip() for p in result.stdout.strip().split(",")]
                if len(parts) >= 8:
                    return {
                        "gpu_name": parts[0],
                        "driver_version": parts[1],
                        "memory_used_mb": int(parts[2]),
                        "memory_total_mb": int(parts[3]),
                        "temperature_c": int(parts[4]),
                        "gpu_utilization_percent": int(parts[5]),
                        "encoder_utilization_percent": int(parts[6]),
                        "decoder_utilization_percent": int(parts[7])
                    }
            return {"error": f"nvidia-smi failed: {result.stderr}"}
        except subprocess.TimeoutExpired:
            return {"error": "SSH timeout connecting to Plex VM"}
        except Exception as e:
            return {"error": str(e)}

    @mcp.tool()
    async def get_gpu_processes() -> list:
        """Get GPU processes (what's using the GPU)."""
        try:
            result = subprocess.run(
                ["ssh", "-o", "StrictHostKeyChecking=no", "-o", "ConnectTimeout=5",
                 f"root@{PLEX_HOST}", "nvidia-smi", "--query-compute-apps=pid,name,used_memory", "--format=csv,noheader,nounits"],
                capture_output=True, text=True, timeout=10
            )
            if result.returncode == 0:
                lines = result.stdout.strip().split("\n")
                processes = []
                for line in lines:
                    if line.strip():
                        parts = [p.strip() for p in line.split(",")]
                        if len(parts) >= 3:
                            processes.append({
                                "pid": parts[0],
                                "name": parts[1],
                                "memory_mb": int(parts[2])
                            })
                return processes if processes else [{"info": "No GPU processes running"}]
            return [{"error": f"nvidia-smi failed: {result.stderr}"}]
        except subprocess.TimeoutExpired:
            return [{"error": "SSH timeout"}]
        except Exception as e:
            return [{"error": str(e)}]

    # ============================================================================
    # ACTION TOOLS
    # ============================================================================

    @mcp.tool()
    async def refresh_library(library_key: Optional[str] = None) -> dict:
        """Trigger library scan. Provide library_key or scans all."""
        try:
            if library_key:
                await plex_request(f"/library/sections/{library_key}/refresh", method="GET")
                return {"success": True, "message": f"Triggered refresh for library {library_key}"}
            else:
                data = await plex_request("/library/sections")
                if "error" in data:
                    return data
                dirs = data.get("MediaContainer", {}).get("Directory", [])
                for d in dirs:
                    await plex_request(f"/library/sections/{d.get('key')}/refresh", method="GET")
                return {"success": True, "message": f"Triggered refresh for all {len(dirs)} libraries"}
        except Exception as e:
            return {"error": str(e)}

    @mcp.tool()
    async def empty_trash(library_key: Optional[str] = None) -> dict:
        """Empty trash for a library or all libraries."""
        try:
            if library_key:
                await plex_request(f"/library/sections/{library_key}/emptyTrash", method="PUT")
                return {"success": True, "message": f"Emptied trash for library {library_key}"}
            else:
                data = await plex_request("/library/sections")
                if "error" in data:
                    return data
                dirs = data.get("MediaContainer", {}).get("Directory", [])
                for d in dirs:
                    await plex_request(f"/library/sections/{d.get('key')}/emptyTrash", method="PUT")
                return {"success": True, "message": f"Emptied trash for all {len(dirs)} libraries"}
        except Exception as e:
            return {"error": str(e)}

    # ============================================================================
    # REST API (for K8s probes and LangGraph context)
    # ============================================================================

    async def rest_health(request: Request):
        """Health check with Plex connectivity status."""
        try:
            data = await plex_request("/identity")
            plex_ok = "error" not in data
        except:
            plex_ok = False
        return JSONResponse({
            "status": "healthy" if plex_ok else "degraded",
            "plex": "connected" if plex_ok else "unreachable"
        })

    async def rest_api_status(request: Request):
        """Get server status for LangGraph context."""
        try:
            status = await get_server_status()
            return JSONResponse({"status": "ok", "data": status})
        except Exception as e:
            logger.error(f"REST api_status error: {e}")
            return JSONResponse({"status": "error", "error": str(e)}, status_code=500)

    async def rest_api_sessions(request: Request):
        """Get active sessions for LangGraph context."""
        try:
            sessions = await get_active_sessions()
            return JSONResponse({"status": "ok", "data": sessions, "count": len(sessions)})
        except Exception as e:
            return JSONResponse({"status": "error", "error": str(e)}, status_code=500)

    async def rest_api_gpu(request: Request):
        """Get GPU status for LangGraph context."""
        try:
            gpu = await get_gpu_status()
            return JSONResponse({"status": "ok", "data": gpu})
        except Exception as e:
            return JSONResponse({"status": "error", "error": str(e)}, status_code=500)

    # ============================================================================
    # MAIN
    # ============================================================================

    def main():
        port = int(os.environ.get("PORT", "8000"))
        logger.info(f"Starting plex-mcp on port {port}")
        logger.info(f"Plex URL: {PLEX_URL}")

        rest_routes = [
            Route("/health", rest_health, methods=["GET"]),
            Route("/api/status", rest_api_status, methods=["GET"]),
            Route("/api/sessions", rest_api_sessions, methods=["GET"]),
            Route("/api/gpu", rest_api_gpu, methods=["GET"]),
        ]

        mcp_app = mcp.http_app()
        # Mount MCP at root so Claude Code can find /sse and /message endpoints
        # Pass lifespan to initialize FastMCP's task group
        app = Starlette(
            routes=rest_routes + [Mount("/", app=mcp_app)],
            lifespan=mcp_app.lifespan
        )
        uvicorn.run(app, host="0.0.0.0", port=port)

    if __name__ == "__main__":
        main()

  requirements.txt: |
    fastmcp>=2.7.0
    pydantic>=2.11.0
    httpx>=0.28.0
    uvicorn>=0.34.0
    starlette>=0.40.0
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: plex-mcp
  namespace: ai-platform
  labels:
    app: plex-mcp
    component: mcp
spec:
  replicas: 1
  selector:
    matchLabels:
      app: plex-mcp
  template:
    metadata:
      labels:
        app: plex-mcp
        component: mcp
    spec:
      initContainers:
        - name: install-deps
          image: python:3.11-slim
          command: ['sh', '-c', 'pip install --target=/app/deps -r /code/requirements.txt']
          volumeMounts:
            - name: code
              mountPath: /code
            - name: deps
              mountPath: /app/deps
      containers:
        - name: mcp-server
          image: python:3.11-slim
          command: ['sh', '-c', 'cd /app && PYTHONPATH=/app/deps python /code/main.py']
          ports:
            - containerPort: 8000
              name: http
          env:
            - name: PORT
              value: "8000"
            - name: PLEX_URL
              value: "http://10.10.0.50:32400"
            - name: PLEX_HOST
              value: "10.10.0.50"
            - name: PLEX_TOKEN
              valueFrom:
                secretKeyRef:
                  name: mcp-plex
                  key: PLEX_TOKEN
          volumeMounts:
            - name: code
              mountPath: /code
            - name: deps
              mountPath: /app/deps
          resources:
            requests:
              memory: "128Mi"
              cpu: "100m"
            limits:
              memory: "256Mi"
              cpu: "500m"
          readinessProbe:
            tcpSocket:
              port: 8000
            initialDelaySeconds: 30
            periodSeconds: 10
            timeoutSeconds: 5
          livenessProbe:
            tcpSocket:
              port: 8000
            initialDelaySeconds: 60
            periodSeconds: 30
            timeoutSeconds: 5
      volumes:
        - name: code
          configMap:
            name: plex-mcp-code
        - name: deps
          emptyDir: {}
---
apiVersion: v1
kind: Service
metadata:
  name: plex-mcp
  namespace: ai-platform
  labels:
    app: plex-mcp
    component: mcp
spec:
  type: NodePort
  selector:
    app: plex-mcp
  ports:
    - port: 8000
      targetPort: 8000
      nodePort: 31096
      name: http
