---
apiVersion: v1
kind: ConfigMap
metadata:
  name: unifi-mcp-code
  namespace: ai-platform
data:
  main.py: |
    #!/usr/bin/env python3
    """UniFi MCP server for network management."""
    import os
    import ssl
    import json
    import logging
    from typing import Optional, List, Dict, Any
    from enum import Enum
    from fastmcp import FastMCP
    from starlette.applications import Starlette
    from starlette.responses import JSONResponse
    from starlette.routing import Route, Mount
    from pydantic import BaseModel, Field, ConfigDict
    import httpx

    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger(__name__)

    UNIFI_HOST = os.environ.get("UNIFI_HOST", "https://10.10.0.154:11443")
    UNIFI_API_KEY = os.environ.get("UNIFI_API_KEY", "")
    UNIFI_SITE = os.environ.get("UNIFI_SITE", "default")

    # Create permissive SSL context for UniFi controller (uses self-signed cert + legacy TLS)
    def _get_ssl_context():
        ctx = ssl.create_default_context()
        ctx.check_hostname = False
        ctx.verify_mode = ssl.CERT_NONE
        # Allow legacy ciphers for older UniFi controllers
        ctx.set_ciphers('DEFAULT:@SECLEVEL=1')
        return ctx

    SSL_CONTEXT = _get_ssl_context()

    mcp = FastMCP(
        name="unifi_mcp",
        instructions="MCP server for UniFi Network. Provides tools for client management, device status, network health, and alarms."
    )

    class ResponseFormat(str, Enum):
        MARKDOWN = "markdown"
        JSON = "json"

    class BaseInput(BaseModel):
        model_config = ConfigDict(str_strip_whitespace=True)
        response_format: ResponseFormat = Field(default=ResponseFormat.MARKDOWN, description="Output format")

    class ClientSearchInput(BaseModel):
        model_config = ConfigDict(str_strip_whitespace=True)
        response_format: ResponseFormat = Field(default=ResponseFormat.MARKDOWN, description="Output format")
        search: Optional[str] = Field(default=None, description="Filter by hostname, IP, or MAC address")

    async def _unifi_api(endpoint: str) -> Any:
        headers = {"X-API-KEY": UNIFI_API_KEY}
        # Use custom SSL context for self-signed certs + legacy TLS on UniFi controller
        async with httpx.AsyncClient(verify=SSL_CONTEXT, timeout=30.0) as client:
            response = await client.get(f"{UNIFI_HOST}/proxy/network/api/s/{UNIFI_SITE}{endpoint}", headers=headers)
            response.raise_for_status()
            return response.json().get("data", [])

    def _handle_error(e: Exception) -> str:
        if isinstance(e, httpx.HTTPStatusError):
            status = e.response.status_code
            if status == 401:
                return "Error: Invalid API key. Check UNIFI_API_KEY."
            elif status == 403:
                return "Error: API key lacks permissions. Ensure it has network read access."
            return f"Error: UniFi API returned status {status}."
        elif isinstance(e, httpx.TimeoutException):
            return "Error: Request timed out. Check connectivity to UniFi controller."
        return f"Error: {type(e).__name__}: {str(e)}"

    def _format_bytes(b: int) -> str:
        for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
            if b < 1024:
                return f"{b:.1f} {unit}"
            b /= 1024
        return f"{b:.1f} PB"

    @mcp.tool(
        name="unifi_list_clients",
        annotations={"readOnlyHint": True, "destructiveHint": False, "idempotentHint": True, "openWorldHint": True}
    )
    async def unifi_list_clients(params: ClientSearchInput) -> str:
        """List all connected clients with IP, MAC, hostname, and traffic stats."""
        try:
            clients = await _unifi_api("/stat/sta")
            if params.search:
                search = params.search.lower()
                clients = [c for c in clients if search in str(c).lower()]

            if params.response_format == ResponseFormat.JSON:
                return json.dumps({"clients": clients, "count": len(clients)}, indent=2)

            lines = ["# Connected Clients", "", f"Found {len(clients)} client(s)", ""]
            for c in sorted(clients, key=lambda x: x.get("hostname", x.get("mac", ""))):
                name = c.get("hostname") or c.get("name") or c.get("mac", "Unknown")
                ip = c.get("ip", "N/A")
                signal = c.get("signal", c.get("rssi"))
                signal_str = f" (Signal: {signal} dBm)" if signal else ""
                tx = _format_bytes(c.get("tx_bytes", 0))
                rx = _format_bytes(c.get("rx_bytes", 0))
                lines.append(f"- **{name}**: {ip}{signal_str} | ‚Üë{tx} ‚Üì{rx}")
            return "\n".join(lines)
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(
        name="unifi_list_devices",
        annotations={"readOnlyHint": True, "destructiveHint": False, "idempotentHint": True, "openWorldHint": True}
    )
    async def unifi_list_devices(params: BaseInput) -> str:
        """List all UniFi network devices (APs, switches, gateways) with status."""
        try:
            devices = await _unifi_api("/stat/device")
            if params.response_format == ResponseFormat.JSON:
                return json.dumps({"devices": devices, "count": len(devices)}, indent=2)

            lines = ["# UniFi Devices", "", f"Found {len(devices)} device(s)", ""]
            for d in devices:
                status = "üü¢" if d.get("state") == 1 else "üî¥"
                name = d.get("name", d.get("mac", "Unknown"))
                model = d.get("model", "Unknown")
                clients = d.get("num_sta", 0)
                uptime = d.get("uptime", 0) // 3600
                lines.append(f"## {name} {status}")
                lines.append(f"- **Model**: {model}")
                lines.append(f"- **IP**: {d.get('ip', 'N/A')}")
                lines.append(f"- **Clients**: {clients}")
                lines.append(f"- **Uptime**: {uptime} hours")
                lines.append("")
            return "\n".join(lines)
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(
        name="unifi_get_health",
        annotations={"readOnlyHint": True, "destructiveHint": False, "idempotentHint": True, "openWorldHint": True}
    )
    async def unifi_get_health(params: BaseInput) -> str:
        """Get network health summary including WAN, LAN, and WLAN status."""
        try:
            health = await _unifi_api("/stat/health")
            if params.response_format == ResponseFormat.JSON:
                return json.dumps({"health": health}, indent=2)

            lines = ["# Network Health", ""]
            for h in health:
                subsystem = h.get("subsystem", "Unknown").upper()
                status = "üü¢" if h.get("status") == "ok" else "üî¥"
                lines.append(f"## {subsystem} {status}")
                if h.get("num_user"):
                    lines.append(f"- **Users**: {h.get('num_user')}")
                if h.get("num_guest"):
                    lines.append(f"- **Guests**: {h.get('num_guest')}")
                if h.get("tx_bytes-r"):
                    lines.append(f"- **TX Rate**: {_format_bytes(h.get('tx_bytes-r', 0))}/s")
                if h.get("rx_bytes-r"):
                    lines.append(f"- **RX Rate**: {_format_bytes(h.get('rx_bytes-r', 0))}/s")
                lines.append("")
            return "\n".join(lines)
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(
        name="unifi_get_alarms",
        annotations={"readOnlyHint": True, "destructiveHint": False, "idempotentHint": True, "openWorldHint": True}
    )
    async def unifi_get_alarms(params: BaseInput) -> str:
        """Get active alarms and alerts from the UniFi controller."""
        try:
            alarms = await _unifi_api("/stat/alarm")
            if params.response_format == ResponseFormat.JSON:
                return json.dumps({"alarms": alarms, "count": len(alarms)}, indent=2)

            if not alarms:
                return "# Alarms\n\n‚úÖ No active alarms."

            lines = ["# Active Alarms", "", f"Found {len(alarms)} alarm(s)", ""]
            for a in alarms[:20]:
                lines.append(f"- ‚ö†Ô∏è **{a.get('key', 'Unknown')}**: {a.get('msg', 'No message')}")
            return "\n".join(lines)
        except Exception as e:
            return _handle_error(e)

    # REST API endpoints for direct HTTP access (used by LangGraph)
    async def api_devices(request):
        """REST endpoint for listing devices."""
        try:
            data = await _unifi_api("/stat/device")
            return JSONResponse({"status": "ok", "data": data})
        except Exception as e:
            logger.error(f"REST api_devices error: {e}")
            return JSONResponse({"status": "error", "error": str(e)}, status_code=500)

    async def api_clients(request):
        """REST endpoint for listing clients."""
        try:
            data = await _unifi_api("/stat/sta")
            return JSONResponse({"status": "ok", "data": data})
        except Exception as e:
            logger.error(f"REST api_clients error: {e}")
            return JSONResponse({"status": "error", "error": str(e)}, status_code=500)

    async def api_health(request):
        """REST endpoint for network health."""
        try:
            data = await _unifi_api("/stat/health")
            return JSONResponse({"status": "ok", "data": data})
        except Exception as e:
            logger.error(f"REST api_health error: {e}")
            return JSONResponse({"status": "error", "error": str(e)}, status_code=500)

    async def api_alarms(request):
        """REST endpoint for alarms."""
        try:
            data = await _unifi_api("/stat/alarm")
            return JSONResponse({"status": "ok", "data": data})
        except Exception as e:
            logger.error(f"REST api_alarms error: {e}")
            return JSONResponse({"status": "error", "error": str(e)}, status_code=500)

    async def api_index(request):
        """REST endpoint listing available APIs."""
        return JSONResponse({
            "status": "ok",
            "endpoints": [
                "/health - Service health check",
                "/api/devices - List all UniFi devices",
                "/api/clients - List connected clients",
                "/api/health - Network health status",
                "/api/alarms - Active alarms",
            ]
        })

    async def rest_health(request):
        """Health check endpoint for K8s probes."""
        return JSONResponse({"status": "healthy"})

    if __name__ == "__main__":
        import uvicorn
        rest_routes = [
            Route("/health", rest_health),
            Route("/api", api_index),
            Route("/api/devices", api_devices),
            Route("/api/clients", api_clients),
            Route("/api/health", api_health),
            Route("/api/alarms", api_alarms),
        ]
        mcp_app = mcp.http_app()
        app = Starlette(routes=rest_routes + [Mount("/mcp", app=mcp_app)])
        uvicorn.run(app, host="0.0.0.0", port=8000)
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: unifi-mcp
  namespace: ai-platform
spec:
  replicas: 1
  selector:
    matchLabels:
      app: unifi-mcp
  template:
    metadata:
      labels:
        app: unifi-mcp
    spec:
      containers:
        - name: unifi-mcp
          image: python:3.11-slim
          command: ["sh", "-c"]
          args:
            - pip install --no-cache-dir fastmcp httpx uvicorn starlette && python /app/main.py
          ports:
            - containerPort: 8000
          env:
            - name: UNIFI_HOST
              value: "https://10.10.0.154:11443"
            - name: UNIFI_API_KEY
              valueFrom:
                secretKeyRef:
                  name: mcp-unifi
                  key: UNIFI_API_KEY
          volumeMounts:
            - name: code
              mountPath: /app
          resources:
            requests: {memory: "128Mi", cpu: "100m"}
            limits: {memory: "256Mi", cpu: "500m"}
      volumes:
        - name: code
          configMap:
            name: unifi-mcp-code
---
apiVersion: v1
kind: Service
metadata:
  name: unifi-mcp
  namespace: ai-platform
spec:
  selector:
    app: unifi-mcp
  ports:
    - port: 8000
      targetPort: 8000
