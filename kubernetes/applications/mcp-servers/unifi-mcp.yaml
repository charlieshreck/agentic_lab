---
apiVersion: v1
kind: ConfigMap
metadata:
  name: unifi-mcp-code
  namespace: ai-platform
data:
  main.py: |
    #!/usr/bin/env python3
    """
    UniFi MCP Server - Comprehensive Network Management

    Provides tools for:
    - Monitoring: clients, devices, events, health, rogue APs, DPI
    - WLAN Management: create, update, delete SSIDs
    - Device Operations: restart, locate
    - Client Management: block, unblock, name
    - RF Optimization: radio AI, roaming assistant
    """
    import os
    import ssl
    import json
    import logging
    from typing import Optional, List, Dict, Any
    from enum import Enum
    from datetime import datetime
    from fastmcp import FastMCP
    from starlette.applications import Starlette
    from starlette.responses import JSONResponse
    from starlette.routing import Route, Mount
    from pydantic import BaseModel, Field, ConfigDict
    import httpx

    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger(__name__)

    # Configuration
    UNIFI_HOST = os.environ.get("UNIFI_HOST", "https://10.10.0.154:11443")
    UNIFI_API_KEY = os.environ.get("UNIFI_API_KEY", "")
    UNIFI_USER = os.environ.get("UNIFI_USER", "")
    UNIFI_PASSWORD = os.environ.get("UNIFI_PASSWORD", "")
    UNIFI_SITE = os.environ.get("UNIFI_SITE", "default")

    def _get_ssl_context():
        ctx = ssl.create_default_context()
        ctx.check_hostname = False
        ctx.verify_mode = ssl.CERT_NONE
        ctx.set_ciphers('DEFAULT:@SECLEVEL=1')
        return ctx

    SSL_CONTEXT = _get_ssl_context()

    # Session manager for operations requiring CSRF token
    class UniFiSession:
        def __init__(self):
            self.cookies = {}  # Store as dict for cross-client use
            self.csrf_token = None

        async def login(self) -> bool:
            """Login with username/password to get session cookies and CSRF token."""
            if not UNIFI_USER or not UNIFI_PASSWORD:
                logger.warning("UNIFI_USER/PASSWORD not set, session auth unavailable")
                return False
            try:
                async with httpx.AsyncClient(verify=SSL_CONTEXT, timeout=30.0) as client:
                    response = await client.post(
                        f"{UNIFI_HOST}/api/auth/login",
                        json={"username": UNIFI_USER, "password": UNIFI_PASSWORD}
                    )
                    response.raise_for_status()
                    # Convert cookies to dict for use with other clients
                    self.cookies = {k: v for k, v in response.cookies.items()}
                    self.csrf_token = response.headers.get("X-CSRF-Token", "")
                    logger.info(f"UniFi session auth successful, CSRF token: {self.csrf_token[:8]}...")
                    return True
            except Exception as e:
                logger.error(f"Session login failed: {e}")
                return False

        async def ensure_session(self) -> bool:
            """Ensure we have a valid session, login if needed."""
            if not self.cookies:
                return await self.login()
            return True

    session_manager = UniFiSession()

    mcp = FastMCP(
        name="unifi_mcp",
        instructions="""UniFi Network MCP Server for comprehensive network management.

        Available capabilities:
        - Monitor clients, devices, events, alarms, rogue APs
        - Create/update/delete WLANs (SSIDs)
        - Restart and locate devices
        - Block/unblock clients
        - Configure RF optimization settings

        IMPORTANT: Destructive operations (delete, block, restart) require confirmation=true parameter.
        """
    )

    # === Input Models ===

    class ResponseFormat(str, Enum):
        MARKDOWN = "markdown"
        JSON = "json"

    class BaseInput(BaseModel):
        model_config = ConfigDict(str_strip_whitespace=True)
        response_format: ResponseFormat = Field(default=ResponseFormat.MARKDOWN)

    class SearchInput(BaseModel):
        model_config = ConfigDict(str_strip_whitespace=True)
        response_format: ResponseFormat = Field(default=ResponseFormat.MARKDOWN)
        search: Optional[str] = Field(default=None, description="Filter by name, IP, or MAC")

    class EventsInput(BaseModel):
        model_config = ConfigDict(str_strip_whitespace=True)
        response_format: ResponseFormat = Field(default=ResponseFormat.MARKDOWN)
        limit: int = Field(default=20, description="Number of events to return (max 100)")
        event_type: Optional[str] = Field(default=None, description="Filter by event type (e.g., EVT_WU_Roam)")

    class WlanCreateInput(BaseModel):
        model_config = ConfigDict(str_strip_whitespace=True)
        name: str = Field(description="SSID name")
        passphrase: str = Field(description="WiFi password (min 8 chars)")
        band: str = Field(default="both", description="Band: '2g', '5g', '6g', or 'both'")
        enabled: bool = Field(default=True)
        hide_ssid: bool = Field(default=False)
        client_isolation: bool = Field(default=False, description="Prevent clients from seeing each other")
        iot_optimized: bool = Field(default=False, description="Apply IoT-friendly settings (DTIM, UAPSD, etc.)")
        confirmation: bool = Field(default=False, description="Must be true to execute")

    class WlanUpdateInput(BaseModel):
        model_config = ConfigDict(str_strip_whitespace=True)
        wlan_id: str = Field(description="WLAN ID to update")
        name: Optional[str] = Field(default=None)
        passphrase: Optional[str] = Field(default=None)
        enabled: Optional[bool] = Field(default=None)
        band: Optional[str] = Field(default=None)
        client_isolation: Optional[bool] = Field(default=None)
        confirmation: bool = Field(default=False, description="Must be true to execute")

    class WlanDeleteInput(BaseModel):
        model_config = ConfigDict(str_strip_whitespace=True)
        wlan_id: str = Field(description="WLAN ID to delete")
        confirmation: bool = Field(default=False, description="Must be true to execute")

    class DeviceActionInput(BaseModel):
        model_config = ConfigDict(str_strip_whitespace=True)
        mac: str = Field(description="Device MAC address")
        confirmation: bool = Field(default=False, description="Must be true for restart")

    class ClientActionInput(BaseModel):
        model_config = ConfigDict(str_strip_whitespace=True)
        mac: str = Field(description="Client MAC address")
        confirmation: bool = Field(default=False, description="Must be true for block/unblock")

    class ClientNameInput(BaseModel):
        model_config = ConfigDict(str_strip_whitespace=True)
        mac: str = Field(description="Client MAC address")
        name: str = Field(description="Friendly name for client")

    class RFSettingInput(BaseModel):
        model_config = ConfigDict(str_strip_whitespace=True)
        setting: str = Field(description="Setting name: 'radio_ai', 'roaming_assistant', 'band_steering'")
        enabled: bool = Field(description="Enable or disable")
        confirmation: bool = Field(default=False, description="Must be true to execute")

    # === API Helpers ===

    async def _api_get(endpoint: str) -> Any:
        headers = {"X-API-KEY": UNIFI_API_KEY}
        async with httpx.AsyncClient(verify=SSL_CONTEXT, timeout=30.0) as client:
            r = await client.get(f"{UNIFI_HOST}/proxy/network/api/s/{UNIFI_SITE}{endpoint}", headers=headers)
            r.raise_for_status()
            return r.json().get("data", [])

    async def _api_post(endpoint: str, data: dict) -> Any:
        headers = {"X-API-KEY": UNIFI_API_KEY, "Content-Type": "application/json"}
        async with httpx.AsyncClient(verify=SSL_CONTEXT, timeout=30.0) as client:
            r = await client.post(f"{UNIFI_HOST}/proxy/network/api/s/{UNIFI_SITE}{endpoint}", headers=headers, json=data)
            r.raise_for_status()
            return r.json()

    async def _api_put(endpoint: str, data: dict) -> Any:
        headers = {"X-API-KEY": UNIFI_API_KEY, "Content-Type": "application/json"}
        async with httpx.AsyncClient(verify=SSL_CONTEXT, timeout=30.0) as client:
            r = await client.put(f"{UNIFI_HOST}/proxy/network/api/s/{UNIFI_SITE}{endpoint}", headers=headers, json=data)
            r.raise_for_status()
            return r.json()

    async def _api_put_session(endpoint: str, data: dict) -> Any:
        """PUT using session auth with CSRF token (required for site settings)."""
        logger.info(f"_api_put_session called for {endpoint}")
        if not await session_manager.ensure_session():
            raise Exception("Session auth required but UNIFI_USER/PASSWORD not configured")
        logger.info(f"Session ready - cookies: {list(session_manager.cookies.keys())}, csrf: {session_manager.csrf_token[:8] if session_manager.csrf_token else 'NONE'}...")
        headers = {"Content-Type": "application/json"}
        if session_manager.csrf_token:
            headers["X-CSRF-Token"] = session_manager.csrf_token
        url = f"{UNIFI_HOST}/proxy/network/api/s/{UNIFI_SITE}{endpoint}"
        logger.info(f"PUT to {url} with headers: {list(headers.keys())}")
        async with httpx.AsyncClient(verify=SSL_CONTEXT, timeout=30.0) as client:
            r = await client.put(url, headers=headers, cookies=session_manager.cookies, json=data)
            logger.info(f"PUT response: {r.status_code}")
            r.raise_for_status()
            return r.json()

    async def _api_delete(endpoint: str) -> Any:
        headers = {"X-API-KEY": UNIFI_API_KEY}
        async with httpx.AsyncClient(verify=SSL_CONTEXT, timeout=30.0) as client:
            r = await client.delete(f"{UNIFI_HOST}/proxy/network/api/s/{UNIFI_SITE}{endpoint}", headers=headers)
            r.raise_for_status()
            return r.json()

    def _handle_error(e: Exception) -> str:
        if isinstance(e, httpx.HTTPStatusError):
            status = e.response.status_code
            if status == 401: return "Error: Invalid API key"
            if status == 403: return "Error: API key lacks permission for this operation"
            if status == 404: return "Error: Resource not found"
            try:
                detail = e.response.json().get("meta", {}).get("msg", str(e))
            except:
                detail = e.response.text[:200]
            return f"Error {status}: {detail}"
        return f"Error: {type(e).__name__}: {str(e)}"

    def _fmt_bytes(b: int) -> str:
        for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
            if b < 1024: return f"{b:.1f}{unit}"
            b /= 1024
        return f"{b:.1f}PB"

    # === MONITORING TOOLS ===

    @mcp.tool(name="unifi_list_clients", annotations={"readOnlyHint": True})
    async def unifi_list_clients(params: SearchInput) -> str:
        """List connected WiFi clients with signal, traffic, and connection info."""
        try:
            clients = await _api_get("/stat/sta")
            if params.search:
                s = params.search.lower()
                clients = [c for c in clients if s in str(c).lower()]

            if params.response_format == ResponseFormat.JSON:
                return json.dumps({"clients": clients, "count": len(clients)}, indent=2)

            lines = [f"# Connected Clients ({len(clients)})", ""]
            by_band = {"2.4GHz": [], "5GHz": [], "6GHz": []}
            for c in clients:
                ch = c.get("channel", 0)
                if ch <= 14: by_band["2.4GHz"].append(c)
                elif ch < 180: by_band["5GHz"].append(c)
                else: by_band["6GHz"].append(c)

            for band, band_clients in by_band.items():
                if band_clients:
                    lines.append(f"## {band} ({len(band_clients)} clients)")
                    for c in sorted(band_clients, key=lambda x: x.get("signal", 0), reverse=True):
                        name = c.get("hostname") or c.get("name") or c.get("mac", "?")[:17]
                        ip = c.get("ip", "N/A")
                        signal = c.get("signal", "?")
                        ch = c.get("channel", "?")
                        tx, rx = _fmt_bytes(c.get("tx_bytes", 0)), _fmt_bytes(c.get("rx_bytes", 0))
                        lines.append(f"- **{name}** ({ip}) | {signal}dBm ch{ch} | ↑{tx} ↓{rx}")
                    lines.append("")
            return "\n".join(lines)
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(name="unifi_list_devices", annotations={"readOnlyHint": True})
    async def unifi_list_devices(params: BaseInput) -> str:
        """List UniFi network devices (APs, switches, gateways) with status and stats."""
        try:
            devices = await _api_get("/stat/device")
            if params.response_format == ResponseFormat.JSON:
                return json.dumps({"devices": devices, "count": len(devices)}, indent=2)

            lines = [f"# UniFi Devices ({len(devices)})", ""]
            for d in devices:
                status = "[OK]" if d.get("state") == 1 else "[ERR]"
                name = d.get("name", d.get("model", "Unknown"))
                model = d.get("model", "?")
                ip = d.get("ip", "N/A")
                mac = d.get("mac", "?")
                uptime_h = d.get("uptime", 0) // 3600
                num_sta = d.get("num_sta", 0)
                satisfaction = d.get("satisfaction", "N/A")

                lines.append(f"## {name} {status}")
                lines.append(f"- **Model**: {model} | **MAC**: {mac}")
                lines.append(f"- **IP**: {ip} | **Uptime**: {uptime_h}h | **Clients**: {num_sta}")
                lines.append(f"- **Satisfaction**: {satisfaction}%")

                for rs in d.get("radio_table_stats", []):
                    band = {"ng": "2.4GHz", "na": "5GHz", "6e": "6GHz"}.get(rs.get("radio"), "?")
                    ch = rs.get("channel", "?")
                    bw = rs.get("bw", "?")
                    util = rs.get("cu_total", 0)
                    sta = rs.get("num_sta", 0)
                    retries = rs.get("tx_retries_pct", 0)
                    lines.append(f"  - {band}: ch{ch}/{bw}MHz | util:{util}% | clients:{sta} | retries:{retries}%")
                lines.append("")
            return "\n".join(lines)
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(name="unifi_list_events", annotations={"readOnlyHint": True})
    async def unifi_list_events(params: EventsInput) -> str:
        """List recent network events (connections, disconnections, roams, alerts)."""
        try:
            events = await _api_get("/stat/event")
            if params.event_type:
                events = [e for e in events if params.event_type.lower() in e.get("key", "").lower()]
            events = events[:min(params.limit, 100)]

            if params.response_format == ResponseFormat.JSON:
                return json.dumps({"events": events, "count": len(events)}, indent=2)

            lines = [f"# Recent Events ({len(events)})", ""]
            for e in events:
                key = e.get("key", "Unknown")
                msg = e.get("msg", "No message")[:80]
                ts = e.get("datetime", e.get("time", "?"))
                lines.append(f"- **{key}**: {msg}")
            return "\n".join(lines)
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(name="unifi_get_health", annotations={"readOnlyHint": True})
    async def unifi_get_health(params: BaseInput) -> str:
        """Get network health summary for WAN, LAN, WLAN subsystems."""
        try:
            health = await _api_get("/stat/health")
            if params.response_format == ResponseFormat.JSON:
                return json.dumps({"health": health}, indent=2)

            lines = ["# Network Health", ""]
            for h in health:
                sub = h.get("subsystem", "?").upper()
                status = "[OK] OK" if h.get("status") == "ok" else "[ERR] ISSUE"
                lines.append(f"## {sub}: {status}")
                if h.get("num_user"): lines.append(f"  - Users: {h['num_user']}")
                if h.get("num_ap"): lines.append(f"  - APs: {h['num_ap']}")
                if h.get("tx_bytes-r"): lines.append(f"  - TX: {_fmt_bytes(h['tx_bytes-r'])}/s")
                if h.get("rx_bytes-r"): lines.append(f"  - RX: {_fmt_bytes(h['rx_bytes-r'])}/s")
            return "\n".join(lines)
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(name="unifi_get_alarms", annotations={"readOnlyHint": True})
    async def unifi_get_alarms(params: BaseInput) -> str:
        """Get active alarms and alerts."""
        try:
            alarms = await _api_get("/stat/alarm")
            if params.response_format == ResponseFormat.JSON:
                return json.dumps({"alarms": alarms, "count": len(alarms)}, indent=2)

            if not alarms:
                return "# Alarms\n\n No active alarms"

            lines = [f"# Active Alarms ({len(alarms)})", ""]
            for a in alarms[:20]:
                lines.append(f"- [!] **{a.get('key', '?')}**: {a.get('msg', 'No message')}")
            return "\n".join(lines)
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(name="unifi_list_rogueaps", annotations={"readOnlyHint": True})
    async def unifi_list_rogueaps(params: BaseInput) -> str:
        """List detected rogue/neighbor access points for RF analysis."""
        try:
            rogues = await _api_get("/stat/rogueap")
            if params.response_format == ResponseFormat.JSON:
                return json.dumps({"rogueaps": rogues, "count": len(rogues)}, indent=2)

            lines = [f"# Neighbor APs ({len(rogues)})", ""]
            by_channel = {}
            for r in rogues:
                ch = r.get("channel", 0)
                by_channel.setdefault(ch, []).append(r)

            for ch in sorted(by_channel.keys()):
                aps = by_channel[ch]
                lines.append(f"## Channel {ch} ({len(aps)} APs)")
                for r in sorted(aps, key=lambda x: x.get("rssi", 0), reverse=True)[:5]:
                    essid = r.get("essid", "Hidden") or "Hidden"
                    rssi = r.get("rssi", "?")
                    bssid = r.get("bssid", "?")
                    lines.append(f"  - {essid} ({bssid}) rssi:{rssi}")
                lines.append("")
            return "\n".join(lines)
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(name="unifi_get_dpi", annotations={"readOnlyHint": True})
    async def unifi_get_dpi(params: BaseInput) -> str:
        """Get Deep Packet Inspection traffic analysis by category."""
        try:
            dpi = await _api_get("/stat/sitedpi")
            if params.response_format == ResponseFormat.JSON:
                return json.dumps({"dpi": dpi}, indent=2)

            if not dpi:
                return "# DPI Stats\n\nNo DPI data available (may need to enable DPI in settings)"

            # DPI category mapping
            cat_names = {0: "Unknown", 1: "Instant Messaging", 3: "Social Networks",
                         4: "Streaming", 5: "VoIP", 7: "Productivity", 10: "Web",
                         13: "File Sharing", 18: "Gaming", 20: "Network Protocols"}

            lines = ["# DPI Traffic Analysis", ""]
            by_cat = dpi[0].get("by_cat", []) if dpi else []
            by_cat_sorted = sorted(by_cat, key=lambda x: x.get("rx_bytes", 0) + x.get("tx_bytes", 0), reverse=True)

            for cat in by_cat_sorted[:15]:
                cat_id = cat.get("cat", 0)
                cat_name = cat_names.get(cat_id, f"Category {cat_id}")
                rx = cat.get("rx_bytes", 0) / (1024**3)
                tx = cat.get("tx_bytes", 0) / (1024**3)
                lines.append(f"- **{cat_name}**: ↓{rx:.2f}GB ↑{tx:.2f}GB")
            return "\n".join(lines)
        except Exception as e:
            return _handle_error(e)

    # === WLAN MANAGEMENT ===

    @mcp.tool(name="unifi_list_wlans", annotations={"readOnlyHint": True})
    async def unifi_list_wlans(params: BaseInput) -> str:
        """List all configured WLANs (SSIDs) with detailed settings."""
        try:
            wlans = await _api_get("/rest/wlanconf")
            if params.response_format == ResponseFormat.JSON:
                return json.dumps({"wlans": wlans, "count": len(wlans)}, indent=2)

            lines = [f"# WLANs ({len(wlans)})", ""]
            for w in wlans:
                status = "[OK]" if w.get("enabled") else "[ERR]"
                name = w.get("name", "Unknown")
                wlan_id = w.get("_id", "?")
                band = w.get("wlan_band", "both")
                security = w.get("security", "open")
                hidden = "hidden" if w.get("hide_ssid") else "visible"
                isolation = "isolated" if w.get("l2_isolation") else "not isolated"

                lines.append(f"## {name} {status}")
                lines.append(f"- **ID**: `{wlan_id}`")
                lines.append(f"- **Band**: {band} | **Security**: {security}")
                lines.append(f"- **Visibility**: {hidden} | **Client Isolation**: {isolation}")
                lines.append("")
            return "\n".join(lines)
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(name="unifi_create_wlan", annotations={"readOnlyHint": False, "destructiveHint": False})
    async def unifi_create_wlan(params: WlanCreateInput) -> str:
        """Create a new WLAN (SSID). Set confirmation=true to execute."""
        if not params.confirmation:
            config = {
                "name": params.name,
                "band": params.band,
                "enabled": params.enabled,
                "hidden": params.hide_ssid,
                "client_isolation": params.client_isolation,
                "iot_optimized": params.iot_optimized,
            }
            iot_info = ""
            if params.iot_optimized:
                iot_info = "\n### IoT Optimizations Applied:\n- DTIM period: 3 (battery-friendly)\n- UAPSD: enabled (power saving)\n- Fast roaming: disabled\n- BSS transition: disabled\n- Proxy ARP: enabled\n"
            return f"# WLAN Creation Preview\n\n**This is a DRY RUN. Set confirmation=true to create.**\n\n## Proposed Configuration\n- **SSID**: {params.name}\n- **Band**: {params.band}\n- **Enabled**: {params.enabled}\n- **Hidden**: {params.hide_ssid}\n- **Client Isolation**: {params.client_isolation}\n- **IoT Optimized**: {params.iot_optimized}\n{iot_info}\nTo create this WLAN, call again with `confirmation=true`\n"

        try:
            # Get default network ID
            networks = await _api_get("/rest/networkconf")
            network_id = None
            for n in networks:
                if n.get("purpose") == "corporate":
                    network_id = n.get("_id")
                    break

            # Build WLAN config
            wlan_config = {
                "name": params.name,
                "x_passphrase": params.passphrase,
                "security": "wpapsk",
                "wpa_mode": "wpa2",
                "wpa_enc": "ccmp",
                "enabled": params.enabled,
                "hide_ssid": params.hide_ssid,
                "l2_isolation": params.client_isolation,
                "wlan_band": params.band,
                "networkconf_id": network_id,
            }

            # Apply IoT optimizations
            if params.iot_optimized:
                wlan_config.update({
                    "dtim_mode": "custom",
                    "dtim_ng": 3,
                    "dtim_na": 3,
                    "uapsd_enabled": True,
                    "fast_roaming_enabled": False,
                    "bss_transition": False,
                    "proxy_arp": True,
                    "minrate_ng_enabled": False,
                    "minrate_na_enabled": False,
                })

            result = await _api_post("/rest/wlanconf", wlan_config)
            wlan_id = result.get("data", [{}])[0].get("_id", "unknown")

            return f"# WLAN Created Successfully \n\n- **SSID**: {params.name}\n- **ID**: `{wlan_id}`\n- **Band**: {params.band}\n- **Client Isolation**: {params.client_isolation}\n- **IoT Optimized**: {params.iot_optimized}\n\nThe SSID should appear on your APs within 30 seconds.\n"
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(name="unifi_update_wlan", annotations={"readOnlyHint": False, "destructiveHint": False})
    async def unifi_update_wlan(params: WlanUpdateInput) -> str:
        """Update an existing WLAN. Set confirmation=true to execute."""
        if not params.confirmation:
            changes = []
            if params.name: changes.append("name -> " + params.name)
            if params.passphrase: changes.append("passphrase -> (new value)")
            if params.enabled is not None: changes.append("enabled -> " + str(params.enabled))
            if params.band: changes.append("band -> " + params.band)
            if params.client_isolation is not None: changes.append("client_isolation -> " + str(params.client_isolation))

            changes_str = "\n".join("- " + c for c in changes) if changes else "- No changes specified"
            return f"# WLAN Update Preview\n\n**This is a DRY RUN. Set confirmation=true to apply.**\n\n## WLAN ID: `{params.wlan_id}`\n\n## Proposed Changes\n{changes_str}\n\nTo apply these changes, call again with `confirmation=true`\n"

        try:
            # Get current config
            wlans = await _api_get("/rest/wlanconf")
            current = None
            for w in wlans:
                if w.get("_id") == params.wlan_id:
                    current = w
                    break

            if not current:
                return f"Error: WLAN ID `{params.wlan_id}` not found"

            # Build update
            update = {}
            if params.name: update["name"] = params.name
            if params.passphrase: update["x_passphrase"] = params.passphrase
            if params.enabled is not None: update["enabled"] = params.enabled
            if params.band: update["wlan_band"] = params.band
            if params.client_isolation is not None: update["l2_isolation"] = params.client_isolation

            await _api_put(f"/rest/wlanconf/{params.wlan_id}", update)

            return f"# WLAN Updated Successfully \n\n- **WLAN ID**: `{params.wlan_id}`\n- **Changes Applied**: {len(update)}\n\nChanges will propagate to APs within 30 seconds.\n"
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(name="unifi_delete_wlan", annotations={"readOnlyHint": False, "destructiveHint": True})
    async def unifi_delete_wlan(params: WlanDeleteInput) -> str:
        """Delete a WLAN. DESTRUCTIVE - requires confirmation=true."""
        if not params.confirmation:
            try:
                wlans = await _api_get("/rest/wlanconf")
                wlan_name = "Unknown"
                for w in wlans:
                    if w.get("_id") == params.wlan_id:
                        wlan_name = w.get("name", "Unknown")
                        break

                return f"# [!] WLAN Deletion Warning\n\n**This is a DESTRUCTIVE operation. Set confirmation=true to proceed.**\n\n## Target WLAN\n- **Name**: {wlan_name}\n- **ID**: `{params.wlan_id}`\n\nAll clients on this SSID will be disconnected immediately.\n\nTo delete this WLAN, call again with `confirmation=true`\n"
            except Exception as e:
                return _handle_error(e)

        try:
            await _api_delete(f"/rest/wlanconf/{params.wlan_id}")
            return f"# WLAN Deleted \n\n- **WLAN ID**: `{params.wlan_id}`\n\nThe SSID has been removed. Connected clients will be disconnected.\n"
        except Exception as e:
            return _handle_error(e)

    # === DEVICE OPERATIONS ===

    @mcp.tool(name="unifi_restart_device", annotations={"readOnlyHint": False, "destructiveHint": True})
    async def unifi_restart_device(params: DeviceActionInput) -> str:
        """Restart a UniFi device. DESTRUCTIVE - requires confirmation=true."""
        if not params.confirmation:
            try:
                devices = await _api_get("/stat/device")
                device_name = "Unknown"
                for d in devices:
                    if d.get("mac", "").lower() == params.mac.lower():
                        device_name = d.get("name", d.get("model", "Unknown"))
                        break

                return f"# [!] Device Restart Warning\n\n**This will cause a brief network outage. Set confirmation=true to proceed.**\n\n## Target Device\n- **Name**: {device_name}\n- **MAC**: {params.mac}\n\nAll clients connected to this device will be temporarily disconnected.\n\nTo restart, call again with `confirmation=true`\n"
            except Exception as e:
                return _handle_error(e)

        try:
            await _api_post("/cmd/devmgr", {"cmd": "restart", "mac": params.mac.lower()})
            return f"# Device Restart Initiated \n\n- **MAC**: {params.mac}\n\nThe device will restart and reconnect within 2-3 minutes.\n"
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(name="unifi_locate_device", annotations={"readOnlyHint": False, "destructiveHint": False})
    async def unifi_locate_device(params: DeviceActionInput) -> str:
        """Flash the LED on a device to locate it physically."""
        try:
            await _api_post("/cmd/devmgr", {"cmd": "set-locate", "mac": params.mac.lower()})
            return f"# Device Locate Activated \n\n- **MAC**: {params.mac}\n\nThe device LED is now flashing. Call again with cmd='unset-locate' to stop.\n"
        except Exception as e:
            return _handle_error(e)

    # === CLIENT MANAGEMENT ===

    @mcp.tool(name="unifi_block_client", annotations={"readOnlyHint": False, "destructiveHint": True})
    async def unifi_block_client(params: ClientActionInput) -> str:
        """Block a client from connecting. DESTRUCTIVE - requires confirmation=true."""
        if not params.confirmation:
            return f"# [!] Client Block Warning\n\n**This will disconnect and block the client. Set confirmation=true to proceed.**\n\n## Target Client\n- **MAC**: {params.mac}\n\nThe client will be immediately disconnected and unable to reconnect.\n\nTo block, call again with `confirmation=true`\n"

        try:
            await _api_post("/cmd/stamgr", {"cmd": "block-sta", "mac": params.mac.lower()})
            return f"# Client Blocked \n\n- **MAC**: {params.mac}\n\nThe client is now blocked from connecting.\n"
        except httpx.HTTPStatusError as e:
            if e.response.status_code == 404:
                # Try alternative endpoint for newer UniFi
                try:
                    await _api_post("/rest/user", {"mac": params.mac.lower(), "blocked": True})
                    return f"# Client Blocked \n\n- **MAC**: {params.mac}"
                except:
                    pass
            return _handle_error(e)
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(name="unifi_unblock_client", annotations={"readOnlyHint": False, "destructiveHint": False})
    async def unifi_unblock_client(params: ClientActionInput) -> str:
        """Unblock a previously blocked client. Requires confirmation=true."""
        if not params.confirmation:
            return f"# Client Unblock Preview\n\n**Set confirmation=true to proceed.**\n\n## Target Client\n- **MAC**: {params.mac}\n\nTo unblock, call again with `confirmation=true`\n"

        try:
            await _api_post("/cmd/stamgr", {"cmd": "unblock-sta", "mac": params.mac.lower()})
            return f"# Client Unblocked \n\n- **MAC**: {params.mac}\n\nThe client can now reconnect to the network.\n"
        except httpx.HTTPStatusError as e:
            if e.response.status_code == 404:
                try:
                    await _api_post("/rest/user", {"mac": params.mac.lower(), "blocked": False})
                    return f"# Client Unblocked \n\n- **MAC**: {params.mac}"
                except:
                    pass
            return _handle_error(e)
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(name="unifi_name_client", annotations={"readOnlyHint": False, "destructiveHint": False})
    async def unifi_name_client(params: ClientNameInput) -> str:
        """Assign a friendly name to a client for easier identification."""
        try:
            # Check if user exists
            users = await _api_get("/rest/user")
            user_id = None
            for u in users:
                if u.get("mac", "").lower() == params.mac.lower():
                    user_id = u.get("_id")
                    break

            if user_id:
                await _api_put(f"/rest/user/{user_id}", {"name": params.name})
            else:
                await _api_post("/rest/user", {"mac": params.mac.lower(), "name": params.name})

            return f"# Client Named \n\n- **MAC**: {params.mac}\n- **Name**: {params.name}\n\nThe client will now appear with this name in the UniFi dashboard.\n"
        except Exception as e:
            return _handle_error(e)

    # === RF OPTIMIZATION ===

    @mcp.tool(name="unifi_get_rf_settings", annotations={"readOnlyHint": True})
    async def unifi_get_rf_settings(params: BaseInput) -> str:
        """Get current RF optimization settings (Radio AI, Roaming Assistant, etc.)."""
        try:
            settings = await _api_get("/rest/setting")

            rf_settings = {}
            for s in settings:
                key = s.get("key", "")
                if key in ["radio_ai", "roaming_assistant", "network_optimization"]:
                    rf_settings[key] = s

            if params.response_format == ResponseFormat.JSON:
                return json.dumps({"rf_settings": rf_settings}, indent=2)

            lines = ["# RF Optimization Settings", ""]

            # Radio AI
            radio_ai = rf_settings.get("radio_ai", {})
            ai_enabled = radio_ai.get("enabled", False)
            lines.append(f"## Radio AI: {'[OK] Enabled' if ai_enabled else '[ERR] Disabled'}")
            lines.append("Automatically optimizes channel and power settings")
            lines.append("")

            # Roaming Assistant
            roaming = rf_settings.get("roaming_assistant", {})
            roam_enabled = roaming.get("enabled", False)
            roam_threshold = roaming.get("rssi_threshold", -70)
            lines.append(f"## Roaming Assistant: {'[OK] Enabled' if roam_enabled else '[ERR] Disabled'}")
            lines.append(f"RSSI threshold: {roam_threshold} dBm")
            lines.append("Disconnects clients with poor signal to encourage roaming")
            lines.append("")

            # Network Optimization
            net_opt = rf_settings.get("network_optimization", {})
            opt_enabled = net_opt.get("enabled", False)
            lines.append(f"## Network Optimization: {'[OK] Enabled' if opt_enabled else '[ERR] Disabled'}")
            lines.append("")

            return "\n".join(lines)
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(name="unifi_set_rf_setting", annotations={"readOnlyHint": False, "destructiveHint": False})
    async def unifi_set_rf_setting(params: RFSettingInput) -> str:
        """Configure RF optimization settings. Requires confirmation=true."""
        valid_settings = ["radio_ai", "roaming_assistant", "network_optimization"]
        if params.setting not in valid_settings:
            return f"Error: Invalid setting. Choose from: {', '.join(valid_settings)}"

        if not params.confirmation:
            status_str = "enabled" if params.enabled else "disabled"
            return f"# RF Setting Change Preview\n\n**Set confirmation=true to apply.**\n\n## Setting\n- **Name**: {params.setting}\n- **New Value**: {status_str}\n\nTo apply, call again with `confirmation=true`\n"

        try:
            # Get current setting to find its ID and current values
            settings = await _api_get("/rest/setting")
            setting_data = None
            for s in settings:
                if s.get("key") == params.setting:
                    setting_data = s
                    break

            if not setting_data:
                return f"Error: Setting '{params.setting}' not found"

            setting_id = setting_data.get("_id")
            setting_key = setting_data.get("key")

            # Build update payload - merge enabled flag into existing settings
            # Some settings use 'auto_enabled' (radio_ai), others use 'enabled'
            update_payload = {"enabled": params.enabled}
            if setting_key == "radio_ai":
                update_payload["auto_enabled"] = params.enabled

            # UniFi API requires: PUT /rest/setting/{key}/{_id}
            # Site settings require session auth with CSRF token (API key not sufficient)
            await _api_put_session(f"/rest/setting/{setting_key}/{setting_id}", update_payload)

            result_status = "enabled" if params.enabled else "disabled"
            return f"# RF Setting Updated \n\n- **Setting**: {params.setting}\n- **Status**: {result_status}\n\nChanges will take effect within 30 seconds.\n"
        except Exception as e:
            return _handle_error(e)

    # === REST API ENDPOINTS (for direct HTTP access) ===

    async def api_health_check(request):
        return JSONResponse({"status": "healthy", "service": "unifi-mcp"})

    async def api_clients(request):
        try:
            data = await _api_get("/stat/sta")
            return JSONResponse({"status": "ok", "data": data, "count": len(data)})
        except Exception as e:
            return JSONResponse({"status": "error", "error": str(e)}, status_code=500)

    async def api_devices(request):
        try:
            data = await _api_get("/stat/device")
            return JSONResponse({"status": "ok", "data": data, "count": len(data)})
        except Exception as e:
            return JSONResponse({"status": "error", "error": str(e)}, status_code=500)

    async def api_wlans(request):
        try:
            data = await _api_get("/rest/wlanconf")
            return JSONResponse({"status": "ok", "data": data, "count": len(data)})
        except Exception as e:
            return JSONResponse({"status": "error", "error": str(e)}, status_code=500)

    async def api_index(request):
        return JSONResponse({
            "status": "ok",
            "service": "UniFi MCP Server",
            "endpoints": {
                "/health": "Health check",
                "/api/clients": "Connected clients",
                "/api/devices": "Network devices",
                "/api/wlans": "WLAN configurations",
                "/mcp": "MCP protocol endpoint",
            }
        })

    # === MAIN ===

    if __name__ == "__main__":
        import uvicorn

        rest_routes = [
            Route("/health", api_health_check),
            Route("/api", api_index),
            Route("/api/clients", api_clients),
            Route("/api/devices", api_devices),
            Route("/api/wlans", api_wlans),
        ]

        mcp_app = mcp.http_app()
        app = Starlette(
            routes=rest_routes + [Mount("/", app=mcp_app)],
            lifespan=mcp_app.lifespan
        )

        uvicorn.run(app, host="0.0.0.0", port=8000)
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: unifi-mcp
  namespace: ai-platform
spec:
  replicas: 1
  selector:
    matchLabels:
      app: unifi-mcp
  template:
    metadata:
      labels:
        app: unifi-mcp
      annotations:
        configmap-hash: "v2-comprehensive"
    spec:
      containers:
        - name: unifi-mcp
          image: python:3.11-slim
          command: ["sh", "-c"]
          args:
            - pip install --no-cache-dir fastmcp httpx uvicorn starlette && python /app/main.py
          ports:
            - containerPort: 8000
          env:
            - name: UNIFI_HOST
              value: "https://10.10.0.51:11443"
            - name: UNIFI_API_KEY
              valueFrom:
                secretKeyRef:
                  name: mcp-unifi
                  key: UNIFI_API_KEY
            - name: UNIFI_USER
              valueFrom:
                secretKeyRef:
                  name: mcp-unifi
                  key: UNIFI_USER
                  optional: true
            - name: UNIFI_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: mcp-unifi
                  key: UNIFI_PASSWORD
                  optional: true
          volumeMounts:
            - name: code
              mountPath: /app
          resources:
            requests: {memory: "128Mi", cpu: "100m"}
            limits: {memory: "256Mi", cpu: "500m"}
          livenessProbe:
            httpGet:
              path: /health
              port: 8000
            initialDelaySeconds: 60
            periodSeconds: 30
          readinessProbe:
            httpGet:
              path: /health
              port: 8000
            initialDelaySeconds: 30
            periodSeconds: 10
      volumes:
        - name: code
          configMap:
            name: unifi-mcp-code
---
apiVersion: v1
kind: Service
metadata:
  name: unifi-mcp
  namespace: ai-platform
spec:
  type: NodePort
  selector:
    app: unifi-mcp
  ports:
    - port: 8000
      targetPort: 8000
      nodePort: 31088
