---
apiVersion: v1
kind: ConfigMap
metadata:
  name: truenas-mcp-code
  namespace: ai-platform
data:
  main.py: |
    #!/usr/bin/env python3
    """TrueNAS MCP server for storage management across multiple instances."""
    import os
    import json
    import logging
    from typing import Optional, List, Dict, Any
    from enum import Enum
    from fastmcp import FastMCP
    from pydantic import BaseModel, Field, ConfigDict
    import httpx

    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger(__name__)

    INSTANCES = {
        "hdd": {
            "host": os.environ.get("TRUENAS_HDD_HOST", "https://truenas.hdd.kernow.io"),
            "api_key": os.environ.get("TRUENAS_HDD_API_KEY", ""),
            "description": "Bulk storage for backups and archives"
        },
        "media": {
            "host": os.environ.get("TRUENAS_MEDIA_HOST", "https://truenas.kernow.io"),
            "api_key": os.environ.get("TRUENAS_MEDIA_API_KEY", ""),
            "description": "Media files for Plex/arr suite"
        }
    }

    mcp = FastMCP(
        name="truenas_mcp",
        instructions="MCP server for TrueNAS storage. Supports two instances: 'hdd' (bulk storage) and 'media' (media files). List instances first to see available options."
    )

    class ResponseFormat(str, Enum):
        MARKDOWN = "markdown"
        JSON = "json"

    class InstanceInput(BaseModel):
        model_config = ConfigDict(str_strip_whitespace=True)
        instance: str = Field(default="hdd", description="TrueNAS instance: 'hdd' or 'media'")
        response_format: ResponseFormat = Field(default=ResponseFormat.MARKDOWN, description="Output format")

    class DatasetInput(BaseModel):
        model_config = ConfigDict(str_strip_whitespace=True)
        instance: str = Field(default="hdd", description="TrueNAS instance: 'hdd' or 'media'")
        pool: Optional[str] = Field(default=None, description="Filter by pool name")
        response_format: ResponseFormat = Field(default=ResponseFormat.MARKDOWN, description="Output format")

    class SnapshotInput(BaseModel):
        model_config = ConfigDict(str_strip_whitespace=True)
        instance: str = Field(default="hdd", description="TrueNAS instance: 'hdd' or 'media'")
        dataset: Optional[str] = Field(default=None, description="Filter by dataset name")
        response_format: ResponseFormat = Field(default=ResponseFormat.MARKDOWN, description="Output format")

    async def _truenas_api(instance: str, endpoint: str) -> Any:
        if instance not in INSTANCES:
            raise ValueError(f"Unknown instance: {instance}. Use 'hdd' or 'media'")
        config = INSTANCES[instance]
        headers = {"Authorization": f"Bearer {config['api_key']}"}
        async with httpx.AsyncClient(verify=False, timeout=30.0) as client:
            response = await client.get(f"{config['host']}/api/v2.0{endpoint}", headers=headers)
            response.raise_for_status()
            return response.json()

    def _handle_error(e: Exception) -> str:
        if isinstance(e, ValueError):
            return f"Error: {str(e)}"
        if isinstance(e, httpx.HTTPStatusError):
            status = e.response.status_code
            if status == 401:
                return "Error: Invalid API key. Check TRUENAS_*_API_KEY."
            elif status == 403:
                return "Error: API key lacks permissions."
            return f"Error: TrueNAS API returned status {status}."
        elif isinstance(e, httpx.TimeoutException):
            return "Error: Request timed out. Check connectivity to TrueNAS."
        return f"Error: {type(e).__name__}: {str(e)}"

    def _format_bytes(b: int) -> str:
        if b is None:
            return "N/A"
        for unit in ['B', 'KB', 'MB', 'GB', 'TB', 'PB']:
            if b < 1024:
                return f"{b:.1f} {unit}"
            b /= 1024
        return f"{b:.1f} EB"

    @mcp.tool(
        name="truenas_list_instances",
        annotations={"readOnlyHint": True, "destructiveHint": False, "idempotentHint": True, "openWorldHint": True}
    )
    async def truenas_list_instances() -> str:
        """List available TrueNAS instances with their hostnames and purposes."""
        lines = ["# TrueNAS Instances", ""]
        for name, config in INSTANCES.items():
            lines.append(f"- **{name}**: {config['host']} - {config['description']}")
        return "\n".join(lines)

    @mcp.tool(
        name="truenas_list_pools",
        annotations={"readOnlyHint": True, "destructiveHint": False, "idempotentHint": True, "openWorldHint": True}
    )
    async def truenas_list_pools(params: InstanceInput) -> str:
        """List ZFS storage pools with health status and capacity."""
        try:
            pools = await _truenas_api(params.instance, "/pool")
            if params.response_format == ResponseFormat.JSON:
                return json.dumps({"instance": params.instance, "pools": pools}, indent=2)

            lines = [f"# Storage Pools ({params.instance})", ""]
            for p in pools:
                status = "ðŸŸ¢" if p.get("healthy") else "ðŸ”´"
                size = _format_bytes(p.get("size"))
                free = _format_bytes(p.get("free"))
                lines.append(f"## {p.get('name')} {status}")
                lines.append(f"- **Status**: {p.get('status')}")
                lines.append(f"- **Size**: {size}")
                lines.append(f"- **Free**: {free}")
                lines.append("")
            return "\n".join(lines)
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(
        name="truenas_list_datasets",
        annotations={"readOnlyHint": True, "destructiveHint": False, "idempotentHint": True, "openWorldHint": True}
    )
    async def truenas_list_datasets(params: DatasetInput) -> str:
        """List ZFS datasets/filesystems with quotas and usage."""
        try:
            datasets = await _truenas_api(params.instance, "/pool/dataset")
            if params.pool:
                datasets = [d for d in datasets if params.pool in d.get("id", "")]

            if params.response_format == ResponseFormat.JSON:
                return json.dumps({"datasets": datasets, "count": len(datasets)}, indent=2)

            lines = [f"# Datasets ({params.instance})", "", f"Found {len(datasets)} dataset(s)", ""]
            for d in datasets[:30]:
                used = _format_bytes(d.get("used", {}).get("parsed", 0))
                avail = _format_bytes(d.get("available", {}).get("parsed", 0))
                lines.append(f"- **{d.get('id')}**: {used} used / {avail} available")
            if len(datasets) > 30:
                lines.append(f"\n... and {len(datasets) - 30} more")
            return "\n".join(lines)
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(
        name="truenas_list_shares",
        annotations={"readOnlyHint": True, "destructiveHint": False, "idempotentHint": True, "openWorldHint": True}
    )
    async def truenas_list_shares(params: InstanceInput) -> str:
        """List all SMB and NFS shares configured on the instance."""
        try:
            smb = await _truenas_api(params.instance, "/sharing/smb")
            nfs = await _truenas_api(params.instance, "/sharing/nfs")

            if params.response_format == ResponseFormat.JSON:
                return json.dumps({"instance": params.instance, "smb": smb, "nfs": nfs}, indent=2)

            lines = [f"# Shares ({params.instance})", ""]
            if smb:
                lines.append("## SMB Shares")
                for s in smb:
                    enabled = "âœ…" if s.get("enabled") else "âš«"
                    lines.append(f"- {enabled} **{s.get('name')}**: {s.get('path')}")
                lines.append("")
            if nfs:
                lines.append("## NFS Shares")
                for n in nfs:
                    enabled = "âœ…" if n.get("enabled") else "âš«"
                    lines.append(f"- {enabled} {n.get('path')} â†’ {', '.join(n.get('hosts', ['*']))}")
            return "\n".join(lines) if (smb or nfs) else "No shares configured."
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(
        name="truenas_get_alerts",
        annotations={"readOnlyHint": True, "destructiveHint": False, "idempotentHint": True, "openWorldHint": True}
    )
    async def truenas_get_alerts(params: InstanceInput) -> str:
        """Get active alerts from a TrueNAS instance."""
        try:
            alerts = await _truenas_api(params.instance, "/alert/list")
            if params.response_format == ResponseFormat.JSON:
                return json.dumps({"instance": params.instance, "alerts": alerts}, indent=2)

            if not alerts:
                return f"# Alerts ({params.instance})\n\nâœ… No active alerts."

            lines = [f"# Alerts ({params.instance})", "", f"Found {len(alerts)} alert(s)", ""]
            for a in alerts:
                level = {"WARNING": "âš ï¸", "CRITICAL": "ðŸ”´", "INFO": "â„¹ï¸"}.get(a.get("level"), "â“")
                lines.append(f"- {level} **{a.get('klass')}**: {a.get('formatted', a.get('text', 'No message'))}")
            return "\n".join(lines)
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(
        name="truenas_get_all_alerts",
        annotations={"readOnlyHint": True, "destructiveHint": False, "idempotentHint": True, "openWorldHint": True}
    )
    async def truenas_get_all_alerts() -> str:
        """Get alerts from ALL TrueNAS instances at once."""
        lines = ["# All TrueNAS Alerts", ""]
        total = 0
        for name in INSTANCES:
            try:
                alerts = await _truenas_api(name, "/alert/list")
                total += len(alerts)
                lines.append(f"## {name} ({len(alerts)} alerts)")
                if alerts:
                    for a in alerts[:5]:
                        level = {"WARNING": "âš ï¸", "CRITICAL": "ðŸ”´"}.get(a.get("level"), "â„¹ï¸")
                        lines.append(f"- {level} {a.get('klass')}: {a.get('formatted', '')[:80]}")
                else:
                    lines.append("âœ… No alerts")
                lines.append("")
            except Exception as e:
                lines.append(f"## {name}\nðŸ”´ Error: {str(e)}\n")
        return "\n".join(lines) if total else "âœ… No alerts on any TrueNAS instance."

    @mcp.tool(
        name="truenas_list_snapshots",
        annotations={"readOnlyHint": True, "destructiveHint": False, "idempotentHint": True, "openWorldHint": True}
    )
    async def truenas_list_snapshots(params: SnapshotInput) -> str:
        """List ZFS snapshots, optionally filtered by dataset."""
        try:
            snapshots = await _truenas_api(params.instance, "/zfs/snapshot")
            if params.dataset:
                snapshots = [s for s in snapshots if params.dataset in s.get("id", "")]

            if params.response_format == ResponseFormat.JSON:
                return json.dumps({"snapshots": snapshots, "count": len(snapshots)}, indent=2)

            lines = [f"# Snapshots ({params.instance})", "", f"Found {len(snapshots)} snapshot(s)", ""]
            for s in snapshots[:30]:
                lines.append(f"- `{s.get('id')}`")
            if len(snapshots) > 30:
                lines.append(f"\n... and {len(snapshots) - 30} more")
            return "\n".join(lines)
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(
        name="truenas_get_disk_usage",
        annotations={"readOnlyHint": True, "destructiveHint": False, "idempotentHint": True, "openWorldHint": True}
    )
    async def truenas_get_disk_usage(params: InstanceInput) -> str:
        """Get disk usage summary across all pools."""
        try:
            pools = await _truenas_api(params.instance, "/pool")
            if params.response_format == ResponseFormat.JSON:
                return json.dumps({"instance": params.instance, "pools": pools}, indent=2)

            lines = [f"# Disk Usage ({params.instance})", ""]
            for p in pools:
                name = p.get("name")
                size = _format_bytes(p.get("size"))
                alloc = _format_bytes(p.get("allocated"))
                free = _format_bytes(p.get("free"))
                pct = (p.get("allocated", 0) / p.get("size", 1)) * 100 if p.get("size") else 0
                bar = "â–ˆ" * int(pct / 5) + "â–‘" * (20 - int(pct / 5))
                lines.append(f"## {name}")
                lines.append(f"```\n[{bar}] {pct:.1f}%\n```")
                lines.append(f"- **Total**: {size}")
                lines.append(f"- **Used**: {alloc}")
                lines.append(f"- **Free**: {free}")
                lines.append("")
            return "\n".join(lines)
        except Exception as e:
            return _handle_error(e)

    if __name__ == "__main__":
        import uvicorn
        uvicorn.run(mcp.http_app(), host="0.0.0.0", port=8000)
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: truenas-mcp
  namespace: ai-platform
spec:
  replicas: 1
  selector:
    matchLabels:
      app: truenas-mcp
  template:
    metadata:
      labels:
        app: truenas-mcp
    spec:
      containers:
        - name: truenas-mcp
          image: python:3.11-slim
          command: ["sh", "-c"]
          args:
            - pip install --no-cache-dir fastmcp httpx uvicorn && python /app/main.py
          ports:
            - containerPort: 8000
          env:
            - name: TRUENAS_HDD_HOST
              valueFrom:
                secretKeyRef:
                  name: mcp-truenas-hdd
                  key: HOST
            - name: TRUENAS_HDD_API_KEY
              valueFrom:
                secretKeyRef:
                  name: mcp-truenas-hdd
                  key: API_KEY
            - name: TRUENAS_MEDIA_HOST
              valueFrom:
                secretKeyRef:
                  name: mcp-truenas-media
                  key: HOST
            - name: TRUENAS_MEDIA_API_KEY
              valueFrom:
                secretKeyRef:
                  name: mcp-truenas-media
                  key: API_KEY
          volumeMounts:
            - name: code
              mountPath: /app
          resources:
            requests: {memory: "128Mi", cpu: "100m"}
            limits: {memory: "256Mi", cpu: "500m"}
      volumes:
        - name: code
          configMap:
            name: truenas-mcp-code
---
apiVersion: v1
kind: Service
metadata:
  name: truenas-mcp
  namespace: ai-platform
spec:
  selector:
    app: truenas-mcp
  ports:
    - port: 8000
      targetPort: 8000
