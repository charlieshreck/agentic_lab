---
apiVersion: v1
kind: ConfigMap
metadata:
  name: adguard-mcp-code
  namespace: ai-platform
data:
  main.py: |
    #!/usr/bin/env python3
    """AdGuard Home MCP server for DNS management."""
    import os
    import json
    import logging
    from typing import Optional, List, Dict, Any
    from enum import Enum
    from fastmcp import FastMCP
    from pydantic import BaseModel, Field, ConfigDict
    import httpx

    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger(__name__)

    ADGUARD_HOST = os.environ.get("ADGUARD_HOST", "http://10.10.0.1:3000")
    ADGUARD_USER = os.environ.get("ADGUARD_USER", "admin")
    ADGUARD_PASSWORD = os.environ.get("ADGUARD_PASSWORD", "")

    mcp = FastMCP(
        name="adguard_mcp",
        instructions="MCP server for AdGuard Home DNS. Provides tools for DNS statistics, query logs, and filtering status."
    )

    class ResponseFormat(str, Enum):
        MARKDOWN = "markdown"
        JSON = "json"

    class BaseInput(BaseModel):
        model_config = ConfigDict(str_strip_whitespace=True)
        response_format: ResponseFormat = Field(default=ResponseFormat.MARKDOWN, description="Output format")

    class QueryLogInput(BaseModel):
        model_config = ConfigDict(str_strip_whitespace=True)
        response_format: ResponseFormat = Field(default=ResponseFormat.MARKDOWN, description="Output format")
        limit: int = Field(default=50, description="Number of queries to return", ge=1, le=1000)
        search: Optional[str] = Field(default=None, description="Filter by domain or client IP")

    async def _adguard_api(endpoint: str, method: str = "GET", data: dict = None) -> Dict[str, Any]:
        async with httpx.AsyncClient(timeout=30.0) as client:
            url = f"{ADGUARD_HOST}/{endpoint}"
            if method == "GET":
                response = await client.get(url, auth=(ADGUARD_USER, ADGUARD_PASSWORD))
            else:
                response = await client.post(url, auth=(ADGUARD_USER, ADGUARD_PASSWORD), json=data)
            response.raise_for_status()
            return response.json()

    def _handle_error(e: Exception) -> str:
        if isinstance(e, httpx.HTTPStatusError):
            status = e.response.status_code
            if status == 401:
                return "Error: Authentication failed. Check ADGUARD_USER and ADGUARD_PASSWORD."
            elif status == 403:
                return "Error: Access denied. User may lack admin privileges."
            return f"Error: AdGuard API returned status {status}."
        elif isinstance(e, httpx.TimeoutException):
            return "Error: Request timed out. Check connectivity to AdGuard Home."
        return f"Error: {type(e).__name__}: {str(e)}"

    @mcp.tool(
        name="adguard_get_stats",
        annotations={"readOnlyHint": True, "destructiveHint": False, "idempotentHint": True, "openWorldHint": True}
    )
    async def adguard_get_stats(params: BaseInput) -> str:
        """Get DNS statistics including total queries, blocked queries, and top clients."""
        try:
            stats = await _adguard_api("control/stats")
            if params.response_format == ResponseFormat.JSON:
                return json.dumps(stats, indent=2)

            lines = ["# AdGuard DNS Statistics", ""]
            lines.append(f"- **Total Queries**: {stats.get('num_dns_queries', 0):,}")
            lines.append(f"- **Blocked**: {stats.get('num_blocked_filtering', 0):,}")
            lines.append(f"- **Safe Browsing Blocked**: {stats.get('num_replaced_safebrowsing', 0):,}")
            lines.append(f"- **Parental Blocked**: {stats.get('num_replaced_parental', 0):,}")
            lines.append(f"- **Avg Processing Time**: {stats.get('avg_processing_time', 0):.2f}ms")
            lines.append("")

            if stats.get("top_queried_domains"):
                lines.append("## Top Queried Domains")
                for domain in list(stats["top_queried_domains"])[:10]:
                    for name, count in domain.items():
                        lines.append(f"- {name}: {count:,}")
                lines.append("")

            if stats.get("top_blocked_domains"):
                lines.append("## Top Blocked Domains")
                for domain in list(stats["top_blocked_domains"])[:10]:
                    for name, count in domain.items():
                        lines.append(f"- ðŸš« {name}: {count:,}")

            return "\n".join(lines)
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(
        name="adguard_get_query_log",
        annotations={"readOnlyHint": True, "destructiveHint": False, "idempotentHint": True, "openWorldHint": True}
    )
    async def adguard_get_query_log(params: QueryLogInput) -> str:
        """Get recent DNS query log with domain, client, and block status."""
        try:
            result = await _adguard_api(f"control/querylog?limit={params.limit}")
            queries = result.get("data", [])

            if params.search:
                search = params.search.lower()
                queries = [q for q in queries if search in str(q).lower()]

            if params.response_format == ResponseFormat.JSON:
                return json.dumps({"queries": queries, "count": len(queries)}, indent=2)

            lines = ["# DNS Query Log", "", f"Showing {len(queries)} queries", ""]
            for q in queries[:50]:
                question = q.get("question", {})
                domain = question.get("name", "Unknown")
                client = q.get("client", "Unknown")
                reason = q.get("reason", "")
                icon = "ðŸš«" if reason else "âœ…"
                lines.append(f"- {icon} `{domain}` from {client}" + (f" ({reason})" if reason else ""))

            return "\n".join(lines)
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(
        name="adguard_get_filtering_status",
        annotations={"readOnlyHint": True, "destructiveHint": False, "idempotentHint": True, "openWorldHint": True}
    )
    async def adguard_get_filtering_status(params: BaseInput) -> str:
        """Get current filtering configuration including enabled lists and rules count."""
        try:
            status = await _adguard_api("control/filtering/status")
            if params.response_format == ResponseFormat.JSON:
                return json.dumps(status, indent=2)

            enabled = "ðŸŸ¢ Enabled" if status.get("enabled") else "ðŸ”´ Disabled"
            lines = ["# Filtering Status", "", f"**Status**: {enabled}", ""]

            filters = status.get("filters", [])
            if filters:
                lines.append("## Active Filter Lists")
                for f in filters:
                    icon = "âœ…" if f.get("enabled") else "âš«"
                    lines.append(f"- {icon} **{f.get('name')}**: {f.get('rules_count', 0):,} rules")
                lines.append("")

            user_rules = status.get("user_rules", [])
            if user_rules:
                lines.append(f"## Custom Rules: {len(user_rules)} rule(s)")

            return "\n".join(lines)
        except Exception as e:
            return _handle_error(e)

    if __name__ == "__main__":
        import uvicorn
        uvicorn.run(mcp.http_app(), host="0.0.0.0", port=8000)
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: adguard-mcp
  namespace: ai-platform
spec:
  replicas: 1
  selector:
    matchLabels:
      app: adguard-mcp
  template:
    metadata:
      labels:
        app: adguard-mcp
    spec:
      containers:
        - name: adguard-mcp
          image: python:3.11-slim
          command: ["sh", "-c"]
          args:
            - pip install --no-cache-dir fastmcp httpx uvicorn && python /app/main.py
          ports:
            - containerPort: 8000
          env:
            - name: ADGUARD_HOST
              value: "http://10.10.0.1:3000"
            - name: ADGUARD_USER
              valueFrom:
                secretKeyRef:
                  name: mcp-adguard
                  key: username
            - name: ADGUARD_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: mcp-adguard
                  key: password
          volumeMounts:
            - name: code
              mountPath: /app
          resources:
            requests: {memory: "128Mi", cpu: "100m"}
            limits: {memory: "256Mi", cpu: "500m"}
      volumes:
        - name: code
          configMap:
            name: adguard-mcp-code
---
apiVersion: v1
kind: Service
metadata:
  name: adguard-mcp
  namespace: ai-platform
spec:
  selector:
    app: adguard-mcp
  ports:
    - port: 8000
      targetPort: 8000
