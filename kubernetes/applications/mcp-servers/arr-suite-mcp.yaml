apiVersion: v1
kind: ConfigMap
metadata:
  name: arr-suite-mcp-code
  namespace: ai-platform
  labels:
    app: arr-suite-mcp
data:
  main.py: |
    #!/usr/bin/env python3
    """
    Arr Suite MCP - Comprehensive media management for homelab.

    Integrates: Sonarr, Radarr, Prowlarr, Overseerr, Tautulli,
                Transmission, SABnzbd, Notifiarr
    """
    import os
    import logging
    import base64
    from typing import List, Optional, Dict, Any
    from fastmcp import FastMCP
    from pydantic import BaseModel
    from starlette.applications import Starlette
    from starlette.routing import Route, Mount
    from starlette.responses import JSONResponse
    from starlette.requests import Request
    import httpx
    import uvicorn

    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger(__name__)

    # ==========================================================================
    # CONFIGURATION
    # ==========================================================================

    # Sonarr (TV Shows)
    SONARR_URL = os.environ.get("SONARR_URL", "https://sonarr.kernow.io")
    SONARR_API_KEY = os.environ.get("SONARR_API_KEY", "")

    # Radarr (Movies)
    RADARR_URL = os.environ.get("RADARR_URL", "https://radarr.kernow.io")
    RADARR_API_KEY = os.environ.get("RADARR_API_KEY", "")

    # Prowlarr (Indexers)
    PROWLARR_URL = os.environ.get("PROWLARR_URL", "https://prowlarr.kernow.io")
    PROWLARR_API_KEY = os.environ.get("PROWLARR_API_KEY", "")

    # Overseerr (Requests)
    OVERSEERR_URL = os.environ.get("OVERSEERR_URL", "https://overseerr.kernow.io")
    OVERSEERR_API_KEY = os.environ.get("OVERSEERR_API_KEY", "")

    # Tautulli (Plex Stats)
    TAUTULLI_URL = os.environ.get("TAUTULLI_URL", "https://tautulli.kernow.io")
    TAUTULLI_API_KEY = os.environ.get("TAUTULLI_API_KEY", "")

    # Transmission (Torrents)
    TRANSMISSION_URL = os.environ.get("TRANSMISSION_URL", "https://transmission.kernow.io")
    TRANSMISSION_USER = os.environ.get("TRANSMISSION_USER", "")
    TRANSMISSION_PASS = os.environ.get("TRANSMISSION_PASS", "")

    # SABnzbd (Usenet)
    SABNZBD_URL = os.environ.get("SABNZBD_URL", "https://sabnzbd.kernow.io")
    SABNZBD_API_KEY = os.environ.get("SABNZBD_API_KEY", "")

    mcp = FastMCP(
        name="arr-suite-mcp",
        instructions="""
        Comprehensive media management MCP for homelab.

        Services:
        - Sonarr: TV show management (search, add, monitor, queue)
        - Radarr: Movie management (search, add, monitor, queue)
        - Prowlarr: Indexer management (health, search, stats)
        - Overseerr: Request management (list, approve, deny)
        - Tautulli: Plex statistics (activity, history, stats)
        - Transmission: Torrent downloads (list, add, pause, remove)
        - SABnzbd: Usenet downloads (queue, history, pause)
        """
    )

    # ==========================================================================
    # HELPER FUNCTIONS
    # ==========================================================================

    async def arr_request(base_url: str, api_key: str, endpoint: str,
                          method: str = "GET", data: dict = None) -> dict:
        """Make request to *arr API (Sonarr, Radarr, Prowlarr)."""
        async with httpx.AsyncClient(timeout=30.0, verify=False) as client:
            headers = {"X-Api-Key": api_key}
            url = f"{base_url}/api/v3/{endpoint}"
            response = await client.request(method, url, headers=headers, json=data)
            response.raise_for_status()
            return response.json() if response.content else {}

    async def overseerr_request(endpoint: str, method: str = "GET", data: dict = None) -> dict:
        """Make request to Overseerr API."""
        async with httpx.AsyncClient(timeout=30.0, verify=False) as client:
            headers = {"X-Api-Key": OVERSEERR_API_KEY}
            url = f"{OVERSEERR_URL}/api/v1/{endpoint}"
            response = await client.request(method, url, headers=headers, json=data)
            response.raise_for_status()
            return response.json() if response.content else {}

    async def tautulli_request(cmd: str, **params) -> dict:
        """Make request to Tautulli API."""
        async with httpx.AsyncClient(timeout=30.0, verify=False) as client:
            params["apikey"] = TAUTULLI_API_KEY
            params["cmd"] = cmd
            url = f"{TAUTULLI_URL}/api/v2"
            response = await client.get(url, params=params)
            response.raise_for_status()
            return response.json().get("response", {}).get("data", {})

    async def transmission_request(method: str, arguments: dict = None) -> dict:
        """Make request to Transmission RPC."""
        async with httpx.AsyncClient(timeout=30.0, verify=False) as client:
            auth = base64.b64encode(f"{TRANSMISSION_USER}:{TRANSMISSION_PASS}".encode()).decode()
            headers = {"Authorization": f"Basic {auth}"}
            url = f"{TRANSMISSION_URL}/transmission/rpc"

            # Get session ID first
            try:
                resp = await client.post(url, headers=headers, json={"method": "session-get"})
            except:
                pass

            if "X-Transmission-Session-Id" in resp.headers:
                headers["X-Transmission-Session-Id"] = resp.headers["X-Transmission-Session-Id"]

            payload = {"method": method}
            if arguments:
                payload["arguments"] = arguments

            response = await client.post(url, headers=headers, json=payload)
            response.raise_for_status()
            return response.json().get("arguments", {})

    async def sabnzbd_request(mode: str, **params) -> dict:
        """Make request to SABnzbd API."""
        async with httpx.AsyncClient(timeout=30.0, verify=False) as client:
            params["apikey"] = SABNZBD_API_KEY
            params["mode"] = mode
            params["output"] = "json"
            url = f"{SABNZBD_URL}/api"
            response = await client.get(url, params=params)
            response.raise_for_status()
            return response.json()

    # ==========================================================================
    # SONARR TOOLS (TV Shows)
    # ==========================================================================

    @mcp.tool()
    async def sonarr_list_series(monitored_only: bool = True) -> List[dict]:
        """List all TV series in Sonarr."""
        try:
            series = await arr_request(SONARR_URL, SONARR_API_KEY, "series")
            result = []
            for s in series:
                if monitored_only and not s.get("monitored"):
                    continue
                result.append({
                    "id": s["id"],
                    "title": s["title"],
                    "year": s.get("year"),
                    "status": s.get("status"),
                    "monitored": s.get("monitored"),
                    "episodeCount": s.get("statistics", {}).get("episodeCount", 0),
                    "episodeFileCount": s.get("statistics", {}).get("episodeFileCount", 0),
                    "percentComplete": s.get("statistics", {}).get("percentOfEpisodes", 0)
                })
            return result
        except Exception as e:
            return [{"error": str(e)}]

    @mcp.tool()
    async def sonarr_search_series(query: str) -> List[dict]:
        """Search for a TV series to add."""
        try:
            results = await arr_request(SONARR_URL, SONARR_API_KEY, f"series/lookup?term={query}")
            return [{"tvdbId": r.get("tvdbId"), "title": r["title"], "year": r.get("year"),
                     "overview": r.get("overview", "")[:200]} for r in results[:10]]
        except Exception as e:
            return [{"error": str(e)}]

    @mcp.tool()
    async def sonarr_add_series(tvdb_id: int, quality_profile_id: int = 1,
                                 root_folder_path: str = "/tv") -> dict:
        """Add a TV series to Sonarr by TVDB ID."""
        try:
            # Lookup the series first
            lookup = await arr_request(SONARR_URL, SONARR_API_KEY, f"series/lookup?term=tvdb:{tvdb_id}")
            if not lookup:
                return {"error": "Series not found"}

            series = lookup[0]
            series["qualityProfileId"] = quality_profile_id
            series["rootFolderPath"] = root_folder_path
            series["monitored"] = True
            series["addOptions"] = {"searchForMissingEpisodes": True}

            result = await arr_request(SONARR_URL, SONARR_API_KEY, "series", "POST", series)
            return {"success": True, "id": result.get("id"), "title": result.get("title")}
        except Exception as e:
            return {"error": str(e)}

    @mcp.tool()
    async def sonarr_get_queue() -> List[dict]:
        """Get Sonarr download queue."""
        try:
            queue = await arr_request(SONARR_URL, SONARR_API_KEY, "queue?pageSize=50")
            return [{
                "title": item.get("title"),
                "series": item.get("series", {}).get("title"),
                "status": item.get("status"),
                "sizeleft": item.get("sizeleft", 0),
                "timeleft": item.get("timeleft", "unknown"),
                "quality": item.get("quality", {}).get("quality", {}).get("name")
            } for item in queue.get("records", [])]
        except Exception as e:
            return [{"error": str(e)}]

    @mcp.tool()
    async def sonarr_trigger_search(series_id: int) -> dict:
        """Trigger a search for missing episodes of a series."""
        try:
            await arr_request(SONARR_URL, SONARR_API_KEY, "command", "POST",
                            {"name": "SeriesSearch", "seriesId": series_id})
            return {"success": True, "message": f"Search triggered for series {series_id}"}
        except Exception as e:
            return {"error": str(e)}

    # ==========================================================================
    # RADARR TOOLS (Movies)
    # ==========================================================================

    @mcp.tool()
    async def radarr_list_movies(monitored_only: bool = True) -> List[dict]:
        """List all movies in Radarr."""
        try:
            movies = await arr_request(RADARR_URL, RADARR_API_KEY, "movie")
            result = []
            for m in movies:
                if monitored_only and not m.get("monitored"):
                    continue
                result.append({
                    "id": m["id"],
                    "title": m["title"],
                    "year": m.get("year"),
                    "status": "downloaded" if m.get("hasFile") else "missing",
                    "monitored": m.get("monitored"),
                    "quality": m.get("movieFile", {}).get("quality", {}).get("quality", {}).get("name") if m.get("hasFile") else None
                })
            return result
        except Exception as e:
            return [{"error": str(e)}]

    @mcp.tool()
    async def radarr_search_movie(query: str) -> List[dict]:
        """Search for a movie to add."""
        try:
            results = await arr_request(RADARR_URL, RADARR_API_KEY, f"movie/lookup?term={query}")
            return [{"tmdbId": r.get("tmdbId"), "title": r["title"], "year": r.get("year"),
                     "overview": r.get("overview", "")[:200]} for r in results[:10]]
        except Exception as e:
            return [{"error": str(e)}]

    @mcp.tool()
    async def radarr_add_movie(tmdb_id: int, quality_profile_id: int = 1,
                                root_folder_path: str = "/movies") -> dict:
        """Add a movie to Radarr by TMDB ID."""
        try:
            lookup = await arr_request(RADARR_URL, RADARR_API_KEY, f"movie/lookup/tmdb?tmdbId={tmdb_id}")
            if not lookup:
                return {"error": "Movie not found"}

            movie = lookup if isinstance(lookup, dict) else lookup[0]
            movie["qualityProfileId"] = quality_profile_id
            movie["rootFolderPath"] = root_folder_path
            movie["monitored"] = True
            movie["addOptions"] = {"searchForMovie": True}

            result = await arr_request(RADARR_URL, RADARR_API_KEY, "movie", "POST", movie)
            return {"success": True, "id": result.get("id"), "title": result.get("title")}
        except Exception as e:
            return {"error": str(e)}

    @mcp.tool()
    async def radarr_get_queue() -> List[dict]:
        """Get Radarr download queue."""
        try:
            queue = await arr_request(RADARR_URL, RADARR_API_KEY, "queue?pageSize=50")
            return [{
                "title": item.get("title"),
                "movie": item.get("movie", {}).get("title"),
                "status": item.get("status"),
                "sizeleft": item.get("sizeleft", 0),
                "timeleft": item.get("timeleft", "unknown"),
                "quality": item.get("quality", {}).get("quality", {}).get("name")
            } for item in queue.get("records", [])]
        except Exception as e:
            return [{"error": str(e)}]

    @mcp.tool()
    async def radarr_trigger_search(movie_id: int) -> dict:
        """Trigger a search for a movie."""
        try:
            await arr_request(RADARR_URL, RADARR_API_KEY, "command", "POST",
                            {"name": "MoviesSearch", "movieIds": [movie_id]})
            return {"success": True, "message": f"Search triggered for movie {movie_id}"}
        except Exception as e:
            return {"error": str(e)}

    # ==========================================================================
    # PROWLARR TOOLS (Indexers)
    # ==========================================================================

    @mcp.tool()
    async def prowlarr_list_indexers() -> List[dict]:
        """List all configured indexers and their status."""
        try:
            indexers = await arr_request(PROWLARR_URL, PROWLARR_API_KEY, "indexer")
            return [{
                "id": idx["id"],
                "name": idx["name"],
                "protocol": idx.get("protocol"),
                "privacy": idx.get("privacy"),
                "enabled": idx.get("enable", False),
                "priority": idx.get("priority", 25)
            } for idx in indexers]
        except Exception as e:
            return [{"error": str(e)}]

    @mcp.tool()
    async def prowlarr_get_health() -> List[dict]:
        """Get Prowlarr health/status checks."""
        try:
            health = await arr_request(PROWLARR_URL, PROWLARR_API_KEY, "health")
            return [{"source": h.get("source"), "type": h.get("type"),
                     "message": h.get("message")} for h in health]
        except Exception as e:
            return [{"error": str(e)}]

    @mcp.tool()
    async def prowlarr_test_indexer(indexer_id: int) -> dict:
        """Test an indexer connection."""
        try:
            await arr_request(PROWLARR_URL, PROWLARR_API_KEY, f"indexer/{indexer_id}/test", "POST")
            return {"success": True, "message": f"Indexer {indexer_id} test passed"}
        except Exception as e:
            return {"error": str(e)}

    @mcp.tool()
    async def prowlarr_search(query: str, indexer_ids: List[int] = None) -> List[dict]:
        """Search across indexers."""
        try:
            params = f"query={query}"
            if indexer_ids:
                params += "&" + "&".join([f"indexerIds={i}" for i in indexer_ids])
            results = await arr_request(PROWLARR_URL, PROWLARR_API_KEY, f"search?{params}")
            return [{
                "title": r.get("title"),
                "indexer": r.get("indexer"),
                "size": r.get("size"),
                "seeders": r.get("seeders"),
                "age": r.get("age")
            } for r in results[:20]]
        except Exception as e:
            return [{"error": str(e)}]

    # ==========================================================================
    # OVERSEERR TOOLS (Requests)
    # ==========================================================================

    @mcp.tool()
    async def overseerr_list_requests(status: str = "pending") -> List[dict]:
        """List media requests. Status: pending, approved, declined, all."""
        try:
            params = "" if status == "all" else f"filter={status}"
            requests = await overseerr_request(f"request?{params}")
            return [{
                "id": r.get("id"),
                "type": r.get("type"),
                "title": r.get("media", {}).get("title") or r.get("media", {}).get("name"),
                "status": r.get("status"),
                "requestedBy": r.get("requestedBy", {}).get("displayName"),
                "createdAt": r.get("createdAt")
            } for r in requests.get("results", [])]
        except Exception as e:
            return [{"error": str(e)}]

    @mcp.tool()
    async def overseerr_approve_request(request_id: int) -> dict:
        """Approve a media request."""
        try:
            await overseerr_request(f"request/{request_id}/approve", "POST")
            return {"success": True, "message": f"Request {request_id} approved"}
        except Exception as e:
            return {"error": str(e)}

    @mcp.tool()
    async def overseerr_decline_request(request_id: int) -> dict:
        """Decline a media request."""
        try:
            await overseerr_request(f"request/{request_id}/decline", "POST")
            return {"success": True, "message": f"Request {request_id} declined"}
        except Exception as e:
            return {"error": str(e)}

    @mcp.tool()
    async def overseerr_get_trending() -> dict:
        """Get trending movies and TV shows."""
        try:
            movies = await overseerr_request("discover/movies")
            tv = await overseerr_request("discover/tv")
            return {
                "movies": [{"title": m.get("title"), "year": m.get("releaseDate", "")[:4]}
                          for m in movies.get("results", [])[:5]],
                "tv": [{"title": t.get("name"), "year": t.get("firstAirDate", "")[:4]}
                      for t in tv.get("results", [])[:5]]
            }
        except Exception as e:
            return {"error": str(e)}

    # ==========================================================================
    # TAUTULLI TOOLS (Plex Stats)
    # ==========================================================================

    @mcp.tool()
    async def tautulli_get_activity() -> dict:
        """Get current Plex streaming activity."""
        try:
            activity = await tautulli_request("get_activity")
            sessions = []
            for s in activity.get("sessions", []):
                sessions.append({
                    "user": s.get("friendly_name"),
                    "title": s.get("full_title"),
                    "state": s.get("state"),
                    "progress": s.get("progress_percent"),
                    "quality": s.get("quality_profile"),
                    "player": s.get("player")
                })
            return {
                "stream_count": activity.get("stream_count", 0),
                "sessions": sessions
            }
        except Exception as e:
            return {"error": str(e)}

    @mcp.tool()
    async def tautulli_get_history(length: int = 10) -> List[dict]:
        """Get recent watch history."""
        try:
            history = await tautulli_request("get_history", length=length)
            return [{
                "user": h.get("friendly_name"),
                "title": h.get("full_title"),
                "watched_at": h.get("date"),
                "duration": h.get("duration"),
                "percent_complete": h.get("percent_complete")
            } for h in history.get("data", [])]
        except Exception as e:
            return [{"error": str(e)}]

    @mcp.tool()
    async def tautulli_get_most_watched(time_range: int = 30) -> dict:
        """Get most watched content in the last N days."""
        try:
            movies = await tautulli_request("get_home_stats", stat_id="top_movies", time_range=time_range)
            shows = await tautulli_request("get_home_stats", stat_id="top_tv", time_range=time_range)
            return {
                "movies": [{"title": m.get("title"), "plays": m.get("total_plays")}
                          for m in movies.get("rows", [])[:5]],
                "shows": [{"title": s.get("title"), "plays": s.get("total_plays")}
                         for s in shows.get("rows", [])[:5]]
            }
        except Exception as e:
            return {"error": str(e)}

    @mcp.tool()
    async def tautulli_get_library_stats() -> dict:
        """Get library statistics."""
        try:
            stats = await tautulli_request("get_libraries")
            return [{
                "name": lib.get("section_name"),
                "type": lib.get("section_type"),
                "count": lib.get("count"),
                "parent_count": lib.get("parent_count"),
                "child_count": lib.get("child_count")
            } for lib in stats]
        except Exception as e:
            return {"error": str(e)}

    # ==========================================================================
    # TRANSMISSION TOOLS (Torrents)
    # ==========================================================================

    @mcp.tool()
    async def transmission_list_torrents() -> List[dict]:
        """List all torrents."""
        try:
            result = await transmission_request("torrent-get", {
                "fields": ["id", "name", "status", "percentDone", "rateDownload",
                          "rateUpload", "eta", "sizeWhenDone"]
            })
            status_map = {0: "stopped", 1: "queued", 2: "verifying", 3: "queued",
                         4: "downloading", 5: "queued", 6: "seeding"}
            return [{
                "id": t["id"],
                "name": t["name"],
                "status": status_map.get(t["status"], "unknown"),
                "progress": round(t["percentDone"] * 100, 1),
                "downloadSpeed": t.get("rateDownload", 0),
                "uploadSpeed": t.get("rateUpload", 0),
                "eta": t.get("eta", -1),
                "size": t.get("sizeWhenDone", 0)
            } for t in result.get("torrents", [])]
        except Exception as e:
            return [{"error": str(e)}]

    @mcp.tool()
    async def transmission_add_torrent(torrent_url: str, paused: bool = False) -> dict:
        """Add a torrent by URL or magnet link."""
        try:
            result = await transmission_request("torrent-add", {
                "filename": torrent_url,
                "paused": paused
            })
            added = result.get("torrent-added", result.get("torrent-duplicate", {}))
            return {"success": True, "id": added.get("id"), "name": added.get("name")}
        except Exception as e:
            return {"error": str(e)}

    @mcp.tool()
    async def transmission_pause_torrent(torrent_id: int) -> dict:
        """Pause a torrent."""
        try:
            await transmission_request("torrent-stop", {"ids": [torrent_id]})
            return {"success": True, "message": f"Torrent {torrent_id} paused"}
        except Exception as e:
            return {"error": str(e)}

    @mcp.tool()
    async def transmission_resume_torrent(torrent_id: int) -> dict:
        """Resume a torrent."""
        try:
            await transmission_request("torrent-start", {"ids": [torrent_id]})
            return {"success": True, "message": f"Torrent {torrent_id} resumed"}
        except Exception as e:
            return {"error": str(e)}

    @mcp.tool()
    async def transmission_remove_torrent(torrent_id: int, delete_data: bool = False) -> dict:
        """Remove a torrent. Set delete_data=True to also delete downloaded files."""
        try:
            await transmission_request("torrent-remove", {
                "ids": [torrent_id],
                "delete-local-data": delete_data
            })
            return {"success": True, "message": f"Torrent {torrent_id} removed"}
        except Exception as e:
            return {"error": str(e)}

    # ==========================================================================
    # SABNZBD TOOLS (Usenet)
    # ==========================================================================

    @mcp.tool()
    async def sabnzbd_get_queue() -> dict:
        """Get SABnzbd download queue."""
        try:
            result = await sabnzbd_request("queue")
            queue = result.get("queue", {})
            return {
                "status": queue.get("status"),
                "speed": queue.get("speed"),
                "timeleft": queue.get("timeleft"),
                "mb_left": queue.get("mbleft"),
                "slots": [{
                    "filename": s.get("filename"),
                    "status": s.get("status"),
                    "percentage": s.get("percentage"),
                    "timeleft": s.get("timeleft"),
                    "mb_left": s.get("mbleft")
                } for s in queue.get("slots", [])]
            }
        except Exception as e:
            return {"error": str(e)}

    @mcp.tool()
    async def sabnzbd_get_history(limit: int = 10) -> List[dict]:
        """Get SABnzbd download history."""
        try:
            result = await sabnzbd_request("history", limit=limit)
            return [{
                "name": h.get("name"),
                "status": h.get("status"),
                "size": h.get("size"),
                "completed": h.get("completed"),
                "category": h.get("category")
            } for h in result.get("history", {}).get("slots", [])]
        except Exception as e:
            return [{"error": str(e)}]

    @mcp.tool()
    async def sabnzbd_pause_queue() -> dict:
        """Pause SABnzbd queue."""
        try:
            await sabnzbd_request("pause")
            return {"success": True, "message": "SABnzbd queue paused"}
        except Exception as e:
            return {"error": str(e)}

    @mcp.tool()
    async def sabnzbd_resume_queue() -> dict:
        """Resume SABnzbd queue."""
        try:
            await sabnzbd_request("resume")
            return {"success": True, "message": "SABnzbd queue resumed"}
        except Exception as e:
            return {"error": str(e)}

    # ==========================================================================
    # COMBINED/STATUS TOOLS
    # ==========================================================================

    @mcp.tool()
    async def get_all_downloads() -> dict:
        """Get combined download status from all clients."""
        result = {"sonarr": [], "radarr": [], "transmission": [], "sabnzbd": {}}

        try:
            result["sonarr"] = await sonarr_get_queue()
        except:
            pass

        try:
            result["radarr"] = await radarr_get_queue()
        except:
            pass

        try:
            result["transmission"] = await transmission_list_torrents()
        except:
            pass

        try:
            result["sabnzbd"] = await sabnzbd_get_queue()
        except:
            pass

        return result

    @mcp.tool()
    async def get_system_status() -> dict:
        """Get status of all media services."""
        status = {}

        services = [
            ("sonarr", SONARR_URL, SONARR_API_KEY, "system/status"),
            ("radarr", RADARR_URL, RADARR_API_KEY, "system/status"),
            ("prowlarr", PROWLARR_URL, PROWLARR_API_KEY, "system/status"),
        ]

        for name, url, key, endpoint in services:
            try:
                info = await arr_request(url, key, endpoint)
                status[name] = {"version": info.get("version"), "status": "online"}
            except Exception as e:
                status[name] = {"status": "offline", "error": str(e)[:50]}

        # Overseerr
        try:
            info = await overseerr_request("status")
            status["overseerr"] = {"version": info.get("version"), "status": "online"}
        except Exception as e:
            status["overseerr"] = {"status": "offline", "error": str(e)[:50]}

        # Tautulli
        try:
            info = await tautulli_request("get_tautulli_info")
            status["tautulli"] = {"version": info.get("tautulli_version"), "status": "online"}
        except Exception as e:
            status["tautulli"] = {"status": "offline", "error": str(e)[:50]}

        return status

    # ==========================================================================
    # REST API (for LangGraph context building)
    # ==========================================================================

    async def rest_health(request: Request):
        """Health check endpoint."""
        status = await get_system_status()
        online_count = sum(1 for s in status.values() if s.get("status") == "online")
        return JSONResponse({
            "status": "healthy" if online_count >= 3 else "degraded",
            "services": status,
            "online": online_count,
            "total": len(status)
        })

    async def rest_api_status(request: Request):
        """Get system status for LangGraph context."""
        return JSONResponse({"status": "ok", "data": await get_system_status()})

    async def rest_api_downloads(request: Request):
        """Get all downloads for LangGraph context."""
        return JSONResponse({"status": "ok", "data": await get_all_downloads()})

    async def rest_api_activity(request: Request):
        """Get Plex activity for LangGraph context."""
        return JSONResponse({"status": "ok", "data": await tautulli_get_activity()})

    # ==========================================================================
    # MAIN
    # ==========================================================================

    def main():
        port = int(os.environ.get("PORT", "8000"))
        logger.info(f"Starting arr-suite MCP on port {port}")
        logger.info(f"Services: Sonarr, Radarr, Prowlarr, Overseerr, Tautulli, Transmission, SABnzbd")

        rest_routes = [
            Route("/health", rest_health, methods=["GET"]),
            Route("/api/status", rest_api_status, methods=["GET"]),
            Route("/api/downloads", rest_api_downloads, methods=["GET"]),
            Route("/api/activity", rest_api_activity, methods=["GET"]),
        ]

        mcp_app = mcp.http_app()
        app = Starlette(routes=rest_routes + [Mount("/mcp", app=mcp_app)])
        uvicorn.run(app, host="0.0.0.0", port=port)

    if __name__ == "__main__":
        main()

  requirements.txt: |
    fastmcp>=2.7.0
    pydantic>=2.11.0
    httpx>=0.28.0
    uvicorn>=0.34.0
    starlette>=0.40.0
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: arr-suite-mcp
  namespace: ai-platform
  labels:
    app: arr-suite-mcp
    component: mcp
spec:
  replicas: 1
  selector:
    matchLabels:
      app: arr-suite-mcp
  template:
    metadata:
      labels:
        app: arr-suite-mcp
        component: mcp
    spec:
      initContainers:
        - name: install-deps
          image: python:3.11-slim
          command: ['sh', '-c', 'pip install --target=/app/deps -r /code/requirements.txt']
          volumeMounts:
            - name: code
              mountPath: /code
            - name: deps
              mountPath: /app/deps
      containers:
        - name: mcp-server
          image: python:3.11-slim
          command: ['sh', '-c', 'cd /app && PYTHONPATH=/app/deps python /code/main.py']
          ports:
            - containerPort: 8000
              name: http
          env:
            - name: PORT
              value: "8000"
            # Sonarr
            - name: SONARR_URL
              value: "https://sonarr.kernow.io"
            - name: SONARR_API_KEY
              valueFrom:
                secretKeyRef:
                  name: mcp-sonarr
                  key: API_KEY
            # Radarr
            - name: RADARR_URL
              value: "https://radarr.kernow.io"
            - name: RADARR_API_KEY
              valueFrom:
                secretKeyRef:
                  name: mcp-radarr
                  key: API_KEY
            # Prowlarr
            - name: PROWLARR_URL
              value: "https://prowlarr.kernow.io"
            - name: PROWLARR_API_KEY
              valueFrom:
                secretKeyRef:
                  name: mcp-prowlarr
                  key: API_KEY
            # Overseerr
            - name: OVERSEERR_URL
              value: "https://overseerr.kernow.io"
            - name: OVERSEERR_API_KEY
              valueFrom:
                secretKeyRef:
                  name: mcp-overseerr
                  key: API_KEY
            # Tautulli
            - name: TAUTULLI_URL
              value: "https://tautulli.kernow.io"
            - name: TAUTULLI_API_KEY
              valueFrom:
                secretKeyRef:
                  name: mcp-tautulli
                  key: API_KEY
            # Transmission
            - name: TRANSMISSION_URL
              value: "https://transmission.kernow.io"
            - name: TRANSMISSION_USER
              valueFrom:
                secretKeyRef:
                  name: mcp-transmission
                  key: TRANSMISSION_RPC_USERNAME
            - name: TRANSMISSION_PASS
              valueFrom:
                secretKeyRef:
                  name: mcp-transmission
                  key: TRANSMISSION_RPC_PASSWORD
            # SABnzbd
            - name: SABNZBD_URL
              value: "https://sabnzbd.kernow.io"
            - name: SABNZBD_API_KEY
              valueFrom:
                secretKeyRef:
                  name: mcp-sabnzbd
                  key: API_KEY
          volumeMounts:
            - name: code
              mountPath: /code
            - name: deps
              mountPath: /app/deps
          resources:
            requests:
              memory: "128Mi"
              cpu: "100m"
            limits:
              memory: "256Mi"
              cpu: "500m"
          readinessProbe:
            httpGet:
              path: /health
              port: 8000
            initialDelaySeconds: 30
            periodSeconds: 10
          livenessProbe:
            httpGet:
              path: /health
              port: 8000
            initialDelaySeconds: 60
            periodSeconds: 30
      volumes:
        - name: code
          configMap:
            name: arr-suite-mcp-code
        - name: deps
          emptyDir: {}
---
apiVersion: v1
kind: Service
metadata:
  name: arr-suite-mcp
  namespace: ai-platform
  labels:
    app: arr-suite-mcp
    component: mcp
spec:
  type: NodePort
  selector:
    app: arr-suite-mcp
  ports:
    - port: 8000
      targetPort: 8000
      nodePort: 31091
      name: http
