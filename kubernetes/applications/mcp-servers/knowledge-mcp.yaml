apiVersion: v1
kind: ConfigMap
metadata:
  name: knowledge-mcp-code
  namespace: ai-platform
  labels:
    app: knowledge-mcp
data:
  main.py: |
    #!/usr/bin/env python3
    """Knowledge MCP server for comprehensive Qdrant vector database operations.
    Provides unified knowledge access: runbooks, documentation, entities, decisions.
    """
    import os
    import logging
    import httpx
    import uuid
    from typing import List, Optional, Dict, Any
    from datetime import datetime, timezone
    from fastmcp import FastMCP
    from pydantic import BaseModel
    from starlette.applications import Starlette
    from starlette.routing import Route, Mount
    from starlette.responses import JSONResponse
    from starlette.requests import Request
    import uvicorn

    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger(__name__)

    QDRANT_URL = os.environ.get("QDRANT_URL", "http://qdrant:6333")
    LITELLM_URL = os.environ.get("LITELLM_URL", "http://litellm:4000")
    EMBEDDING_MODEL = os.environ.get("EMBEDDING_MODEL", "embeddings")

    mcp = FastMCP(
        name="knowledge-mcp",
        instructions="""MCP server for comprehensive knowledge base operations.
        Collections: runbooks, documentation, entities, decisions, agent_events.
        Use for semantic search, entity lookup, runbook management, and decision tracking."""
    )

    # ============================================================================
    # HELPERS
    # ============================================================================

    async def get_embedding(text: str) -> List[float]:
        """Get embeddings via LiteLLM (Gemini text-embedding-004)."""
        async with httpx.AsyncClient(timeout=60.0) as client:
            response = await client.post(
                f"{LITELLM_URL}/v1/embeddings",
                json={"model": EMBEDDING_MODEL, "input": text}
            )
            response.raise_for_status()
            return response.json()["data"][0]["embedding"]

    async def qdrant_search(collection: str, vector: List[float], limit: int = 5, filter_: Optional[dict] = None) -> List[dict]:
        """Search Qdrant collection with optional filter."""
        async with httpx.AsyncClient(timeout=30.0) as client:
            payload = {"vector": vector, "limit": limit, "with_payload": True}
            if filter_:
                payload["filter"] = filter_
            response = await client.post(
                f"{QDRANT_URL}/collections/{collection}/points/search",
                json=payload
            )
            if response.status_code == 404:
                return []
            response.raise_for_status()
            return response.json().get("result", [])

    async def qdrant_upsert(collection: str, points: List[dict]) -> bool:
        """Upsert points to Qdrant collection."""
        async with httpx.AsyncClient(timeout=30.0) as client:
            response = await client.put(
                f"{QDRANT_URL}/collections/{collection}/points",
                json={"points": points}
            )
            return response.status_code == 200

    async def qdrant_delete(collection: str, point_ids: List[str]) -> bool:
        """Delete points from Qdrant collection."""
        async with httpx.AsyncClient(timeout=30.0) as client:
            response = await client.post(
                f"{QDRANT_URL}/collections/{collection}/points/delete",
                json={"points": point_ids}
            )
            return response.status_code == 200

    async def qdrant_scroll(collection: str, filter_: Optional[dict] = None, limit: int = 100) -> List[dict]:
        """Scroll through collection with optional filter (no vector needed)."""
        async with httpx.AsyncClient(timeout=30.0) as client:
            payload = {"limit": limit, "with_payload": True}
            if filter_:
                payload["filter"] = filter_
            response = await client.post(
                f"{QDRANT_URL}/collections/{collection}/points/scroll",
                json=payload
            )
            if response.status_code == 404:
                return []
            response.raise_for_status()
            return response.json().get("result", {}).get("points", [])

    async def qdrant_get_point(collection: str, point_id: str) -> Optional[dict]:
        """Get a single point by ID."""
        async with httpx.AsyncClient(timeout=30.0) as client:
            response = await client.get(f"{QDRANT_URL}/collections/{collection}/points/{point_id}")
            if response.status_code == 404:
                return None
            response.raise_for_status()
            return response.json().get("result")

    # ============================================================================
    # COLLECTION MANAGEMENT
    # ============================================================================

    @mcp.tool()
    async def list_collections() -> List[dict]:
        """List all available Qdrant collections with point counts."""
        try:
            async with httpx.AsyncClient(timeout=30.0) as client:
                response = await client.get(f"{QDRANT_URL}/collections")
                response.raise_for_status()
                collections = response.json().get("result", {}).get("collections", [])
                result = []
                for c in collections:
                    name = c.get("name")
                    info_resp = await client.get(f"{QDRANT_URL}/collections/{name}")
                    if info_resp.status_code == 200:
                        info = info_resp.json().get("result", {})
                        result.append({
                            "name": name,
                            "points_count": info.get("points_count", 0),
                            "vectors_count": info.get("vectors_count", 0)
                        })
                return result
        except Exception as e:
            logger.error(f"list_collections failed: {e}")
            return []

    @mcp.tool()
    async def get_collection_info(collection: str) -> dict:
        """Get detailed info about a collection."""
        try:
            async with httpx.AsyncClient(timeout=30.0) as client:
                response = await client.get(f"{QDRANT_URL}/collections/{collection}")
                if response.status_code == 404:
                    return {"error": f"Collection '{collection}' not found"}
                response.raise_for_status()
                return response.json().get("result", {})
        except Exception as e:
            return {"error": str(e)}

    # ============================================================================
    # RUNBOOK TOOLS
    # ============================================================================

    @mcp.tool()
    async def search_runbooks(query: str, limit: int = 5, min_score: float = 0.6) -> List[dict]:
        """Search runbooks for solutions to issues. Returns title, solution, and path."""
        try:
            vector = await get_embedding(query)
            results = await qdrant_search("runbooks", vector, limit)
            return [{
                "id": str(r.get("id")),
                "score": round(r.get("score", 0), 3),
                "title": r.get("payload", {}).get("title", ""),
                "solution": r.get("payload", {}).get("solution", "")[:500],
                "path": r.get("payload", {}).get("path", "")
            } for r in results if r.get("score", 0) >= min_score]
        except Exception as e:
            logger.error(f"search_runbooks failed: {e}")
            return [{"error": str(e)}]

    @mcp.tool()
    async def get_runbook(runbook_id: str) -> dict:
        """Get full runbook content by ID."""
        try:
            result = await qdrant_get_point("runbooks", runbook_id)
            if not result:
                return {"error": "Runbook not found"}
            return result.get("payload", {})
        except Exception as e:
            return {"error": str(e)}

    @mcp.tool()
    async def add_runbook(title: str, trigger_pattern: str, solution: str, path: Optional[str] = None) -> dict:
        """Add a new runbook to the knowledge base."""
        try:
            point_id = str(uuid.uuid4())
            vector = await get_embedding(f"{title}\n{trigger_pattern}\n{solution[:1000]}")
            point = {
                "id": point_id,
                "vector": vector,
                "payload": {
                    "title": title,
                    "trigger_pattern": trigger_pattern,
                    "solution": solution,
                    "path": path or "",
                    "created_at": datetime.now(timezone.utc).isoformat()
                }
            }
            success = await qdrant_upsert("runbooks", [point])
            return {"success": success, "id": point_id}
        except Exception as e:
            return {"success": False, "error": str(e)}

    @mcp.tool()
    async def list_runbooks(limit: int = 50) -> List[dict]:
        """List all runbooks (titles and IDs)."""
        try:
            results = await qdrant_scroll("runbooks", limit=limit)
            return [{
                "id": str(r.get("id")),
                "title": r.get("payload", {}).get("title", ""),
                "path": r.get("payload", {}).get("path", ""),
                "automation_level": r.get("payload", {}).get("automation_level", "manual"),
                "success_rate": r.get("payload", {}).get("success_rate", 0.0),
                "execution_count": r.get("payload", {}).get("execution_count", 0)
            } for r in results]
        except Exception as e:
            return [{"error": str(e)}]

    # ============================================================================
    # AUTONOMY MANAGEMENT TOOLS - Forever Learning System Phase 3
    # ============================================================================

    # Autonomy levels define progressive trust in runbook execution
    AUTONOMY_LEVELS = {
        "manual": {
            "confidence_threshold": 0.0,
            "requires_approval": True,
            "timeout_auto_approve": None,
            "notify_human": True,
            "description": "Always requires human approval"
        },
        "prompted": {
            "confidence_threshold": 0.7,
            "requires_approval": True,
            "timeout_auto_approve": 300,  # Auto-approve after 5 min
            "notify_human": True,
            "description": "Prompts human, auto-approves if no response"
        },
        "standard": {
            "confidence_threshold": 0.85,
            "requires_approval": False,
            "timeout_auto_approve": None,
            "notify_human": True,
            "description": "Executes automatically, notifies human"
        },
        "autonomous": {
            "confidence_threshold": 0.95,
            "requires_approval": False,
            "timeout_auto_approve": None,
            "notify_human": False,
            "description": "Fully autonomous, logged only"
        }
    }

    @mcp.tool()
    async def update_runbook(
        runbook_id: str,
        automation_level: Optional[str] = None,
        success_rate: Optional[float] = None,
        execution_count: Optional[int] = None,
        success_count: Optional[int] = None
    ) -> dict:
        """Update runbook metadata including autonomy level and execution stats.

        Used by the autonomy system to track runbook performance and
        automatically upgrade/downgrade autonomy levels based on success rates.

        Args:
            runbook_id: UUID of the runbook to update
            automation_level: New autonomy level (manual, prompted, standard, autonomous)
            success_rate: Updated success rate (0.0-1.0)
            execution_count: Total number of executions
            success_count: Number of successful executions

        Returns:
            Status of the update operation
        """
        try:
            if automation_level and automation_level not in AUTONOMY_LEVELS:
                return {"success": False, "error": f"Invalid autonomy level: {automation_level}"}

            point = await qdrant_get_point("runbooks", runbook_id)
            if not point:
                return {"success": False, "error": f"Runbook not found: {runbook_id}"}

            payload = point.get("payload", {})
            old_level = payload.get("automation_level", "manual")

            if automation_level is not None:
                payload["automation_level"] = automation_level
                if old_level != automation_level:
                    logger.info(f"Runbook {runbook_id} autonomy: {old_level} -> {automation_level}")
            if success_rate is not None:
                payload["success_rate"] = success_rate
            if execution_count is not None:
                payload["execution_count"] = execution_count
            if success_count is not None:
                payload["success_count"] = success_count

            payload["last_updated"] = datetime.now(timezone.utc).isoformat()

            vector = await get_embedding(f"{payload.get('title', '')}\n{payload.get('trigger_pattern', '')}\n{payload.get('solution', '')[:1000]}")
            updated_point = {"id": runbook_id, "vector": vector, "payload": payload}
            success = await qdrant_upsert("runbooks", [updated_point])
            return {"success": success, "id": runbook_id}
        except Exception as e:
            return {"success": False, "error": str(e)}

    @mcp.tool()
    async def record_runbook_execution(runbook_id: str, success: bool, resolution_time: Optional[int] = None) -> dict:
        """Record a runbook execution and update statistics.

        Convenience method that updates execution_count, success_count, and success_rate
        in a single call. Used after executing a runbook to track its effectiveness.

        Args:
            runbook_id: UUID of the executed runbook
            success: Whether the execution was successful
            resolution_time: Time to resolution in seconds (optional)

        Returns:
            Updated runbook stats and any autonomy level changes
        """
        try:
            point = await qdrant_get_point("runbooks", runbook_id)
            if not point:
                return {"success": False, "error": f"Runbook not found: {runbook_id}"}

            payload = point.get("payload", {})
            execution_count = payload.get("execution_count", 0) + 1
            success_count = payload.get("success_count", 0) + (1 if success else 0)
            success_rate = success_count / execution_count if execution_count > 0 else 0.0

            payload["execution_count"] = execution_count
            payload["success_count"] = success_count
            payload["success_rate"] = success_rate
            payload["last_executed"] = datetime.now(timezone.utc).isoformat()

            # Check for autonomy upgrade eligibility
            current_level = payload.get("automation_level", "manual")
            suggested_upgrade = None
            level_order = ["manual", "prompted", "standard", "autonomous"]

            if execution_count >= 10:
                for level_name, level_config in AUTONOMY_LEVELS.items():
                    if success_rate >= level_config["confidence_threshold"]:
                        if level_order.index(level_name) > level_order.index(current_level):
                            suggested_upgrade = level_name

            vector = await get_embedding(f"{payload.get('title', '')}\n{payload.get('trigger_pattern', '')}\n{payload.get('solution', '')[:1000]}")
            updated_point = {"id": runbook_id, "vector": vector, "payload": payload}
            upsert_success = await qdrant_upsert("runbooks", [updated_point])

            result = {
                "success": upsert_success,
                "id": runbook_id,
                "execution_count": execution_count,
                "success_rate": round(success_rate, 3),
                "current_level": current_level
            }
            if suggested_upgrade:
                result["suggested_upgrade"] = suggested_upgrade
                result["upgrade_reason"] = f"Success rate {success_rate:.0%} exceeds threshold"
            return result
        except Exception as e:
            return {"success": False, "error": str(e)}

    @mcp.tool()
    async def get_autonomy_config(level: str) -> dict:
        """Get the configuration for an autonomy level.

        Args:
            level: Autonomy level name (manual, prompted, standard, autonomous)

        Returns:
            Level configuration including thresholds and approval requirements
        """
        if level not in AUTONOMY_LEVELS:
            return {"error": f"Invalid level. Valid: {list(AUTONOMY_LEVELS.keys())}"}
        return {"level": level, **AUTONOMY_LEVELS[level]}

    @mcp.tool()
    async def list_autonomy_candidates(min_executions: int = 10, min_success_rate: float = 0.9) -> List[dict]:
        """List runbooks eligible for autonomy upgrade.

        Finds runbooks that meet criteria for upgrading to a higher autonomy level
        based on their execution history and success rate.

        Args:
            min_executions: Minimum number of executions required (default: 10)
            min_success_rate: Minimum success rate required (default: 0.9)

        Returns:
            List of runbooks with upgrade suggestions
        """
        try:
            results = await qdrant_scroll("runbooks", limit=200)
            candidates = []
            level_order = ["manual", "prompted", "standard", "autonomous"]

            for r in results:
                payload = r.get("payload", {})
                execution_count = payload.get("execution_count", 0)
                success_rate = payload.get("success_rate", 0.0)
                current_level = payload.get("automation_level", "manual")

                if execution_count < min_executions or success_rate < min_success_rate:
                    continue

                eligible_level = current_level
                for level_name, level_config in AUTONOMY_LEVELS.items():
                    if success_rate >= level_config["confidence_threshold"]:
                        if level_order.index(level_name) > level_order.index(eligible_level):
                            eligible_level = level_name

                if eligible_level != current_level:
                    candidates.append({
                        "id": str(r.get("id", "")),
                        "title": payload.get("title", ""),
                        "current_level": current_level,
                        "suggested_level": eligible_level,
                        "success_rate": round(success_rate, 3),
                        "execution_count": execution_count
                    })
            return candidates
        except Exception as e:
            return [{"error": str(e)}]

    # ============================================================================
    # DOCUMENTATION TOOLS
    # ============================================================================

    @mcp.tool()
    async def search_documentation(query: str, limit: int = 5, min_score: float = 0.5) -> List[dict]:
        """Search documentation for information."""
        try:
            vector = await get_embedding(query)
            results = await qdrant_search("documentation", vector, limit)
            return [{
                "id": str(r.get("id")),
                "score": round(r.get("score", 0), 3),
                "title": r.get("payload", {}).get("title", ""),
                "content": r.get("payload", {}).get("content", "")[:500],
                "path": r.get("payload", {}).get("path", "")
            } for r in results if r.get("score", 0) >= min_score]
        except Exception as e:
            logger.error(f"search_documentation failed: {e}")
            return [{"error": str(e)}]

    @mcp.tool()
    async def add_documentation(title: str, content: str, path: Optional[str] = None, tags: Optional[List[str]] = None) -> dict:
        """Add documentation to the knowledge base."""
        try:
            point_id = str(uuid.uuid4())
            vector = await get_embedding(f"{title}\n{content[:2000]}")
            point = {
                "id": point_id,
                "vector": vector,
                "payload": {
                    "title": title,
                    "content": content,
                    "path": path or "",
                    "tags": tags or [],
                    "indexed_at": datetime.now(timezone.utc).isoformat()
                }
            }
            success = await qdrant_upsert("documentation", [point])
            return {"success": success, "id": point_id}
        except Exception as e:
            return {"success": False, "error": str(e)}

    # ============================================================================
    # ENTITY INTELLIGENCE TOOLS
    # ============================================================================

    @mcp.tool()
    async def search_entities(query: str, limit: int = 10) -> List[dict]:
        """Semantic search for network entities. Examples: 'Chromecast devices', 'IoT on guest VLAN'."""
        try:
            vector = await get_embedding(query)
            results = await qdrant_search("entities", vector, limit)
            return [{
                "id": str(r.get("id")),
                "score": round(r.get("score", 0), 3),
                "hostname": r.get("payload", {}).get("hostname", ""),
                "ip": r.get("payload", {}).get("ip", ""),
                "mac": r.get("payload", {}).get("mac", ""),
                "type": r.get("payload", {}).get("type", ""),
                "network": r.get("payload", {}).get("network", ""),
                "location": r.get("payload", {}).get("location", "")
            } for r in results]
        except Exception as e:
            logger.error(f"search_entities failed: {e}")
            return [{"error": str(e)}]

    @mcp.tool()
    async def get_entity(identifier: str) -> dict:
        """Get entity by IP, MAC, or hostname."""
        try:
            # Try each identifier type
            for field in ["ip", "mac", "hostname"]:
                filter_ = {"must": [{"key": field, "match": {"value": identifier}}]}
                results = await qdrant_scroll("entities", filter_=filter_, limit=1)
                if results:
                    return results[0].get("payload", {})
            return {"error": f"Entity not found: {identifier}"}
        except Exception as e:
            return {"error": str(e)}

    @mcp.tool()
    async def get_entities_by_type(entity_type: str, limit: int = 50) -> List[dict]:
        """Get entities by type: sonoff, chromecast, nas, printer, switch, etc."""
        try:
            filter_ = {"must": [{"key": "type", "match": {"value": entity_type}}]}
            results = await qdrant_scroll("entities", filter_=filter_, limit=limit)
            return [{
                "id": str(r.get("id")),
                "hostname": r.get("payload", {}).get("hostname", ""),
                "ip": r.get("payload", {}).get("ip", ""),
                "network": r.get("payload", {}).get("network", ""),
                "location": r.get("payload", {}).get("location", "")
            } for r in results]
        except Exception as e:
            return [{"error": str(e)}]

    @mcp.tool()
    async def get_entities_by_network(network: str, limit: int = 100) -> List[dict]:
        """Get entities by network: prod, iot-vlan, guest, management, etc."""
        try:
            filter_ = {"must": [{"key": "network", "match": {"value": network}}]}
            results = await qdrant_scroll("entities", filter_=filter_, limit=limit)
            return [{
                "id": str(r.get("id")),
                "hostname": r.get("payload", {}).get("hostname", ""),
                "ip": r.get("payload", {}).get("ip", ""),
                "type": r.get("payload", {}).get("type", ""),
                "location": r.get("payload", {}).get("location", "")
            } for r in results]
        except Exception as e:
            return [{"error": str(e)}]

    @mcp.tool()
    async def add_entity(
        hostname: str,
        ip: str,
        mac: Optional[str] = None,
        entity_type: Optional[str] = None,
        network: Optional[str] = None,
        location: Optional[str] = None,
        manufacturer: Optional[str] = None,
        model: Optional[str] = None,
        capabilities: Optional[List[str]] = None,
        notes: Optional[str] = None
    ) -> dict:
        """Add a new entity to the knowledge base."""
        try:
            point_id = str(uuid.uuid4())
            embed_text = f"{hostname} {entity_type or ''} {manufacturer or ''} {location or ''}"
            vector = await get_embedding(embed_text)
            point = {
                "id": point_id,
                "vector": vector,
                "payload": {
                    "hostname": hostname,
                    "ip": ip,
                    "mac": mac or "",
                    "type": entity_type or "unknown",
                    "network": network or "unknown",
                    "location": location or "",
                    "manufacturer": manufacturer or "",
                    "model": model or "",
                    "capabilities": capabilities or [],
                    "notes": notes or "",
                    "discovered_at": datetime.now(timezone.utc).isoformat()
                }
            }
            success = await qdrant_upsert("entities", [point])
            return {"success": success, "id": point_id}
        except Exception as e:
            return {"success": False, "error": str(e)}

    @mcp.tool()
    async def list_entity_types() -> List[dict]:
        """List all unique entity types with counts."""
        try:
            results = await qdrant_scroll("entities", limit=500)
            type_counts: Dict[str, int] = {}
            for r in results:
                t = r.get("payload", {}).get("type", "unknown")
                type_counts[t] = type_counts.get(t, 0) + 1
            return [{"type": k, "count": v} for k, v in sorted(type_counts.items(), key=lambda x: -x[1])]
        except Exception as e:
            return [{"error": str(e)}]

    # ============================================================================
    # DECISION TRACKING TOOLS
    # ============================================================================

    @mcp.tool()
    async def search_decisions(query: str, limit: int = 5) -> List[dict]:
        """Search architectural decisions and past solutions."""
        try:
            vector = await get_embedding(query)
            results = await qdrant_search("decisions", vector, limit)
            return [{
                "id": str(r.get("id")),
                "score": round(r.get("score", 0), 3),
                "title": r.get("payload", {}).get("title", ""),
                "decision": r.get("payload", {}).get("decision", ""),
                "rationale": r.get("payload", {}).get("rationale", "")[:300],
                "date": r.get("payload", {}).get("date", "")
            } for r in results]
        except Exception as e:
            return [{"error": str(e)}]

    @mcp.tool()
    async def add_decision(title: str, decision: str, rationale: str, context: Optional[str] = None, alternatives: Optional[List[str]] = None) -> dict:
        """Record an architectural decision."""
        try:
            point_id = str(uuid.uuid4())
            vector = await get_embedding(f"{title}\n{decision}\n{rationale}")
            point = {
                "id": point_id,
                "vector": vector,
                "payload": {
                    "title": title,
                    "decision": decision,
                    "rationale": rationale,
                    "context": context or "",
                    "alternatives": alternatives or [],
                    "date": datetime.now(timezone.utc).isoformat()
                }
            }
            success = await qdrant_upsert("decisions", [point])
            return {"success": success, "id": point_id}
        except Exception as e:
            return {"success": False, "error": str(e)}

    # ============================================================================
    # EVENT LOGGING TOOLS - Forever Learning System
    # ============================================================================

    # Valid event types for the learning system
    EVENT_TYPES = {
        "agent.chat.start",      # Conversation initiated
        "agent.chat.complete",   # Conversation finished
        "agent.tool.call",       # Tool executed
        "agent.error",           # Error occurred
        "validation.complete",   # Validator reviewed item
        "runbook.executed",      # Runbook was run
        "feedback.received",     # Human provided feedback
        "pattern.detected",      # Pattern detector found something
        "autonomy.upgrade",      # Runbook autonomy level changed
    }

    @mcp.tool()
    async def get_similar_events(event_description: str, limit: int = 5, min_score: float = 0.7) -> List[dict]:
        """Find similar historical events for pattern matching."""
        try:
            vector = await get_embedding(event_description)
            results = await qdrant_search("agent_events", vector, limit)
            return [{
                "id": str(r.get("id")),
                "score": round(r.get("score", 0), 3),
                "event_type": r.get("payload", {}).get("event_type", ""),
                "description": r.get("payload", {}).get("description", ""),
                "resolution": r.get("payload", {}).get("resolution", ""),
                "timestamp": r.get("payload", {}).get("timestamp", ""),
                "score_value": r.get("payload", {}).get("score"),
                "feedback": r.get("payload", {}).get("feedback", "")
            } for r in results if r.get("score", 0) >= min_score]
        except Exception as e:
            return [{"error": str(e)}]

    @mcp.tool()
    async def log_event(
        event_type: str,
        description: str,
        source_agent: str = "claude-agent",
        metadata: Optional[dict] = None,
        resolution: Optional[str] = None
    ) -> dict:
        """Log an event to agent_events collection for learning.

        Foundation of the Forever Learning System - every interaction is logged
        for pattern detection, feedback tracking, and autonomy progression.

        Args:
            event_type: Type of event (agent.chat.start, agent.chat.complete,
                       agent.tool.call, agent.error, validation.complete,
                       runbook.executed, feedback.received, pattern.detected, autonomy.upgrade)
            description: Natural language description of the event
            source_agent: Source (claude-agent, claude-validator, langgraph)
            metadata: Additional context (task_id, model, latency_ms, tools_used)
            resolution: Outcome (completed, failed, pending)

        Returns:
            Status with event ID for later feedback
        """
        try:
            point_id = str(uuid.uuid4())
            timestamp = datetime.now(timezone.utc).isoformat()

            combined_text = f"{event_type}: {description}"
            if resolution:
                combined_text += f" - {resolution}"
            vector = await get_embedding(combined_text)

            point = {
                "id": point_id,
                "vector": vector,
                "payload": {
                    "event_type": event_type,
                    "description": description,
                    "source_agent": source_agent,
                    "timestamp": timestamp,
                    "metadata": metadata or {},
                    "resolution": resolution or "",
                    "score": None,
                    "feedback": None
                }
            }
            success = await qdrant_upsert("agent_events", [point])
            if success:
                logger.info(f"Logged event {event_type} with ID {point_id}")
            return {"success": success, "id": point_id, "timestamp": timestamp}
        except Exception as e:
            logger.error(f"log_event failed: {e}")
            return {"success": False, "error": str(e)}

    @mcp.tool()
    async def update_event(
        event_id: str,
        score: Optional[float] = None,
        feedback: Optional[str] = None,
        resolution: Optional[str] = None
    ) -> dict:
        """Update an existing event with feedback or outcome.

        Used by feedback loop to record human feedback on agent actions,
        enabling the system to learn from successes and failures.

        Args:
            event_id: UUID of the event to update
            score: Feedback score 0.0-1.0 (0=failed, 0.5=partial, 1.0=perfect)
            feedback: Human feedback text
            resolution: Updated resolution (resolved, partial, failed, escalated)

        Returns:
            Status of the update operation
        """
        try:
            point = await qdrant_get_point("agent_events", event_id)
            if not point:
                return {"success": False, "error": f"Event not found: {event_id}"}

            payload = point.get("payload", {})

            if score is not None:
                if not 0.0 <= score <= 1.0:
                    return {"success": False, "error": "Score must be between 0.0 and 1.0"}
                payload["score"] = score
            if feedback is not None:
                payload["feedback"] = feedback
            if resolution is not None:
                payload["resolution"] = resolution

            payload["feedback_at"] = datetime.now(timezone.utc).isoformat()

            combined_text = f"{payload.get('event_type', '')}: {payload.get('description', '')}"
            if payload.get("resolution"):
                combined_text += f" - {payload['resolution']}"
            if payload.get("feedback"):
                combined_text += f" (feedback: {payload['feedback']})"
            vector = await get_embedding(combined_text)

            updated_point = {"id": event_id, "vector": vector, "payload": payload}
            success = await qdrant_upsert("agent_events", [updated_point])
            if success:
                logger.info(f"Updated event {event_id} with score={score}, resolution={resolution}")
            return {"success": success, "id": event_id}
        except Exception as e:
            logger.error(f"update_event failed: {e}")
            return {"success": False, "error": str(e)}

    @mcp.tool()
    async def get_event(event_id: str) -> dict:
        """Get a specific event by ID."""
        try:
            point = await qdrant_get_point("agent_events", event_id)
            if not point:
                return {"error": f"Event not found: {event_id}"}
            payload = point.get("payload", {})
            payload["id"] = event_id
            return payload
        except Exception as e:
            return {"error": str(e)}

    @mcp.tool()
    async def list_recent_events(
        event_type: Optional[str] = None,
        source_agent: Optional[str] = None,
        limit: int = 50
    ) -> List[dict]:
        """List recent events, optionally filtered by type or source."""
        try:
            filter_ = None
            must = []
            if event_type:
                must.append({"key": "event_type", "match": {"value": event_type}})
            if source_agent:
                must.append({"key": "source_agent", "match": {"value": source_agent}})
            if must:
                filter_ = {"must": must}

            results = await qdrant_scroll("agent_events", filter_, limit=limit)
            events = []
            for r in results:
                payload = r.get("payload", {})
                payload["id"] = str(r.get("id", ""))
                events.append(payload)
            events.sort(key=lambda x: x.get("timestamp", ""), reverse=True)
            return events
        except Exception as e:
            logger.error(f"list_recent_events failed: {e}")
            return [{"error": str(e)}]

    # ============================================================================
    # UNIFIED SEARCH
    # ============================================================================

    @mcp.tool()
    async def search_all(query: str, limit: int = 3) -> dict:
        """Search across all collections (runbooks, docs, entities, decisions)."""
        try:
            vector = await get_embedding(query)
            results = {}

            # Search each collection
            for collection in ["runbooks", "documentation", "entities", "decisions"]:
                try:
                    items = await qdrant_search(collection, vector, limit)
                    results[collection] = [{
                        "id": str(r.get("id")),
                        "score": round(r.get("score", 0), 3),
                        "title": r.get("payload", {}).get("title") or r.get("payload", {}).get("hostname", ""),
                        "preview": (r.get("payload", {}).get("content") or r.get("payload", {}).get("solution") or r.get("payload", {}).get("decision", ""))[:200]
                    } for r in items]
                except:
                    results[collection] = []

            return results
        except Exception as e:
            return {"error": str(e)}

    # ============================================================================
    # ENTITY MANAGEMENT TOOLS
    # ============================================================================

    @mcp.tool()
    async def delete_entity(entity_id: str) -> dict:
        """Delete an entity by its ID."""
        try:
            success = await qdrant_delete("entities", [entity_id])
            return {"success": success, "id": entity_id}
        except Exception as e:
            return {"success": False, "error": str(e)}

    @mcp.tool()
    async def delete_entities_by_ip(ip: str) -> dict:
        """Delete all entities matching an IP address. Useful for cleaning up duplicates."""
        try:
            filter_ = {"must": [{"key": "ip", "match": {"value": ip}}]}
            results = await qdrant_scroll("entities", filter_, limit=100)
            if not results:
                return {"success": True, "deleted": 0, "message": f"No entities found with IP {ip}"}
            entity_ids = [str(r.get("id", "")) for r in results if r.get("id")]
            if entity_ids:
                success = await qdrant_delete("entities", entity_ids)
                return {"success": success, "deleted": len(entity_ids), "ids": entity_ids}
            return {"success": True, "deleted": 0}
        except Exception as e:
            return {"success": False, "error": str(e)}

    # ============================================================================
    # REST API (for langgraph context building)
    # ============================================================================

    async def rest_health(request: Request):
        """Health check endpoint."""
        try:
            # Verify Qdrant connectivity
            async with httpx.AsyncClient(timeout=5.0) as client:
                resp = await client.get(f"{QDRANT_URL}/collections")
                qdrant_ok = resp.status_code == 200
        except:
            qdrant_ok = False

        return JSONResponse({
            "status": "healthy" if qdrant_ok else "degraded",
            "qdrant": "connected" if qdrant_ok else "unreachable"
        })

    async def rest_api_search(request: Request):
        """Search knowledge base for langgraph context."""
        try:
            query = request.query_params.get("q", "")
            collection = request.query_params.get("collection", "runbooks")
            limit = int(request.query_params.get("limit", "5"))
            if not query:
                return JSONResponse({"status": "error", "error": "Missing query parameter 'q'"}, status_code=400)
            vector = await get_embedding(query)
            results = await qdrant_search(collection, vector, limit)
            return JSONResponse({"status": "ok", "data": results, "count": len(results)})
        except Exception as e:
            logger.error(f"REST api_search error: {e}")
            return JSONResponse({"status": "error", "error": str(e)}, status_code=500)

    async def rest_api_collections(request: Request):
        """List all collections."""
        try:
            collections = await list_collections()
            return JSONResponse({"status": "ok", "data": collections})
        except Exception as e:
            return JSONResponse({"status": "error", "error": str(e)}, status_code=500)

    async def rest_api_entity(request: Request):
        """Get entity by identifier."""
        try:
            identifier = request.query_params.get("id", "")
            if not identifier:
                return JSONResponse({"status": "error", "error": "Missing 'id' parameter"}, status_code=400)
            entity = await get_entity(identifier)
            return JSONResponse({"status": "ok", "data": entity})
        except Exception as e:
            return JSONResponse({"status": "error", "error": str(e)}, status_code=500)

    async def rest_api_runbook(request: Request):
        """Get runbook by ID."""
        try:
            runbook_id = request.query_params.get("id", "")
            if not runbook_id:
                return JSONResponse({"status": "error", "error": "Missing 'id' parameter"}, status_code=400)
            runbook = await get_runbook(runbook_id)
            return JSONResponse({"status": "ok", "data": runbook})
        except Exception as e:
            return JSONResponse({"status": "error", "error": str(e)}, status_code=500)

    async def rest_api_runbooks(request: Request):
        """List all runbooks."""
        try:
            limit = int(request.query_params.get("limit", "100"))
            results = await qdrant_scroll("runbooks", limit=limit)
            runbooks = [{
                "id": str(r.get("id")),
                "title": r.get("payload", {}).get("title", ""),
                "path": r.get("payload", {}).get("path", ""),
                "trigger_pattern": r.get("payload", {}).get("trigger_pattern", "")
            } for r in results]
            return JSONResponse({"status": "ok", "runbooks": runbooks})
        except Exception as e:
            return JSONResponse({"status": "error", "error": str(e)}, status_code=500)

    async def rest_api_log_event(request: Request):
        """Log an event to the agent_events collection (REST API wrapper for Forever Learning System)."""
        try:
            import json as json_module
            body = await request.body()
            data = json_module.loads(body)

            event_type = data.get("event_type")
            description = data.get("description")
            source_agent = data.get("source_agent", "claude-agent")
            metadata = data.get("metadata")
            resolution = data.get("resolution")

            if not event_type or not description:
                return JSONResponse(
                    {"status": "error", "error": "Missing required fields: event_type and description"},
                    status_code=400
                )

            # Call the log_event function directly (not the MCP tool wrapper)
            result = await _log_event_impl(event_type, description, source_agent, metadata, resolution)
            return JSONResponse(result)
        except Exception as e:
            logger.error(f"Error logging event: {e}")
            return JSONResponse({"status": "error", "error": str(e)}, status_code=500)

    async def _log_event_impl(
        event_type: str,
        description: str,
        source_agent: str = "claude-agent",
        metadata: Optional[dict] = None,
        resolution: Optional[str] = None
    ) -> dict:
        """Implementation of log_event (shared by MCP tool and REST API)."""
        # Valid event types
        valid_types = {
            "agent.chat.start", "agent.chat.complete", "agent.tool.call",
            "agent.error", "validation.complete", "runbook.executed",
            "feedback.received", "pattern.detected", "autonomy.upgrade"
        }
        if event_type not in valid_types:
            return {"status": "error", "error": f"Invalid event_type. Must be one of: {valid_types}"}

        event_id = str(uuid.uuid4())
        timestamp = datetime.now(timezone.utc).isoformat()

        # Generate embedding from description
        try:
            vector = await get_embedding(f"{event_type}: {description}")
        except Exception as e:
            return {"status": "error", "error": f"Failed to generate embedding: {str(e)}"}

        # Build payload
        payload = {
            "event_type": event_type,
            "description": description,
            "source_agent": source_agent,
            "timestamp": timestamp,
            "metadata": metadata or {},
            "resolution": resolution,
            "score": None,
            "feedback": None
        }

        # Upsert to Qdrant
        point = {"id": event_id, "vector": vector, "payload": payload}
        success = await qdrant_upsert("agent_events", [point])

        if success:
            logger.info(f"Logged event {event_id}: {event_type}")
            return {"status": "ok", "event_id": event_id, "timestamp": timestamp}
        else:
            return {"status": "error", "error": "Failed to store event in Qdrant"}

    async def rest_api_update_event(request: Request):
        """Update an event with feedback/outcome (REST API wrapper for Forever Learning System)."""
        try:
            import json as json_module
            body = await request.body()
            data = json_module.loads(body)

            event_id = data.get("event_id")
            if not event_id:
                return JSONResponse(
                    {"status": "error", "error": "Missing required field: event_id"},
                    status_code=400
                )

            score = data.get("score")
            feedback = data.get("feedback")
            resolution = data.get("resolution")

            if score is None and feedback is None and resolution is None:
                return JSONResponse(
                    {"status": "error", "error": "Must provide at least one of: score, feedback, resolution"},
                    status_code=400
                )

            result = await _update_event_impl(event_id, score, feedback, resolution)
            return JSONResponse(result)
        except Exception as e:
            logger.error(f"Error updating event: {e}")
            return JSONResponse({"status": "error", "error": str(e)}, status_code=500)

    async def _update_event_impl(
        event_id: str,
        score: Optional[float] = None,
        feedback: Optional[str] = None,
        resolution: Optional[str] = None
    ) -> dict:
        """Implementation of update_event (shared by MCP tool and REST API)."""
        # Get current event
        async with httpx.AsyncClient(timeout=30.0) as client:
            response = await client.post(
                f"{QDRANT_URL}/collections/agent_events/points",
                json={"ids": [event_id], "with_payload": True, "with_vector": True}
            )
            if response.status_code != 200:
                return {"status": "error", "error": "Event not found"}

            points = response.json().get("result", [])
            if not points:
                return {"status": "error", "error": f"Event {event_id} not found"}

            point = points[0]
            payload = point.get("payload", {})
            vector = point.get("vector")

            # Update fields
            if score is not None:
                payload["score"] = score
            if feedback is not None:
                payload["feedback"] = feedback
            if resolution is not None:
                payload["resolution"] = resolution

            # Upsert back
            updated_point = {"id": event_id, "vector": vector, "payload": payload}
            success = await qdrant_upsert("agent_events", [updated_point])

            if success:
                logger.info(f"Updated event {event_id}: score={score}, resolution={resolution}")
                return {"status": "ok", "event_id": event_id, "updated": {"score": score, "feedback": feedback, "resolution": resolution}}
            else:
                return {"status": "error", "error": "Failed to update event"}

    # ============================================================================
    # MAIN
    # ============================================================================

    def main():
        port = int(os.environ.get("PORT", "8000"))
        logger.info(f"Starting knowledge MCP on port {port}")
        logger.info("Collections: runbooks, documentation, entities, decisions, agent_events")
        logger.info(f"Qdrant URL: {QDRANT_URL}")
        logger.info(f"LiteLLM URL: {LITELLM_URL}")

        rest_routes = [
            Route("/health", rest_health, methods=["GET"]),
            Route("/api/search", rest_api_search, methods=["GET"]),
            Route("/api/collections", rest_api_collections, methods=["GET"]),
            Route("/api/entity", rest_api_entity, methods=["GET"]),
            Route("/api/runbook", rest_api_runbook, methods=["GET"]),
            Route("/api/runbooks", rest_api_runbooks, methods=["GET"]),
            Route("/api/log_event", rest_api_log_event, methods=["POST"]),
            Route("/api/update_event", rest_api_update_event, methods=["POST"]),
        ]

        mcp_app = mcp.http_app()
        app = Starlette(
            routes=rest_routes + [Mount("/", app=mcp_app)],
            lifespan=mcp_app.lifespan
        )
        uvicorn.run(app, host="0.0.0.0", port=port)

    if __name__ == "__main__":
        main()

  requirements.txt: |
    fastmcp>=2.7.0
    pydantic>=2.11.0
    httpx>=0.28.0
    uvicorn>=0.34.0
    starlette>=0.40.0
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: knowledge-mcp
  namespace: ai-platform
  labels:
    app: knowledge-mcp
    component: mcp
spec:
  replicas: 1
  selector:
    matchLabels:
      app: knowledge-mcp
  template:
    metadata:
      labels:
        app: knowledge-mcp
        component: mcp
    spec:
      initContainers:
        - name: install-deps
          image: python:3.11-slim
          command: ['sh', '-c', 'pip install --target=/app/deps -r /code/requirements.txt']
          volumeMounts:
            - name: code
              mountPath: /code
            - name: deps
              mountPath: /app/deps
      containers:
        - name: mcp-server
          image: python:3.11-slim
          command: ['sh', '-c', 'cd /app && PYTHONPATH=/app/deps python /code/main.py']
          ports:
            - containerPort: 8000
              name: http
          env:
            - name: PORT
              value: "8000"
            - name: QDRANT_URL
              value: "http://qdrant:6333"
            - name: LITELLM_URL
              value: "http://litellm:4000"
            - name: EMBEDDING_MODEL
              value: "embeddings"
          volumeMounts:
            - name: code
              mountPath: /code
            - name: deps
              mountPath: /app/deps
          resources:
            requests:
              memory: "128Mi"
              cpu: "100m"
            limits:
              memory: "256Mi"
              cpu: "500m"
          readinessProbe:
            tcpSocket:
              port: 8000
            initialDelaySeconds: 30
            periodSeconds: 10
            timeoutSeconds: 5
          livenessProbe:
            tcpSocket:
              port: 8000
            initialDelaySeconds: 60
            periodSeconds: 30
            timeoutSeconds: 5
      volumes:
        - name: code
          configMap:
            name: knowledge-mcp-code
        - name: deps
          emptyDir: {}
---
apiVersion: v1
kind: Service
metadata:
  name: knowledge-mcp
  namespace: ai-platform
  labels:
    app: knowledge-mcp
    component: mcp
spec:
  type: NodePort
  selector:
    app: knowledge-mcp
  ports:
    - port: 8000
      targetPort: 8000
      nodePort: 31084
      name: http
