---
apiVersion: v1
kind: ConfigMap
metadata:
  name: keep-mcp-code
  namespace: ai-platform
data:
  main.py: |
    #!/usr/bin/env python3
    """Keep MCP server for alert aggregation platform management.

    Keep is the central hub for all alerts before forwarding to LangGraph.
    Provides tools for providers, workflows, alerts, incidents, deduplication,
    and correlation management.
    """
    import os
    import json
    import logging
    from typing import Optional, List, Dict, Any
    from enum import Enum
    from datetime import datetime
    from fastmcp import FastMCP
    from pydantic import BaseModel, Field, ConfigDict
    import httpx

    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger(__name__)

    KEEP_URL = os.environ.get("KEEP_URL", "http://keep.keep.svc.cluster.local:8080")
    KEEP_API_KEY = os.environ.get("KEEP_API_KEY", "")

    mcp = FastMCP(
        name="keep_mcp",
        instructions="""MCP server for Keep alert aggregation platform.

Keep receives alerts from AlertManager, Gatus, TrueNAS, Proxmox, etc. and
forwards them to LangGraph after deduplication and correlation.

Capabilities:
- Providers: Manage webhook/notification providers
- Workflows: Create alert routing and automation workflows
- Alerts: View and manage incoming alerts
- Incidents: View correlated incidents
- Deduplication: Configure alert deduplication rules
- Correlation: Configure incident correlation rules
"""
    )

    # ==========================================================================
    # Models
    # ==========================================================================

    class ResponseFormat(str, Enum):
        MARKDOWN = "markdown"
        JSON = "json"

    class BaseInput(BaseModel):
        model_config = ConfigDict(str_strip_whitespace=True)
        response_format: ResponseFormat = Field(default=ResponseFormat.MARKDOWN, description="Output format")

    class AlertsInput(BaseModel):
        model_config = ConfigDict(str_strip_whitespace=True)
        response_format: ResponseFormat = Field(default=ResponseFormat.MARKDOWN, description="Output format")
        limit: int = Field(default=50, description="Max alerts to return", ge=1, le=500)
        severity: Optional[str] = Field(default=None, description="Filter by severity: critical, warning, info")
        status: Optional[str] = Field(default=None, description="Filter by status: firing, resolved, acknowledged")

    class IncidentsInput(BaseModel):
        model_config = ConfigDict(str_strip_whitespace=True)
        response_format: ResponseFormat = Field(default=ResponseFormat.MARKDOWN, description="Output format")
        limit: int = Field(default=50, description="Max incidents to return", ge=1, le=500)
        status: Optional[str] = Field(default=None, description="Filter by status: open, acknowledged, resolved")

    class AlertIdInput(BaseModel):
        model_config = ConfigDict(str_strip_whitespace=True)
        alert_id: str = Field(description="Alert ID (fingerprint)")

    class IncidentIdInput(BaseModel):
        model_config = ConfigDict(str_strip_whitespace=True)
        incident_id: str = Field(description="Incident ID")

    class WorkflowIdInput(BaseModel):
        model_config = ConfigDict(str_strip_whitespace=True)
        workflow_id: str = Field(description="Workflow ID")

    class ProviderIdInput(BaseModel):
        model_config = ConfigDict(str_strip_whitespace=True)
        provider_id: str = Field(description="Provider ID (e.g., langgraph-triage)")

    class WebhookProviderInput(BaseModel):
        model_config = ConfigDict(str_strip_whitespace=True)
        name: str = Field(description="Provider name (e.g., 'langgraph-webhook')")
        url: str = Field(description="Webhook URL to POST alerts to")
        headers: Optional[Dict[str, str]] = Field(default=None, description="Optional headers")

    class WorkflowInput(BaseModel):
        model_config = ConfigDict(str_strip_whitespace=True)
        name: str = Field(description="Workflow name")
        description: str = Field(default="", description="Workflow description")
        triggers: List[Dict[str, Any]] = Field(description="List of trigger conditions")
        actions: List[Dict[str, Any]] = Field(description="List of actions to execute")
        enabled: bool = Field(default=True, description="Whether workflow is enabled")

    class DeduplicationRuleInput(BaseModel):
        model_config = ConfigDict(str_strip_whitespace=True)
        name: str = Field(description="Rule name")
        description: str = Field(default="", description="Rule description")
        fingerprint_fields: List[str] = Field(description="Fields to use for fingerprint (e.g., ['alertname', 'namespace'])")
        enabled: bool = Field(default=True, description="Whether rule is enabled")

    class CorrelationRuleInput(BaseModel):
        model_config = ConfigDict(str_strip_whitespace=True)
        name: str = Field(description="Rule name")
        description: str = Field(default="", description="Rule description")
        condition: str = Field(description="Correlation condition expression")
        timeframe_seconds: int = Field(default=300, description="Time window for correlation (default 5 min)")
        enabled: bool = Field(default=True, description="Whether rule is enabled")

    # ==========================================================================
    # API Helpers
    # ==========================================================================

    def _get_headers() -> Dict[str, str]:
        """Get headers for Keep API requests."""
        headers = {
            "Content-Type": "application/json",
            "Accept": "application/json"
        }
        if KEEP_API_KEY:
            headers["X-API-KEY"] = KEEP_API_KEY
        return headers

    async def _keep_api(endpoint: str, method: str = "GET", data: dict = None) -> Dict[str, Any]:
        """Make authenticated request to Keep API."""
        async with httpx.AsyncClient(timeout=30.0) as client:
            url = f"{KEEP_URL}{endpoint}"
            headers = _get_headers()

            if method == "GET":
                response = await client.get(url, headers=headers)
            elif method == "POST":
                response = await client.post(url, headers=headers, json=data)
            elif method == "PUT":
                response = await client.put(url, headers=headers, json=data)
            elif method == "DELETE":
                response = await client.delete(url, headers=headers)
            else:
                raise ValueError(f"Unsupported method: {method}")

            response.raise_for_status()

            if response.text:
                return response.json()
            return {"status": "success"}

    def _handle_error(e: Exception) -> str:
        """Format error message with actionable guidance."""
        if isinstance(e, httpx.HTTPStatusError):
            status = e.response.status_code
            if status == 401:
                return "Error: Authentication failed. Check KEEP_API_KEY is set correctly."
            elif status == 403:
                return "Error: Access denied. API key may lack required permissions."
            elif status == 404:
                return f"Error: Resource not found. Check the ID exists in Keep."
            return f"Error: Keep API returned status {status}. Response: {e.response.text[:200]}"
        elif isinstance(e, httpx.TimeoutException):
            return "Error: Request timed out. Check connectivity to Keep (http://keep.keep.svc.cluster.local:8080)."
        elif isinstance(e, httpx.ConnectError):
            return "Error: Cannot connect to Keep. Verify Keep is running and accessible."
        return f"Error: {type(e).__name__}: {str(e)}"

    def _format_severity(severity: str) -> str:
        """Format severity with icon."""
        icons = {"critical": "[!]", "warning": "[W]", "info": "[i]"}
        return icons.get(severity.lower(), "[?]") if severity else "[?]"

    def _format_status(status: str) -> str:
        """Format status with icon."""
        icons = {"firing": "[FIRE]", "resolved": "[OK]", "acknowledged": "[ACK]", "open": "[OPEN]"}
        return icons.get(status.lower(), f"[{status}]") if status else "[?]"

    # ==========================================================================
    # Provider Tools
    # ==========================================================================

    @mcp.tool(
        name="keep_list_providers",
        annotations={"readOnlyHint": True, "destructiveHint": False, "idempotentHint": True, "openWorldHint": True}
    )
    async def keep_list_providers(params: BaseInput) -> str:
        """List all configured alert providers (webhook, slack, discord, etc.)."""
        try:
            result = await _keep_api("/providers")
            providers = result if isinstance(result, list) else result.get("providers", [])

            if params.response_format == ResponseFormat.JSON:
                return json.dumps({"providers": providers, "count": len(providers)}, indent=2)

            lines = ["# Keep Providers", "", f"Total: {len(providers)} provider(s)", ""]
            for p in providers:
                ptype = p.get("type", "unknown")
                pid = p.get("id", p.get("provider_id", "unknown"))
                installed = "[OK]" if p.get("installed") else "[ ]"
                lines.append(f"- {installed} **{pid}** ({ptype})")

            return "\n".join(lines)
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(
        name="keep_create_webhook_provider",
        annotations={"readOnlyHint": False, "destructiveHint": False, "idempotentHint": False, "openWorldHint": True}
    )
    async def keep_create_webhook_provider(params: WebhookProviderInput) -> str:
        """Create a webhook provider for forwarding alerts to external services."""
        try:
            data = {
                "provider_type": "webhook",
                "provider_id": params.name,
                "config": {
                    "url": params.url,
                    "headers": params.headers or {}
                }
            }
            result = await _keep_api("/providers/install", method="POST", data=data)
            return f"[OK] Created webhook provider `{params.name}` pointing to `{params.url}`"
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(
        name="keep_delete_provider",
        annotations={"readOnlyHint": False, "destructiveHint": True, "idempotentHint": False, "openWorldHint": True}
    )
    async def keep_delete_provider(params: ProviderIdInput) -> str:
        """Delete a provider by ID."""
        try:
            await _keep_api(f"/providers/{params.provider_id}", method="DELETE")
            return f"[OK] Deleted provider `{params.provider_id}`"
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(
        name="keep_test_provider",
        annotations={"readOnlyHint": False, "destructiveHint": False, "idempotentHint": True, "openWorldHint": True}
    )
    async def keep_test_provider(params: ProviderIdInput) -> str:
        """Test a provider connection."""
        try:
            result = await _keep_api(f"/providers/test", method="POST", data={"provider_id": params.provider_id})
            success = result.get("success", False)
            if success:
                return f"[OK] Provider `{params.provider_id}` test successful"
            else:
                msg = result.get("message", "Unknown error")
                return f"[ERR] Provider test failed: {msg}"
        except Exception as e:
            return _handle_error(e)

    # ==========================================================================
    # Workflow Tools
    # ==========================================================================

    @mcp.tool(
        name="keep_list_workflows",
        annotations={"readOnlyHint": True, "destructiveHint": False, "idempotentHint": True, "openWorldHint": True}
    )
    async def keep_list_workflows(params: BaseInput) -> str:
        """List all workflows for alert routing and automation."""
        try:
            result = await _keep_api("/workflows")
            workflows = result if isinstance(result, list) else result.get("workflows", [])

            if params.response_format == ResponseFormat.JSON:
                return json.dumps({"workflows": workflows, "count": len(workflows)}, indent=2)

            lines = ["# Keep Workflows", "", f"Total: {len(workflows)} workflow(s)", ""]
            for w in workflows:
                wid = w.get("id", "unknown")
                name = w.get("name", "Unnamed")
                enabled = "[ON]" if not w.get("is_disabled") else "[OFF]"
                desc = w.get("description", "")[:50]
                lines.append(f"- {enabled} **{name}** (id: {wid})")
                if desc:
                    lines.append(f"  {desc}")

            return "\n".join(lines)
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(
        name="keep_get_workflow",
        annotations={"readOnlyHint": True, "destructiveHint": False, "idempotentHint": True, "openWorldHint": True}
    )
    async def keep_get_workflow(params: WorkflowIdInput) -> str:
        """Get details of a specific workflow."""
        try:
            result = await _keep_api(f"/workflows/{params.workflow_id}")
            return json.dumps(result, indent=2)
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(
        name="keep_create_workflow",
        annotations={"readOnlyHint": False, "destructiveHint": False, "idempotentHint": False, "openWorldHint": True}
    )
    async def keep_create_workflow(params: WorkflowInput) -> str:
        """Create a new workflow for alert routing/automation."""
        try:
            data = {
                "name": params.name,
                "description": params.description,
                "triggers": params.triggers,
                "actions": params.actions,
                "is_disabled": not params.enabled
            }
            result = await _keep_api("/workflows", method="POST", data=data)
            wid = result.get("id", "unknown")
            return f"[OK] Created workflow `{params.name}` (id: {wid})"
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(
        name="keep_delete_workflow",
        annotations={"readOnlyHint": False, "destructiveHint": True, "idempotentHint": False, "openWorldHint": True}
    )
    async def keep_delete_workflow(params: WorkflowIdInput) -> str:
        """Delete a workflow."""
        try:
            await _keep_api(f"/workflows/{params.workflow_id}", method="DELETE")
            return f"[OK] Deleted workflow `{params.workflow_id}`"
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(
        name="keep_run_workflow",
        annotations={"readOnlyHint": False, "destructiveHint": False, "idempotentHint": False, "openWorldHint": True}
    )
    async def keep_run_workflow(params: WorkflowIdInput) -> str:
        """Manually trigger a workflow."""
        try:
            result = await _keep_api(f"/workflows/{params.workflow_id}/run", method="POST")
            return f"[OK] Triggered workflow `{params.workflow_id}`"
        except Exception as e:
            return _handle_error(e)

    # ==========================================================================
    # Alert Tools
    # ==========================================================================

    @mcp.tool(
        name="keep_list_alerts",
        annotations={"readOnlyHint": True, "destructiveHint": False, "idempotentHint": True, "openWorldHint": True}
    )
    async def keep_list_alerts(params: AlertsInput) -> str:
        """List alerts with optional filters."""
        try:
            endpoint = f"/alerts?limit={params.limit}"
            if params.severity:
                endpoint += f"&severity={params.severity}"
            if params.status:
                endpoint += f"&status={params.status}"

            result = await _keep_api(endpoint)
            alerts = result if isinstance(result, list) else result.get("items", result.get("alerts", []))

            if params.response_format == ResponseFormat.JSON:
                return json.dumps({"alerts": alerts, "count": len(alerts)}, indent=2)

            lines = ["# Keep Alerts", "", f"Showing {len(alerts)} alert(s)", ""]
            for a in alerts[:50]:
                aid = a.get("fingerprint", a.get("id", "unknown"))[:12]
                name = a.get("name", a.get("alertname", "Unknown"))
                severity = _format_severity(a.get("severity", ""))
                status = _format_status(a.get("status", ""))
                source = a.get("source", ["unknown"])[0] if isinstance(a.get("source"), list) else a.get("source", "unknown")
                lines.append(f"- {severity} {status} **{name}** ({source})")
                lines.append(f"  ID: `{aid}`")

            return "\n".join(lines)
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(
        name="keep_get_alert",
        annotations={"readOnlyHint": True, "destructiveHint": False, "idempotentHint": True, "openWorldHint": True}
    )
    async def keep_get_alert(params: AlertIdInput) -> str:
        """Get details of a specific alert."""
        try:
            result = await _keep_api(f"/alerts/{params.alert_id}")
            return json.dumps(result, indent=2)
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(
        name="keep_acknowledge_alert",
        annotations={"readOnlyHint": False, "destructiveHint": False, "idempotentHint": True, "openWorldHint": True}
    )
    async def keep_acknowledge_alert(params: AlertIdInput) -> str:
        """Acknowledge an alert."""
        try:
            await _keep_api(f"/alerts/{params.alert_id}/acknowledge", method="POST")
            return f"[OK] Acknowledged alert `{params.alert_id}`"
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(
        name="keep_resolve_alert",
        annotations={"readOnlyHint": False, "destructiveHint": False, "idempotentHint": True, "openWorldHint": True}
    )
    async def keep_resolve_alert(params: AlertIdInput) -> str:
        """Resolve an alert."""
        try:
            await _keep_api(f"/alerts/{params.alert_id}/resolve", method="POST")
            return f"[OK] Resolved alert `{params.alert_id}`"
        except Exception as e:
            return _handle_error(e)

    # ==========================================================================
    # Incident Tools (Correlation)
    # ==========================================================================

    @mcp.tool(
        name="keep_list_incidents",
        annotations={"readOnlyHint": True, "destructiveHint": False, "idempotentHint": True, "openWorldHint": True}
    )
    async def keep_list_incidents(params: IncidentsInput) -> str:
        """List incidents (correlated groups of alerts)."""
        try:
            endpoint = f"/incidents?limit={params.limit}"
            if params.status:
                endpoint += f"&status={params.status}"

            result = await _keep_api(endpoint)
            incidents = result if isinstance(result, list) else result.get("items", result.get("incidents", []))

            if params.response_format == ResponseFormat.JSON:
                return json.dumps({"incidents": incidents, "count": len(incidents)}, indent=2)

            lines = ["# Keep Incidents", "", f"Showing {len(incidents)} incident(s)", ""]
            for inc in incidents[:30]:
                iid = inc.get("id", "unknown")[:12]
                name = inc.get("name", "Unnamed Incident")
                status = _format_status(inc.get("status", "open"))
                alert_count = len(inc.get("alerts", []))
                lines.append(f"- {status} **{name}** ({alert_count} alerts)")
                lines.append(f"  ID: `{iid}`")

            return "\n".join(lines)
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(
        name="keep_get_incident",
        annotations={"readOnlyHint": True, "destructiveHint": False, "idempotentHint": True, "openWorldHint": True}
    )
    async def keep_get_incident(params: IncidentIdInput) -> str:
        """Get details of a specific incident including correlated alerts."""
        try:
            result = await _keep_api(f"/incidents/{params.incident_id}")
            return json.dumps(result, indent=2)
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(
        name="keep_acknowledge_incident",
        annotations={"readOnlyHint": False, "destructiveHint": False, "idempotentHint": True, "openWorldHint": True}
    )
    async def keep_acknowledge_incident(params: IncidentIdInput) -> str:
        """Acknowledge an incident."""
        try:
            await _keep_api(f"/incidents/{params.incident_id}/acknowledge", method="POST")
            return f"[OK] Acknowledged incident `{params.incident_id}`"
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(
        name="keep_resolve_incident",
        annotations={"readOnlyHint": False, "destructiveHint": False, "idempotentHint": True, "openWorldHint": True}
    )
    async def keep_resolve_incident(params: IncidentIdInput) -> str:
        """Resolve an incident."""
        try:
            await _keep_api(f"/incidents/{params.incident_id}/resolve", method="POST")
            return f"[OK] Resolved incident `{params.incident_id}`"
        except Exception as e:
            return _handle_error(e)

    # ==========================================================================
    # Deduplication Tools
    # ==========================================================================

    @mcp.tool(
        name="keep_list_dedup_rules",
        annotations={"readOnlyHint": True, "destructiveHint": False, "idempotentHint": True, "openWorldHint": True}
    )
    async def keep_list_dedup_rules(params: BaseInput) -> str:
        """List deduplication rules for alert fingerprinting."""
        try:
            result = await _keep_api("/deduplications")
            rules = result if isinstance(result, list) else result.get("rules", [])

            if params.response_format == ResponseFormat.JSON:
                return json.dumps({"rules": rules, "count": len(rules)}, indent=2)

            lines = ["# Deduplication Rules", "", f"Total: {len(rules)} rule(s)", ""]
            for r in rules:
                rid = r.get("id", "unknown")
                name = r.get("name", "Unnamed")
                fields = r.get("fingerprint_fields", [])
                enabled = "[ON]" if r.get("enabled", True) else "[OFF]"
                lines.append(f"- {enabled} **{name}** (id: {rid})")
                lines.append(f"  Fields: {', '.join(fields)}")

            return "\n".join(lines)
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(
        name="keep_create_dedup_rule",
        annotations={"readOnlyHint": False, "destructiveHint": False, "idempotentHint": False, "openWorldHint": True}
    )
    async def keep_create_dedup_rule(params: DeduplicationRuleInput) -> str:
        """Create a deduplication rule for alert fingerprinting.

        Example fingerprint_fields: ['alertname', 'namespace', 'pod'] will
        deduplicate alerts with the same alertname, namespace, and pod.
        """
        try:
            data = {
                "name": params.name,
                "description": params.description,
                "fingerprint_fields": params.fingerprint_fields,
                "enabled": params.enabled
            }
            result = await _keep_api("/deduplications", method="POST", data=data)
            rid = result.get("id", "unknown")
            return f"[OK] Created dedup rule `{params.name}` (id: {rid}) with fields: {', '.join(params.fingerprint_fields)}"
        except Exception as e:
            return _handle_error(e)

    # ==========================================================================
    # Correlation Tools
    # ==========================================================================

    @mcp.tool(
        name="keep_list_correlations",
        annotations={"readOnlyHint": True, "destructiveHint": False, "idempotentHint": True, "openWorldHint": True}
    )
    async def keep_list_correlations(params: BaseInput) -> str:
        """List correlation rules for grouping alerts into incidents."""
        try:
            result = await _keep_api("/rules")
            rules = result if isinstance(result, list) else result.get("rules", [])

            if params.response_format == ResponseFormat.JSON:
                return json.dumps({"rules": rules, "count": len(rules)}, indent=2)

            lines = ["# Correlation Rules", "", f"Total: {len(rules)} rule(s)", ""]
            for r in rules:
                rid = r.get("id", "unknown")
                name = r.get("name", "Unnamed")
                timeframe = r.get("timeframe_seconds", 300)
                enabled = "[ON]" if r.get("enabled", True) else "[OFF]"
                lines.append(f"- {enabled} **{name}** (id: {rid})")
                lines.append(f"  Timeframe: {timeframe}s")

            return "\n".join(lines)
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(
        name="keep_create_correlation",
        annotations={"readOnlyHint": False, "destructiveHint": False, "idempotentHint": False, "openWorldHint": True}
    )
    async def keep_create_correlation(params: CorrelationRuleInput) -> str:
        """Create a correlation rule to group related alerts into incidents.

        Example condition: "(alertname == 'PodCrashLooping') && (namespace == 'ai-platform')"
        Groups matching alerts within the timeframe into a single incident.
        """
        try:
            data = {
                "name": params.name,
                "description": params.description,
                "condition": params.condition,
                "timeframe_seconds": params.timeframe_seconds,
                "enabled": params.enabled
            }
            result = await _keep_api("/rules", method="POST", data=data)
            rid = result.get("id", "unknown")
            return f"[OK] Created correlation rule `{params.name}` (id: {rid}) with {params.timeframe_seconds}s window"
        except Exception as e:
            return _handle_error(e)

    # ==========================================================================
    # Settings Tools
    # ==========================================================================

    @mcp.tool(
        name="keep_list_api_keys",
        annotations={"readOnlyHint": True, "destructiveHint": False, "idempotentHint": True, "openWorldHint": True}
    )
    async def keep_list_api_keys(params: BaseInput) -> str:
        """List API keys (names only, not values)."""
        try:
            result = await _keep_api("/settings/apikeys")
            keys = result if isinstance(result, list) else result.get("apikeys", [])

            if params.response_format == ResponseFormat.JSON:
                return json.dumps({"apikeys": keys, "count": len(keys)}, indent=2)

            lines = ["# API Keys", "", f"Total: {len(keys)} key(s)", ""]
            for k in keys:
                name = k.get("name", k.get("reference", "unknown"))
                created = k.get("created_at", "unknown")
                lines.append(f"- **{name}** (created: {created})")

            return "\n".join(lines)
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(
        name="keep_get_webhook_settings",
        annotations={"readOnlyHint": True, "destructiveHint": False, "idempotentHint": True, "openWorldHint": True}
    )
    async def keep_get_webhook_settings(params: BaseInput) -> str:
        """Get webhook settings including endpoints for receiving alerts."""
        try:
            result = await _keep_api("/settings/webhook")

            if params.response_format == ResponseFormat.JSON:
                return json.dumps(result, indent=2)

            lines = ["# Webhook Settings", ""]
            for key, value in result.items():
                lines.append(f"- **{key}**: `{value}`")

            return "\n".join(lines)
        except Exception as e:
            return _handle_error(e)

    # ==========================================================================
    # Helper Tools
    # ==========================================================================

    @mcp.tool(
        name="keep_setup_langgraph_integration",
        annotations={"readOnlyHint": False, "destructiveHint": False, "idempotentHint": False, "openWorldHint": True}
    )
    async def keep_setup_langgraph_integration(params: BaseInput) -> str:
        """One-click setup: Create webhook provider and workflow to forward all alerts to LangGraph.

        This creates:
        1. A webhook provider 'langgraph-triage' pointing to LangGraph's /alert endpoint
        2. A workflow that forwards all alerts to this provider
        """
        try:
            langgraph_url = os.environ.get("LANGGRAPH_URL", "http://langgraph.ai-platform.svc.cluster.local:8000/alert")

            # Step 1: Create webhook provider
            provider_data = {
                "provider_type": "webhook",
                "provider_id": "langgraph-triage",
                "config": {
                    "url": langgraph_url,
                    "headers": {"Content-Type": "application/json"}
                }
            }
            try:
                await _keep_api("/providers/install", method="POST", data=provider_data)
                provider_status = "[OK] Created"
            except Exception as e:
                if "already exists" in str(e).lower():
                    provider_status = "[OK] Already exists"
                else:
                    return f"[ERR] Failed to create provider: {_handle_error(e)}"

            # Step 2: Create workflow to forward all alerts
            workflow_data = {
                "name": "Forward to LangGraph",
                "description": "Forward all alerts to LangGraph for AI triage",
                "triggers": [
                    {
                        "type": "alert",
                        "filters": []  # All alerts
                    }
                ],
                "actions": [
                    {
                        "type": "webhook",
                        "provider": "langgraph-triage",
                        "config": {
                            "body": {
                                "id": "{{ alert.id }}",
                                "alertname": "{{ alert.name }}",
                                "severity": "{{ alert.severity }}",
                                "description": "{{ alert.description }}",
                                "source": "{{ alert.source }}",
                                "labels": "{{ alert.labels }}",
                                "status": "{{ alert.status }}"
                            }
                        }
                    }
                ],
                "is_disabled": False
            }
            try:
                result = await _keep_api("/workflows", method="POST", data=workflow_data)
                workflow_status = f"[OK] Created (id: {result.get('id', 'unknown')})"
            except Exception as e:
                if "already exists" in str(e).lower():
                    workflow_status = "[OK] Already exists"
                else:
                    return f"[ERR] Failed to create workflow: {_handle_error(e)}"

            lines = [
                "# LangGraph Integration Setup",
                "",
                f"**Provider**: langgraph-triage - {provider_status}",
                f"**Workflow**: Forward to LangGraph - {workflow_status}",
                f"**Target URL**: `{langgraph_url}`",
                "",
                "All alerts will now be forwarded to LangGraph for AI triage."
            ]
            return "\n".join(lines)
        except Exception as e:
            return _handle_error(e)

    @mcp.tool(
        name="keep_health",
        annotations={"readOnlyHint": True, "destructiveHint": False, "idempotentHint": True, "openWorldHint": True}
    )
    async def keep_health(params: BaseInput) -> str:
        """Check Keep server health and connectivity."""
        try:
            result = await _keep_api("/healthcheck")
            healthy = True
        except Exception as e:
            healthy = False
            result = {"error": str(e)}

        if params.response_format == ResponseFormat.JSON:
            return json.dumps({
                "healthy": healthy,
                "keep_url": KEEP_URL,
                "api_key_configured": bool(KEEP_API_KEY),
                "details": result
            }, indent=2)

        status = "[OK] Healthy" if healthy else "[ERR] Unhealthy"
        api_key = "[OK] Configured" if KEEP_API_KEY else "[WARN] Not configured"

        lines = [
            "# Keep Health Check",
            "",
            f"**Status**: {status}",
            f"**URL**: `{KEEP_URL}`",
            f"**API Key**: {api_key}"
        ]

        if not healthy:
            lines.append(f"**Error**: {result.get('error', 'Unknown')}")

        return "\n".join(lines)

    # ==========================================================================
    # REST API for discovery/automation
    # ==========================================================================

    from starlette.applications import Starlette
    from starlette.routing import Route, Mount
    from starlette.responses import JSONResponse

    async def rest_health(request):
        """Health check endpoint."""
        try:
            await _keep_api("/healthcheck")
            keep_ok = True
        except:
            keep_ok = False

        return JSONResponse({
            "status": "healthy",
            "keep_connected": keep_ok,
            "api_key_configured": bool(KEEP_API_KEY)
        })

    async def rest_alerts(request):
        """REST endpoint to list recent alerts."""
        try:
            limit = int(request.query_params.get("limit", "20"))
            result = await _keep_api(f"/alerts?limit={limit}")
            return JSONResponse({"status": "ok", "data": result})
        except Exception as e:
            return JSONResponse({"status": "error", "message": str(e)}, status_code=500)

    async def rest_incidents(request):
        """REST endpoint to list incidents."""
        try:
            limit = int(request.query_params.get("limit", "20"))
            result = await _keep_api(f"/incidents?limit={limit}")
            return JSONResponse({"status": "ok", "data": result})
        except Exception as e:
            return JSONResponse({"status": "error", "message": str(e)}, status_code=500)

    if __name__ == "__main__":
        import uvicorn
        rest_routes = [
            Route("/health", rest_health, methods=["GET"]),
            Route("/api/alerts", rest_alerts, methods=["GET"]),
            Route("/api/incidents", rest_incidents, methods=["GET"]),
        ]
        mcp_app = mcp.http_app()
        app = Starlette(
            routes=rest_routes + [Mount("/", app=mcp_app)],
            lifespan=mcp_app.lifespan
        )
        uvicorn.run(app, host="0.0.0.0", port=8000)
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: keep-mcp
  namespace: ai-platform
spec:
  replicas: 1
  selector:
    matchLabels:
      app: keep-mcp
  template:
    metadata:
      labels:
        app: keep-mcp
    spec:
      containers:
        - name: keep-mcp
          image: python:3.11-slim
          command: ["sh", "-c"]
          args:
            - pip install --no-cache-dir fastmcp httpx uvicorn starlette && python /app/main.py
          ports:
            - containerPort: 8000
          env:
            - name: KEEP_URL
              value: "http://keep.keep.svc.cluster.local:8080"
            - name: KEEP_API_KEY
              valueFrom:
                secretKeyRef:
                  name: mcp-keep
                  key: api_key
            - name: LANGGRAPH_URL
              value: "http://langgraph.ai-platform.svc.cluster.local:8000/alert"
          volumeMounts:
            - name: code
              mountPath: /app
          resources:
            requests: {memory: "128Mi", cpu: "100m"}
            limits: {memory: "256Mi", cpu: "500m"}
          livenessProbe:
            httpGet:
              path: /health
              port: 8000
            initialDelaySeconds: 60
            periodSeconds: 30
          readinessProbe:
            httpGet:
              path: /health
              port: 8000
            initialDelaySeconds: 30
            periodSeconds: 10
      volumes:
        - name: code
          configMap:
            name: keep-mcp-code
---
apiVersion: v1
kind: Service
metadata:
  name: keep-mcp
  namespace: ai-platform
spec:
  type: NodePort
  selector:
    app: keep-mcp
  ports:
    - port: 8000
      targetPort: 8000
      nodePort: 31106
