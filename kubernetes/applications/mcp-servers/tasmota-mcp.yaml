apiVersion: v1
kind: ConfigMap
metadata:
  name: tasmota-mcp-code
  namespace: ai-platform
  labels:
    app: tasmota-mcp
data:
  main.py: |
    #!/usr/bin/env python3
    """Tasmota MCP server for smart device control and configuration."""
    import os
    import json
    import logging
    import asyncio
    from pathlib import Path
    from typing import List, Optional, Dict, Any
    from fastmcp import FastMCP
    import httpx
    from starlette.applications import Starlette
    from starlette.routing import Route, Mount
    from starlette.responses import JSONResponse
    from starlette.requests import Request
    import uvicorn

    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger(__name__)

    # Configuration
    DEVICES_FILE = os.environ.get("DEVICES_FILE", "/data/devices.json")
    INITIAL_DEVICES = os.environ.get("TASMOTA_DEVICES", "")
    COMMAND_TIMEOUT = float(os.environ.get("COMMAND_TIMEOUT", "10.0"))

    mcp = FastMCP(
        name="tasmota-mcp",
        instructions="""MCP server for Tasmota smart device control.
        Provides tools to control power, configure WiFi/MQTT, and manage devices.
        Tasmota devices expose HTTP API at /cm?cmnd=<command>.
        Common commands: Power, Status, WifiConfig, MqttHost, Upgrade."""
    )

    def load_devices() -> Dict[str, dict]:
        """Load devices from persistent storage."""
        devices = {}
        if Path(DEVICES_FILE).exists():
            try:
                with open(DEVICES_FILE, "r") as f:
                    devices = json.load(f)
                logger.info(f"Loaded {len(devices)} devices from {DEVICES_FILE}")
            except Exception as e:
                logger.error(f"Failed to load devices: {e}")
        if INITIAL_DEVICES:
            for ip in INITIAL_DEVICES.split(","):
                ip = ip.strip()
                if ip and ip not in devices:
                    devices[ip] = {"ip": ip}
                    logger.info(f"Added initial device: {ip}")
        return devices

    def save_devices(devices: Dict[str, dict]) -> None:
        """Save devices to persistent storage."""
        try:
            Path(DEVICES_FILE).parent.mkdir(parents=True, exist_ok=True)
            with open(DEVICES_FILE, "w") as f:
                json.dump(devices, f, indent=2)
            logger.info(f"Saved {len(devices)} devices to {DEVICES_FILE}")
        except Exception as e:
            logger.error(f"Failed to save devices: {e}")

    DEVICES = load_devices()

    async def tasmota_cmd(ip: str, command: str, timeout: float = COMMAND_TIMEOUT) -> dict:
        """Execute a Tasmota command via HTTP API."""
        url = f"http://{ip}/cm?cmnd={command}"
        try:
            async with httpx.AsyncClient(timeout=timeout) as client:
                response = await client.get(url)
                response.raise_for_status()
                return {"success": True, "ip": ip, "command": command, "response": response.json()}
        except httpx.TimeoutException:
            return {"success": False, "ip": ip, "command": command, "error": f"Timeout connecting to {ip}"}
        except httpx.HTTPStatusError as e:
            return {"success": False, "ip": ip, "command": command, "error": f"HTTP {e.response.status_code}"}
        except Exception as e:
            return {"success": False, "ip": ip, "command": command, "error": str(e)}

    # ==========================================================================
    # DEVICE MANAGEMENT
    # ==========================================================================

    @mcp.tool()
    async def tasmota_list_devices() -> List[dict]:
        """List all registered Tasmota devices."""
        return list(DEVICES.values())

    @mcp.tool()
    async def tasmota_add_device(ip: str, name: Optional[str] = None) -> str:
        """Add a Tasmota device by IP address."""
        if ip in DEVICES:
            return f"Device {ip} already registered"
        result = await tasmota_cmd(ip, "Status%200")
        if not result["success"]:
            return f"Failed to reach device at {ip}: {result.get('error')}"
        device = {"ip": ip, "name": name}
        if result.get("response"):
            status = result["response"].get("Status", {})
            fn = status.get("FriendlyName", [ip])
            device["name"] = name or (fn[0] if isinstance(fn, list) else fn)
            device["module"] = status.get("Module")
            net = result["response"].get("StatusNET", {})
            device["hostname"] = net.get("Hostname")
            device["mac"] = net.get("Mac")
            fw = result["response"].get("StatusFWR", {})
            device["firmware"] = fw.get("Version")
        DEVICES[ip] = device
        save_devices(DEVICES)
        return f"Added device: {device.get('name', ip)} ({ip})"

    @mcp.tool()
    async def tasmota_remove_device(ip: str) -> str:
        """Remove a Tasmota device from the registry."""
        if ip not in DEVICES:
            return f"Device {ip} not found"
        device = DEVICES.pop(ip)
        save_devices(DEVICES)
        return f"Removed device: {device.get('name', ip)}"

    @mcp.tool()
    async def tasmota_discover(network: str = "192.168.1", start: int = 1, end: int = 254, timeout: float = 2.0) -> List[dict]:
        """Scan network for Tasmota devices."""
        discovered = []
        async def check(ip):
            result = await tasmota_cmd(ip, "Status", timeout=timeout)
            if result["success"] and result.get("response"):
                status = result["response"].get("Status", {})
                fn = status.get("FriendlyName", [ip])
                name = fn[0] if isinstance(fn, list) else fn
                return {"ip": ip, "name": name}
            return None
        batch_size = 20
        for i in range(start, end + 1, batch_size):
            batch_end = min(i + batch_size, end + 1)
            tasks = [check(f"{network}.{j}") for j in range(i, batch_end)]
            results = await asyncio.gather(*tasks)
            for r in results:
                if r:
                    discovered.append(r)
                    logger.info(f"Discovered Tasmota: {r['ip']} ({r['name']})")
        return discovered

    # ==========================================================================
    # POWER CONTROL
    # ==========================================================================

    @mcp.tool()
    async def tasmota_power(ip: str, action: str = "toggle", relay: int = 1) -> str:
        """Control device power state. action: on, off, toggle, blink. relay: 1-based for multi-relay."""
        action_map = {"on": "1", "off": "0", "toggle": "2", "blink": "3"}
        if action.lower() not in action_map:
            return f"Invalid action: {action}. Use: on, off, toggle, blink"
        cmd = f"Power{relay}%20{action_map[action.lower()]}"
        result = await tasmota_cmd(ip, cmd)
        if not result["success"]:
            return f"Failed: {result.get('error')}"
        power_key = f"POWER{relay}" if relay > 1 else "POWER"
        state = result.get("response", {}).get(power_key, result.get("response", {}).get("POWER", "unknown"))
        return f"Power{relay}: {state}"

    @mcp.tool()
    async def tasmota_power_all(action: str = "toggle") -> List[dict]:
        """Control power on all registered devices."""
        results = []
        for ip in DEVICES:
            result = await tasmota_power(ip, action)
            results.append({"ip": ip, "result": result})
        return results

    # ==========================================================================
    # STATUS
    # ==========================================================================

    @mcp.tool()
    async def tasmota_status(ip: str) -> dict:
        """Get comprehensive device status."""
        result = await tasmota_cmd(ip, "Status%200")
        if not result["success"]:
            return {"ip": ip, "name": DEVICES.get(ip, {}).get("name", ip), "power": "unavailable", "error": result.get("error")}
        resp = result.get("response", {})
        status = resp.get("Status", {})
        sts = resp.get("StatusSTS", {})
        net = resp.get("StatusNET", {})
        fwr = resp.get("StatusFWR", {})
        power = sts.get("POWER", sts.get("POWER1", "unknown"))
        return {
            "ip": ip,
            "name": status.get("DeviceName", DEVICES.get(ip, {}).get("name", ip)),
            "power": power,
            "wifi_ssid": net.get("SSId"),
            "wifi_signal": net.get("Signal"),
            "uptime": sts.get("Uptime"),
            "firmware": fwr.get("Version"),
            "mqtt_connected": sts.get("MqttCount", 0) > 0
        }

    @mcp.tool()
    async def tasmota_status_all() -> List[dict]:
        """Get status of all registered devices."""
        tasks = [tasmota_status(ip) for ip in DEVICES]
        return await asyncio.gather(*tasks)

    # ==========================================================================
    # CONFIGURATION
    # ==========================================================================

    @mcp.tool()
    async def tasmota_wifi_config(ip: str, ssid: Optional[str] = None, password: Optional[str] = None, ssid2: Optional[str] = None, password2: Optional[str] = None) -> str:
        """Configure WiFi settings. If no args, show current config."""
        results = []
        if ssid:
            r = await tasmota_cmd(ip, f"SSID1%20{ssid}")
            results.append(f"SSID1: {'OK' if r['success'] else r.get('error')}")
        if password:
            r = await tasmota_cmd(ip, f"Password1%20{password}")
            results.append(f"Password1: {'OK' if r['success'] else r.get('error')}")
        if ssid2:
            r = await tasmota_cmd(ip, f"SSID2%20{ssid2}")
            results.append(f"SSID2: {'OK' if r['success'] else r.get('error')}")
        if password2:
            r = await tasmota_cmd(ip, f"Password2%20{password2}")
            results.append(f"Password2: {'OK' if r['success'] else r.get('error')}")
        if not results:
            result = await tasmota_cmd(ip, "SSID")
            if result["success"]:
                return f"Current WiFi: {result.get('response')}"
            return f"Failed to get WiFi config: {result.get('error')}"
        return "; ".join(results)

    @mcp.tool()
    async def tasmota_mqtt_config(ip: str, host: Optional[str] = None, port: Optional[int] = None, user: Optional[str] = None, password: Optional[str] = None, topic: Optional[str] = None) -> str:
        """Configure MQTT settings. If no args, show current config."""
        results = []
        if host:
            r = await tasmota_cmd(ip, f"MqttHost%20{host}")
            results.append(f"MqttHost: {'OK' if r['success'] else r.get('error')}")
        if port:
            r = await tasmota_cmd(ip, f"MqttPort%20{port}")
            results.append(f"MqttPort: {'OK' if r['success'] else r.get('error')}")
        if user:
            r = await tasmota_cmd(ip, f"MqttUser%20{user}")
            results.append(f"MqttUser: {'OK' if r['success'] else r.get('error')}")
        if password:
            r = await tasmota_cmd(ip, f"MqttPassword%20{password}")
            results.append(f"MqttPassword: {'OK' if r['success'] else r.get('error')}")
        if topic:
            r = await tasmota_cmd(ip, f"Topic%20{topic}")
            results.append(f"Topic: {'OK' if r['success'] else r.get('error')}")
        if not results:
            result = await tasmota_cmd(ip, "Status%206")
            if result["success"]:
                mqtt = result.get("response", {}).get("StatusMQT", {})
                return f"MQTT: Host={mqtt.get('MqttHost')}, Port={mqtt.get('MqttPort')}, Topic={mqtt.get('Topic')}"
            return f"Failed to get MQTT config: {result.get('error')}"
        return "; ".join(results)

    @mcp.tool()
    async def tasmota_set_name(ip: str, name: str) -> str:
        """Set device friendly name."""
        result = await tasmota_cmd(ip, f"DeviceName%20{name}")
        if result["success"]:
            if ip in DEVICES:
                DEVICES[ip]["name"] = name
                save_devices(DEVICES)
            return f"Device name set to: {name}"
        return f"Failed: {result.get('error')}"

    # ==========================================================================
    # ADVANCED
    # ==========================================================================

    @mcp.tool()
    async def tasmota_command(ip: str, command: str) -> dict:
        """Execute any Tasmota command directly. command: e.g., 'Status 0', 'Backlog Power ON; Delay 100; Power OFF'"""
        cmd = command.replace(" ", "%20")
        return await tasmota_cmd(ip, cmd)

    @mcp.tool()
    async def tasmota_upgrade(ip: str, url: Optional[str] = None) -> str:
        """Trigger firmware upgrade. url: OTA firmware URL (optional, uses default if not specified)."""
        if url:
            result = await tasmota_cmd(ip, f"OtaUrl%20{url}")
            if not result["success"]:
                return f"Failed to set OTA URL: {result.get('error')}"
        result = await tasmota_cmd(ip, "Upgrade%201")
        if result["success"]:
            return f"Upgrade initiated on {ip}. Device will restart when complete."
        return f"Failed to start upgrade: {result.get('error')}"

    @mcp.tool()
    async def tasmota_restart(ip: str) -> str:
        """Restart the device."""
        result = await tasmota_cmd(ip, "Restart%201")
        if result["success"]:
            return f"Restart command sent to {ip}"
        return f"Failed: {result.get('error')}"

    @mcp.tool()
    async def tasmota_get_sensors(ip: str) -> dict:
        """Get sensor readings (temperature, humidity, energy, etc.)."""
        result = await tasmota_cmd(ip, "Status%2010")
        if result["success"]:
            return result.get("response", {}).get("StatusSNS", {})
        return {"error": result.get("error")}

    @mcp.tool()
    async def tasmota_get_energy(ip: str) -> dict:
        """Get energy monitoring data (voltage, current, power, energy)."""
        result = await tasmota_cmd(ip, "Status%208")
        if result["success"]:
            return result.get("response", {}).get("StatusSNS", {}).get("ENERGY", {})
        return {"error": result.get("error")}

    # ==========================================================================
    # REST API
    # ==========================================================================

    async def rest_health(request: Request):
        return JSONResponse({"status": "healthy", "devices": len(DEVICES)})

    async def rest_devices(request: Request):
        try:
            data = await tasmota_list_devices()
            return JSONResponse({"status": "ok", "data": data, "count": len(data)})
        except Exception as e:
            return JSONResponse({"status": "error", "error": str(e)}, status_code=500)

    async def rest_status(request: Request):
        try:
            data = await tasmota_status_all()
            return JSONResponse({"status": "ok", "data": data, "count": len(data)})
        except Exception as e:
            return JSONResponse({"status": "error", "error": str(e)}, status_code=500)

    # ==========================================================================
    # MAIN
    # ==========================================================================

    def main():
        port = int(os.environ.get("PORT", "8000"))
        logger.info(f"Starting tasmota MCP on port {port}")
        logger.info(f"Registered devices: {len(DEVICES)}")

        rest_routes = [
            Route("/health", rest_health, methods=["GET"]),
            Route("/api/devices", rest_devices, methods=["GET"]),
            Route("/api/status", rest_status, methods=["GET"]),
        ]

        mcp_app = mcp.http_app()
        app = Starlette(
            routes=rest_routes + [Mount("/", app=mcp_app)],
            lifespan=mcp_app.lifespan
        )
        uvicorn.run(app, host="0.0.0.0", port=port)

    if __name__ == "__main__":
        main()

  requirements.txt: |
    fastmcp>=2.7.0
    pydantic>=2.11.0
    httpx>=0.28.0
    uvicorn>=0.34.0
    starlette>=0.40.0
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: tasmota-mcp
  namespace: ai-platform
  labels:
    app: tasmota-mcp
    component: mcp
spec:
  replicas: 1
  selector:
    matchLabels:
      app: tasmota-mcp
  template:
    metadata:
      labels:
        app: tasmota-mcp
        component: mcp
    spec:
      initContainers:
        - name: install-deps
          image: python:3.11-slim
          command: ['sh', '-c', 'pip install --target=/app/deps -r /code/requirements.txt']
          volumeMounts:
            - name: code
              mountPath: /code
            - name: deps
              mountPath: /app/deps
      containers:
        - name: mcp-server
          image: python:3.11-slim
          command: ['sh', '-c', 'cd /app && PYTHONPATH=/app/deps python /code/main.py']
          ports:
            - containerPort: 8000
              name: http
          env:
            - name: PORT
              value: "8000"
            - name: DEVICES_FILE
              value: "/data/devices.json"
            - name: TASMOTA_DEVICES
              value: ""  # Comma-separated IPs for initial devices
            - name: COMMAND_TIMEOUT
              value: "10.0"
          volumeMounts:
            - name: code
              mountPath: /code
            - name: deps
              mountPath: /app/deps
            - name: data
              mountPath: /data
          resources:
            requests:
              memory: "128Mi"
              cpu: "100m"
            limits:
              memory: "256Mi"
              cpu: "500m"
          readinessProbe:
            httpGet:
              path: /health
              port: 8000
            initialDelaySeconds: 30
            periodSeconds: 10
            timeoutSeconds: 5
          livenessProbe:
            httpGet:
              path: /health
              port: 8000
            initialDelaySeconds: 60
            periodSeconds: 30
            timeoutSeconds: 5
      volumes:
        - name: code
          configMap:
            name: tasmota-mcp-code
        - name: deps
          emptyDir: {}
        - name: data
          emptyDir: {}
---
apiVersion: v1
kind: Service
metadata:
  name: tasmota-mcp
  namespace: ai-platform
  labels:
    app: tasmota-mcp
    component: mcp
spec:
  type: NodePort
  selector:
    app: tasmota-mcp
  ports:
    - port: 8000
      targetPort: 8000
      nodePort: 31100
      name: http
