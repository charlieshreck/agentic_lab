apiVersion: v1
kind: ConfigMap
metadata:
  name: neo4j-mcp-code
  namespace: ai-platform
  labels:
    app: neo4j-mcp
data:
  main.py: |
    #!/usr/bin/env python3
    """Neo4j MCP server for knowledge graph operations."""
    import os
    import json
    import logging
    from typing import List, Optional, Dict, Any
    from base64 import b64encode
    import httpx
    from fastmcp import FastMCP
    from pydantic import BaseModel
    from starlette.applications import Starlette
    from starlette.routing import Route, Mount
    from starlette.responses import JSONResponse
    from starlette.requests import Request
    import uvicorn

    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger(__name__)

    NEO4J_URL = os.environ.get("NEO4J_URL", "http://neo4j:7474")
    NEO4J_USER = os.environ.get("NEO4J_USER", "neo4j")
    # Note: Don't strip - Neo4j was initialized with password including trailing newline
    NEO4J_PASSWORD = os.environ.get("NEO4J_PASSWORD", "")

    mcp = FastMCP(
        name="neo4j-mcp",
        instructions="""MCP server for Neo4j knowledge graph operations.
        Use for relationship queries, dependency analysis, impact assessment.
        KEY TOOLS: query_graph, get_entity_context, find_dependencies, get_impact_analysis
        Neo4j: relationships, dependencies. Qdrant: semantic similarity, text search."""
    )

    class QueryResult(BaseModel):
        columns: List[str]
        data: List[List[Any]]
        summary: str = ""

    async def neo4j_query(cypher: str, params: dict = None) -> dict:
        """Execute Cypher query via Neo4j HTTP API."""
        url = f"{NEO4J_URL}/db/neo4j/tx/commit"
        auth = b64encode(f"{NEO4J_USER}:{NEO4J_PASSWORD}".encode()).decode()
        body = {"statements": [{"statement": cypher, "parameters": params or {}}]}
        async with httpx.AsyncClient(timeout=30.0) as client:
            response = await client.post(url, json=body, headers={
                "Content-Type": "application/json",
                "Authorization": f"Basic {auth}"
            })
            return response.json()

    def format_result(result: dict) -> QueryResult:
        if result.get("errors"):
            return QueryResult(columns=[], data=[], summary=f"Error: {result['errors']}")
        results = result.get("results", [])
        if not results:
            return QueryResult(columns=[], data=[], summary="No results")
        first = results[0]
        columns = first.get("columns", [])
        data = [row.get("row", []) for row in first.get("data", [])]
        return QueryResult(columns=columns, data=data, summary=f"Returned {len(data)} rows")

    # Base implementation functions (called by both MCP tools and REST API)
    async def _query_graph_impl(cypher: str) -> QueryResult:
        upper = cypher.upper()
        if any(kw in upper for kw in ["MERGE", "CREATE", "DELETE", "SET", "REMOVE", "DROP"]):
            return QueryResult(columns=[], data=[], summary="Error: Write operations not allowed")
        return format_result(await neo4j_query(cypher))

    @mcp.tool()
    async def query_graph(cypher: str) -> QueryResult:
        """Execute read-only Cypher query. Examples: 'MATCH (h:Host) RETURN h.ip LIMIT 10'"""
        return await _query_graph_impl(cypher)

    async def _get_entity_context_impl(entity_id: str, entity_type: str = "Host") -> dict:
        cypher = f"""
        MATCH (e:{entity_type})
        WHERE e.ip = $id OR e.hostname = $id OR e.mac = $id OR e.name = $id OR e.vmid = $id OR e.title = $id
        WITH e LIMIT 1
        OPTIONAL MATCH (e)-[r]->(related)
        OPTIONAL MATCH (e)<-[r2]-(related2)
        RETURN e, collect(DISTINCT {{type: type(r), target: related.name, target_type: labels(related)[0]}}) as out,
               collect(DISTINCT {{type: type(r2), source: related2.name, source_type: labels(related2)[0]}}) as in
        """
        result = await neo4j_query(cypher, {"id": entity_id})
        if result.get("errors") or not result.get("results", [{}])[0].get("data"):
            return {"id": entity_id, "type": entity_type, "found": False}
        data = result["results"][0]["data"][0]["row"]
        props = data[0] or {}
        out = [r for r in data[1] if r.get("target")]
        inp = [{"direction": "incoming", **r} for r in data[2] if r.get("source")]
        return {"id": entity_id, "type": entity_type, "found": True, "properties": props, "relationships": out + inp}

    @mcp.tool()
    async def get_entity_context(entity_id: str, entity_type: str = "Host") -> dict:
        """Get entity with relationships. entity_id: IP, hostname, MAC, or name."""
        return await _get_entity_context_impl(entity_id, entity_type)

    @mcp.tool()
    async def find_dependencies(service_name: str, depth: int = 2) -> dict:
        """Find upstream/downstream dependencies for a service."""
        up = await neo4j_query(f"MATCH (s:Service {{name: $name}})-[:DEPENDS_ON*1..{depth}]->(d) RETURN DISTINCT d.name, labels(d)[0]", {"name": service_name})
        down = await neo4j_query(f"MATCH (s:Service {{name: $name}})<-[:DEPENDS_ON*1..{depth}]-(d) RETURN DISTINCT d.name, labels(d)[0]", {"name": service_name})
        upstream = [f"{r['row'][1]}:{r['row'][0]}" for r in up.get("results", [{}])[0].get("data", [])]
        downstream = [f"{r['row'][1]}:{r['row'][0]}" for r in down.get("results", [{}])[0].get("data", [])]
        return {"entity": service_name, "upstream": upstream, "downstream": downstream, "depth": depth}

    @mcp.tool()
    async def get_impact_analysis(entity_type: str, entity_id: str) -> dict:
        """What breaks if entity fails? Returns affected services and severity."""
        cypher = """
        MATCH (e) WHERE labels(e)[0] = $type AND (e.ip = $id OR e.hostname = $id OR e.name = $id OR e.vmid = $id)
        OPTIONAL MATCH (e)<-[:SCHEDULED_ON|HOSTS|RUNS*1..3]-(a)
        OPTIONAL MATCH (e)<-[:DEPENDS_ON*1..3]-(s:Service)
        RETURN collect(DISTINCT {name: a.name, type: labels(a)[0]}) as affected,
               collect(DISTINCT {name: s.name, ns: s.namespace}) as services
        """
        result = await neo4j_query(cypher, {"type": entity_type, "id": entity_id})
        if result.get("errors") or not result.get("results", [{}])[0].get("data"):
            return {"entity_type": entity_type, "entity_id": entity_id, "severity": "unknown"}
        data = result["results"][0]["data"][0]["row"]
        affected = [a for a in (data[0] or []) if a.get("name")]
        services = [s for s in (data[1] or []) if s.get("name")]
        total = len(affected) + len(services)
        severity = "low" if total == 0 else "medium" if total < 5 else "high" if total < 15 else "critical"
        return {"entity_type": entity_type, "entity_id": entity_id, "affected": affected, "services": services, "severity": severity}

    @mcp.tool()
    async def find_path(from_entity: str, to_entity: str, max_depth: int = 5) -> dict:
        """Find connection path between two entities."""
        cypher = f"""
        MATCH (f), (t) WHERE (f.ip = $from OR f.hostname = $from OR f.name = $from)
          AND (t.ip = $to OR t.hostname = $to OR t.name = $to)
        MATCH path = shortestPath((f)-[*1..{max_depth}]-(t))
        RETURN [n IN nodes(path) | {{name: n.name, type: labels(n)[0]}}] as nodes,
               [r IN relationships(path) | type(r)] as rels LIMIT 1
        """
        result = await neo4j_query(cypher, {"from": from_entity, "to": to_entity})
        if result.get("errors") or not result.get("results", [{}])[0].get("data"):
            return {"found": False, "from": from_entity, "to": to_entity}
        data = result["results"][0]["data"][0]["row"]
        return {"found": True, "from": from_entity, "to": to_entity, "nodes": data[0], "relationships": data[1]}

    @mcp.tool()
    async def get_runbook_for_alert(alert_name: str) -> List[dict]:
        """Find runbooks that resolve an alert."""
        cypher = """
        MATCH (r:RunbookDocument)-[:RESOLVES]->(a:Alert)
        WHERE a.name =~ ('(?i).*' + $pattern + '.*')
        RETURN r.title, r.path, r.automation_level, a.name LIMIT 10
        """
        result = await neo4j_query(cypher, {"pattern": alert_name})
        if result.get("errors") or not result.get("results", [{}])[0].get("data"):
            return []
        return [{"title": r["row"][0], "path": r["row"][1], "automation": r["row"][2], "alert": r["row"][3]}
                for r in result["results"][0]["data"]]

    async def _get_infrastructure_overview_impl() -> dict:
        overview = {}
        # Query each entity type separately
        queries = [
            ("hosts", "MATCH (h:Host) RETURN count(h) as total, sum(CASE WHEN h.status='online' THEN 1 ELSE 0 END) as online"),
            ("vms", "MATCH (v:VM) RETURN count(v) as total, sum(CASE WHEN v.status='running' THEN 1 ELSE 0 END) as online"),
            ("services", "MATCH (s:Service) RETURN count(s) as total, count(s) as online"),
            ("pods", "MATCH (p:Pod) RETURN count(p) as total, sum(CASE WHEN p.phase='Running' THEN 1 ELSE 0 END) as online"),
            ("networks", "MATCH (n:Network) RETURN count(n) as total, count(n) as online"),
        ]
        for label, cypher in queries:
            result = await neo4j_query(cypher)
            if not result.get("errors") and result.get("results", [{}])[0].get("data"):
                row = result["results"][0]["data"][0]["row"]
                overview[label] = {"total": row[0] or 0, "online": row[1] or 0}
            else:
                overview[label] = {"total": 0, "online": 0}
        return overview

    @mcp.tool()
    async def get_infrastructure_overview() -> dict:
        """High-level infrastructure overview."""
        return await _get_infrastructure_overview_impl()

    @mcp.tool()
    async def get_hosts_on_network(network: str) -> List[dict]:
        """Get hosts connected to a network (prod, agentic, monitoring)."""
        cypher = """
        MATCH (h:Host)-[:CONNECTED_TO]->(n:Network {name: $network})
        RETURN h.ip, h.hostname, h.mac, h.status, h.type ORDER BY h.ip
        """
        result = await neo4j_query(cypher, {"network": network})
        if result.get("errors") or not result.get("results", [{}])[0].get("data"):
            return []
        return [{"ip": r["row"][0], "hostname": r["row"][1], "mac": r["row"][2], "status": r["row"][3], "type": r["row"][4]}
                for r in result["results"][0]["data"]]

    @mcp.tool()
    async def get_services_on_host(host_id: str) -> List[dict]:
        """Get services/pods running on a host."""
        cypher = """
        MATCH (h:Host) WHERE h.ip = $id OR h.hostname = $id
        OPTIONAL MATCH (p:Pod)-[:SCHEDULED_ON]->(h)
        OPTIONAL MATCH (s:Service)-[:EXPOSES]->(p)
        RETURN p.name, p.namespace, p.phase, collect(DISTINCT s.name)
        """
        result = await neo4j_query(cypher, {"id": host_id})
        if result.get("errors") or not result.get("results", [{}])[0].get("data"):
            return []
        return [{"pod": r["row"][0], "namespace": r["row"][1], "phase": r["row"][2], "services": r["row"][3]}
                for r in result["results"][0]["data"] if r["row"][0]]

    @mcp.tool()
    async def find_orphan_entities(entity_type: str = None) -> List[dict]:
        """Find entities with no relationships (potentially stale)."""
        type_filter = f":{entity_type}" if entity_type else ""
        cypher = f"MATCH (e{type_filter}) WHERE NOT (e)--() RETURN e.ip, e.name, labels(e)[0], e.last_seen LIMIT 50"
        result = await neo4j_query(cypher)
        if result.get("errors") or not result.get("results", [{}])[0].get("data"):
            return []
        return [{"ip": r["row"][0], "name": r["row"][1], "type": r["row"][2], "last_seen": r["row"][3]}
                for r in result["results"][0]["data"]]

    @mcp.tool()
    async def get_stale_entities(hours: int = 24) -> List[dict]:
        """Find entities not seen in specified hours."""
        cypher = """
        MATCH (h:Host) WHERE h.last_seen < datetime() - duration({hours: $hours})
        RETURN h.ip, h.hostname, h.status, h.last_seen LIMIT 50
        """
        result = await neo4j_query(cypher, {"hours": hours})
        if result.get("errors") or not result.get("results", [{}])[0].get("data"):
            return []
        return [{"ip": r["row"][0], "hostname": r["row"][1], "status": r["row"][2], "last_seen": r["row"][3]}
                for r in result["results"][0]["data"]]

    # REST API endpoints
    async def rest_health(request: Request):
        try:
            result = await neo4j_query("RETURN 1 as test")
            ok = not result.get("errors")
        except:
            ok = False
        return JSONResponse({"status": "healthy" if ok else "degraded", "neo4j": "connected" if ok else "unreachable"})

    async def rest_query(request: Request):
        try:
            cypher = request.query_params.get("q", "")
            if not cypher:
                return JSONResponse({"error": "Missing 'q' parameter"}, status_code=400)
            result = await _query_graph_impl(cypher)
            return JSONResponse({"status": "ok", "columns": result.columns, "data": result.data})
        except Exception as e:
            return JSONResponse({"error": str(e)}, status_code=500)

    async def rest_entity(request: Request):
        try:
            entity_id = request.query_params.get("id", "")
            entity_type = request.query_params.get("type", "Host")
            if not entity_id:
                return JSONResponse({"error": "Missing 'id' parameter"}, status_code=400)
            return JSONResponse(await _get_entity_context_impl(entity_id, entity_type))
        except Exception as e:
            return JSONResponse({"error": str(e)}, status_code=500)

    async def rest_overview(request: Request):
        try:
            return JSONResponse(await _get_infrastructure_overview_impl())
        except Exception as e:
            return JSONResponse({"error": str(e)}, status_code=500)

    async def rest_write(request: Request):
        """Execute write Cypher query (for enrichment jobs only)."""
        try:
            body = await request.json()
            cypher = body.get("cypher", "")
            if not cypher:
                return JSONResponse({"error": "Missing 'cypher' in body"}, status_code=400)
            result = await neo4j_query(cypher)
            if result.get("errors"):
                return JSONResponse({"status": "error", "errors": result["errors"]}, status_code=400)
            stats = result.get("results", [{}])[0].get("stats", {})
            return JSONResponse({"status": "ok", "stats": stats})
        except Exception as e:
            return JSONResponse({"error": str(e)}, status_code=500)

    async def rest_relationship_graph(request: Request):
        """Get entity with all relationships for visualization (spider graph)."""
        try:
            entity_id = request.query_params.get("id", "")
            entity_type = request.query_params.get("type", "Host")
            depth = int(request.query_params.get("depth", "2"))
            if not entity_id:
                return JSONResponse({"error": "Missing 'id' parameter"}, status_code=400)

            # Get all connected nodes up to specified depth
            cypher = f"""
            MATCH (e:{entity_type})
            WHERE e.ip = $id OR e.hostname = $id OR e.name = $id OR e.title = $id OR e.vmid = $id
            WITH e LIMIT 1
            CALL {{
                WITH e
                MATCH path = (e)-[*1..{depth}]-(connected)
                RETURN e, connected, relationships(path) as rels
            }}
            WITH e, collect(DISTINCT connected) as nodes, collect(rels) as all_rels
            RETURN e as center,
                   [n IN nodes | {{
                       id: coalesce(n.ip, n.name, n.title, toString(n.vmid)),
                       name: coalesce(n.hostname, n.name, n.title),
                       type: labels(n)[0]
                   }}] as nodes,
                   [r IN apoc.coll.flatten(all_rels) | {{
                       source: coalesce(startNode(r).ip, startNode(r).name, startNode(r).title),
                       target: coalesce(endNode(r).ip, endNode(r).name, endNode(r).title),
                       type: type(r)
                   }}] as edges
            """
            result = await neo4j_query(cypher, {"id": entity_id})

            # Fallback if APOC not available OR primary query returns empty (CALL subquery may not work via HTTP)
            primary_results = result.get("results", [])
            primary_data = primary_results[0].get("data", []) if primary_results else []
            if result.get("errors") or not primary_data:
                cypher = f"""
                MATCH (e:{entity_type})
                WHERE e.ip = $id OR e.hostname = $id OR e.name = $id OR e.title = $id
                WITH e LIMIT 1
                OPTIONAL MATCH path = (e)-[*1..{depth}]-(connected)
                WITH e, path, connected
                UNWIND CASE WHEN path IS NOT NULL THEN relationships(path) ELSE [null] END as r
                WITH e,
                     collect(DISTINCT connected) as allNodes,
                     collect(DISTINCT r) as allRels
                RETURN e as center,
                       [n IN allNodes WHERE n IS NOT NULL | {{
                           id: coalesce(n.ip, n.name, n.title, toString(n.vmid)),
                           name: coalesce(n.hostname, n.name, n.title),
                           type: labels(n)[0]
                       }}] as nodes,
                       [rel IN allRels WHERE rel IS NOT NULL | {{
                           source: coalesce(startNode(rel).ip, startNode(rel).name, startNode(rel).title),
                           target: coalesce(endNode(rel).ip, endNode(rel).name, endNode(rel).title),
                           type: type(rel)
                       }}] as edges
                """
                result = await neo4j_query(cypher, {"id": entity_id})

            # Safely check for valid results
            results = result.get("results", [])
            if result.get("errors") or not results or not results[0].get("data"):
                return JSONResponse({"error": "Entity not found", "id": entity_id}, status_code=404)

            data = results[0]["data"][0]["row"]
            center_props = data[0] or {}
            nodes = [n for n in (data[1] or []) if n.get("id")]
            edges = [e for e in (data[2] or []) if e.get("source") and e.get("target")]

            # Add center node to nodes list
            center_node = {
                "id": entity_id,
                "name": center_props.get("hostname") or center_props.get("name") or center_props.get("title") or entity_id,
                "type": entity_type,
                "isCenter": True
            }

            return JSONResponse({
                "center": center_node,
                "nodes": [center_node] + nodes,
                "edges": edges
            })
        except Exception as e:
            logger.error(f"Graph query failed: {e}")
            return JSONResponse({"error": str(e)}, status_code=500)

    def main():
        port = int(os.environ.get("PORT", "8000"))
        logger.info(f"Starting neo4j-mcp on port {port}")
        logger.info(f"Neo4j URL: {NEO4J_URL}")

        rest_routes = [
            Route("/health", rest_health, methods=["GET"]),
            Route("/api/query", rest_query, methods=["GET"]),
            Route("/api/entity", rest_entity, methods=["GET"]),
            Route("/api/overview", rest_overview, methods=["GET"]),
            Route("/api/write", rest_write, methods=["POST"]),
            Route("/api/graph", rest_relationship_graph, methods=["GET"]),
        ]

        mcp_app = mcp.http_app()
        app = Starlette(routes=rest_routes + [Mount("/", app=mcp_app)], lifespan=mcp_app.lifespan)
        uvicorn.run(app, host="0.0.0.0", port=port)

    if __name__ == "__main__":
        main()

  requirements.txt: |
    fastmcp>=2.7.0
    pydantic>=2.11.0
    httpx>=0.28.0
    uvicorn>=0.34.0
    starlette>=0.40.0
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: neo4j-mcp
  namespace: ai-platform
  labels:
    app: neo4j-mcp
    component: mcp
spec:
  replicas: 1
  selector:
    matchLabels:
      app: neo4j-mcp
  template:
    metadata:
      labels:
        app: neo4j-mcp
        component: mcp
    spec:
      initContainers:
        - name: install-deps
          image: python:3.11-slim
          command: ['sh', '-c', 'pip install --target=/app/deps -r /code/requirements.txt']
          volumeMounts:
            - name: code
              mountPath: /code
            - name: deps
              mountPath: /app/deps
      containers:
        - name: mcp-server
          image: python:3.11-slim
          command: ['sh', '-c', 'cd /app && PYTHONPATH=/app/deps python /code/main.py']
          ports:
            - containerPort: 8000
              name: http
          env:
            - name: PORT
              value: "8000"
            - name: NEO4J_URL
              value: "http://neo4j:7474"
            - name: NEO4J_USER
              value: "neo4j"
            - name: NEO4J_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: neo4j-credentials
                  key: NEO4J_PASSWORD
          volumeMounts:
            - name: code
              mountPath: /code
            - name: deps
              mountPath: /app/deps
          resources:
            requests:
              memory: "128Mi"
              cpu: "100m"
            limits:
              memory: "256Mi"
              cpu: "500m"
          readinessProbe:
            httpGet:
              path: /health
              port: 8000
            initialDelaySeconds: 30
            periodSeconds: 10
            timeoutSeconds: 5
          livenessProbe:
            httpGet:
              path: /health
              port: 8000
            initialDelaySeconds: 60
            periodSeconds: 30
            timeoutSeconds: 5
      volumes:
        - name: code
          configMap:
            name: neo4j-mcp-code
        - name: deps
          emptyDir: {}
---
apiVersion: v1
kind: Service
metadata:
  name: neo4j-mcp
  namespace: ai-platform
  labels:
    app: neo4j-mcp
    component: mcp
spec:
  type: NodePort
  selector:
    app: neo4j-mcp
  ports:
    - port: 8000
      targetPort: 8000
      nodePort: 31098
      name: http
