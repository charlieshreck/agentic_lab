apiVersion: v1
kind: ConfigMap
metadata:
  name: browser-automation-mcp-code
  namespace: ai-platform
  labels:
    app: browser-automation-mcp
data:
  main.py: |
    #!/usr/bin/env python3
    """Browser Automation MCP server using Playwright."""
    import os
    import base64
    import logging
    import asyncio
    from typing import Optional, Dict, List
    from datetime import datetime
    from contextlib import asynccontextmanager
    from fastmcp import FastMCP
    from pydantic import BaseModel
    from starlette.applications import Starlette
    from starlette.routing import Route, Mount
    from starlette.responses import JSONResponse, Response
    from starlette.requests import Request
    import uvicorn

    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger(__name__)

    BROWSER_TYPE = os.environ.get("BROWSER_TYPE", "chromium")
    HEADLESS = os.environ.get("HEADLESS", "true").lower() == "true"
    DEFAULT_TIMEOUT = int(os.environ.get("DEFAULT_TIMEOUT", "30000"))
    VIEWPORT_WIDTH = int(os.environ.get("VIEWPORT_WIDTH", "1920"))
    VIEWPORT_HEIGHT = int(os.environ.get("VIEWPORT_HEIGHT", "1080"))

    mcp = FastMCP(
        name="browser-automation-mcp",
        instructions="MCP server for browser automation. Navigate pages, take screenshots, click elements, type text."
    )

    class NavigateResult(BaseModel):
        url: str
        title: str
        status: int
        load_time_ms: int

    class Screenshot(BaseModel):
        data: str
        width: int
        height: int
        timestamp: str

    class ActionResult(BaseModel):
        success: bool
        message: str
        timestamp: str

    class PageContent(BaseModel):
        url: str
        title: str
        html: Optional[str] = None
        text: Optional[str] = None
        word_count: int

    class BrowserManager:
        def __init__(self):
            self.playwright = None
            self.browser = None
            self.context = None
            self.page = None
            self._lock = asyncio.Lock()

        async def ensure_browser(self):
            async with self._lock:
                if self.page is None or self.page.is_closed():
                    await self._start_browser()
                return self.page

        async def _start_browser(self):
            from playwright.async_api import async_playwright
            if self.playwright is None:
                self.playwright = await async_playwright().start()
            browser_launcher = getattr(self.playwright, BROWSER_TYPE)
            self.browser = await browser_launcher.launch(headless=HEADLESS)
            self.context = await self.browser.new_context(
                viewport={"width": VIEWPORT_WIDTH, "height": VIEWPORT_HEIGHT},
                user_agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
            )
            self.page = await self.context.new_page()
            self.page.set_default_timeout(DEFAULT_TIMEOUT)
            logger.info(f"Browser started: {BROWSER_TYPE}, headless={HEADLESS}")

        async def close(self):
            async with self._lock:
                if self.page: await self.page.close()
                if self.context: await self.context.close()
                if self.browser: await self.browser.close()
                if self.playwright: await self.playwright.stop()
                self.page = self.context = self.browser = self.playwright = None

    browser_manager = BrowserManager()

    @mcp.tool()
    async def navigate(url: str, wait_until: str = "networkidle") -> NavigateResult:
        """Navigate browser to a URL."""
        page = await browser_manager.ensure_browser()
        start = datetime.utcnow()
        try:
            resp = await page.goto(url, wait_until=wait_until)
            return NavigateResult(url=page.url, title=await page.title(),
                                 status=resp.status if resp else 0,
                                 load_time_ms=int((datetime.utcnow()-start).total_seconds()*1000))
        except Exception as e:
            logger.error(f"Navigate failed: {e}")
            return NavigateResult(url=url, title="", status=0, load_time_ms=0)

    @mcp.tool()
    async def screenshot(full_page: bool = False) -> Screenshot:
        """Take a screenshot of current page."""
        page = await browser_manager.ensure_browser()
        try:
            data = base64.b64encode(await page.screenshot(full_page=full_page, type="png")).decode()
            vp = page.viewport_size
            return Screenshot(data=data, width=vp["width"] if vp else VIEWPORT_WIDTH,
                            height=vp["height"] if vp else VIEWPORT_HEIGHT,
                            timestamp=datetime.utcnow().isoformat())
        except Exception as e:
            logger.error(f"Screenshot failed: {e}")
            return Screenshot(data="", width=0, height=0, timestamp=datetime.utcnow().isoformat())

    @mcp.tool()
    async def click(selector: str) -> ActionResult:
        """Click element by CSS selector."""
        page = await browser_manager.ensure_browser()
        try:
            await page.click(selector)
            return ActionResult(success=True, message=f"Clicked: {selector}", timestamp=datetime.utcnow().isoformat())
        except Exception as e:
            return ActionResult(success=False, message=str(e), timestamp=datetime.utcnow().isoformat())

    @mcp.tool()
    async def click_coordinates(x: int, y: int) -> ActionResult:
        """Click at screen coordinates."""
        page = await browser_manager.ensure_browser()
        try:
            await page.mouse.click(x, y)
            return ActionResult(success=True, message=f"Clicked ({x},{y})", timestamp=datetime.utcnow().isoformat())
        except Exception as e:
            return ActionResult(success=False, message=str(e), timestamp=datetime.utcnow().isoformat())

    @mcp.tool()
    async def type_text(selector: str, text: str, clear_first: bool = True) -> ActionResult:
        """Type text into input element."""
        page = await browser_manager.ensure_browser()
        try:
            if clear_first: await page.fill(selector, text)
            else: await page.type(selector, text)
            return ActionResult(success=True, message=f"Typed into: {selector}", timestamp=datetime.utcnow().isoformat())
        except Exception as e:
            return ActionResult(success=False, message=str(e), timestamp=datetime.utcnow().isoformat())

    @mcp.tool()
    async def press_key(key: str) -> ActionResult:
        """Press keyboard key (Enter, Tab, Escape, Control+a, etc.)."""
        page = await browser_manager.ensure_browser()
        try:
            await page.keyboard.press(key)
            return ActionResult(success=True, message=f"Pressed: {key}", timestamp=datetime.utcnow().isoformat())
        except Exception as e:
            return ActionResult(success=False, message=str(e), timestamp=datetime.utcnow().isoformat())

    @mcp.tool()
    async def scroll(direction: str = "down", amount: int = 500) -> ActionResult:
        """Scroll page (up/down/left/right)."""
        page = await browser_manager.ensure_browser()
        try:
            dx, dy = 0, 0
            if direction == "down": dy = amount
            elif direction == "up": dy = -amount
            elif direction == "right": dx = amount
            elif direction == "left": dx = -amount
            await page.mouse.wheel(dx, dy)
            return ActionResult(success=True, message=f"Scrolled {direction}", timestamp=datetime.utcnow().isoformat())
        except Exception as e:
            return ActionResult(success=False, message=str(e), timestamp=datetime.utcnow().isoformat())

    @mcp.tool()
    async def get_page_content(include_html: bool = False) -> PageContent:
        """Get current page content."""
        page = await browser_manager.ensure_browser()
        try:
            text = await page.inner_text("body")
            html = await page.content() if include_html else None
            return PageContent(url=page.url, title=await page.title(), html=html, text=text, word_count=len(text.split()))
        except Exception as e:
            return PageContent(url="", title="", text=str(e), word_count=0)

    @mcp.tool()
    async def evaluate_js(script: str) -> dict:
        """Execute JavaScript on page."""
        page = await browser_manager.ensure_browser()
        try:
            result = await page.evaluate(script)
            return {"success": True, "result": result}
        except Exception as e:
            return {"success": False, "error": str(e)}

    @mcp.tool()
    async def wait_for_selector(selector: str, timeout: int = 30000, state: str = "visible") -> ActionResult:
        """Wait for element to appear."""
        page = await browser_manager.ensure_browser()
        try:
            await page.wait_for_selector(selector, timeout=timeout, state=state)
            return ActionResult(success=True, message=f"Found: {selector}", timestamp=datetime.utcnow().isoformat())
        except Exception as e:
            return ActionResult(success=False, message=str(e), timestamp=datetime.utcnow().isoformat())

    @mcp.tool()
    async def fill_form(fields: Dict[str, str]) -> ActionResult:
        """Fill multiple form fields."""
        page = await browser_manager.ensure_browser()
        try:
            for selector, value in fields.items():
                await page.fill(selector, value)
            return ActionResult(success=True, message=f"Filled {len(fields)} fields", timestamp=datetime.utcnow().isoformat())
        except Exception as e:
            return ActionResult(success=False, message=str(e), timestamp=datetime.utcnow().isoformat())

    @mcp.tool()
    async def get_element_text(selector: str) -> str:
        """Get text content of element."""
        page = await browser_manager.ensure_browser()
        try:
            return await page.inner_text(selector)
        except Exception as e:
            return f"Error: {e}"

    @mcp.tool()
    async def get_all_links() -> List[Dict[str, str]]:
        """Get all links on page."""
        page = await browser_manager.ensure_browser()
        try:
            return await page.evaluate("() => Array.from(document.querySelectorAll('a[href]')).map(a => ({href: a.href, text: a.innerText.trim().substring(0,100)}))")
        except:
            return []

    @mcp.tool()
    async def go_back() -> ActionResult:
        """Navigate back in history."""
        page = await browser_manager.ensure_browser()
        try:
            await page.go_back()
            return ActionResult(success=True, message="Navigated back", timestamp=datetime.utcnow().isoformat())
        except Exception as e:
            return ActionResult(success=False, message=str(e), timestamp=datetime.utcnow().isoformat())

    @mcp.tool()
    async def reload_page() -> ActionResult:
        """Reload current page."""
        page = await browser_manager.ensure_browser()
        try:
            await page.reload()
            return ActionResult(success=True, message="Reloaded", timestamp=datetime.utcnow().isoformat())
        except Exception as e:
            return ActionResult(success=False, message=str(e), timestamp=datetime.utcnow().isoformat())

    async def rest_health(request: Request):
        return JSONResponse({"status": "healthy"})

    async def rest_api_screenshot(request: Request):
        try:
            page = await browser_manager.ensure_browser()
            return Response(content=await page.screenshot(type="png"), media_type="image/png")
        except Exception as e:
            return JSONResponse({"error": str(e)}, status_code=500)

    async def rest_api_page_info(request: Request):
        try:
            page = await browser_manager.ensure_browser()
            return JSONResponse({"url": page.url, "title": await page.title(), "viewport": page.viewport_size})
        except Exception as e:
            return JSONResponse({"error": str(e)}, status_code=500)

    def main():
        port = int(os.environ.get("PORT", "8000"))
        logger.info(f"Starting Browser Automation MCP on port {port}")
        routes = [
            Route("/health", rest_health, methods=["GET"]),
            Route("/api/screenshot", rest_api_screenshot, methods=["GET"]),
            Route("/api/page", rest_api_page_info, methods=["GET"]),
        ]
        mcp_app = mcp.http_app()

        @asynccontextmanager
        async def combined_lifespan(app):
            async with mcp_app.lifespan(app):
                yield
            await browser_manager.close()

        app = Starlette(routes=routes + [Mount("/", app=mcp_app)], lifespan=combined_lifespan)
        uvicorn.run(app, host="0.0.0.0", port=port)

    if __name__ == "__main__":
        main()

  requirements.txt: |
    fastmcp>=2.7.0
    pydantic>=2.11.0
    uvicorn>=0.34.0
    starlette>=0.40.0
    httpx>=0.28.0
    playwright>=1.49.0
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: browser-automation-mcp
  namespace: ai-platform
  labels:
    app: browser-automation-mcp
    component: mcp
spec:
  replicas: 1
  selector:
    matchLabels:
      app: browser-automation-mcp
  template:
    metadata:
      labels:
        app: browser-automation-mcp
        component: mcp
    spec:
      initContainers:
        - name: install-deps
          image: mcr.microsoft.com/playwright/python:v1.49.0-jammy
          command:
            - sh
            - -c
            - |
              pip install --target=/app/deps -r /code/requirements.txt
          volumeMounts:
            - name: code
              mountPath: /code
            - name: deps
              mountPath: /app/deps
      containers:
        - name: mcp-server
          image: mcr.microsoft.com/playwright/python:v1.49.0-jammy
          command:
            - sh
            - -c
            - |
              cd /app && PYTHONPATH=/app/deps python /code/main.py
          ports:
            - containerPort: 8000
              name: http
          env:
            - name: PORT
              value: "8000"
            - name: BROWSER_TYPE
              value: "chromium"
            - name: HEADLESS
              value: "true"
            - name: VIEWPORT_WIDTH
              value: "1920"
            - name: VIEWPORT_HEIGHT
              value: "1080"
            - name: DEFAULT_TIMEOUT
              value: "30000"
          volumeMounts:
            - name: code
              mountPath: /code
            - name: deps
              mountPath: /app/deps
          resources:
            requests:
              memory: "512Mi"
              cpu: "100m"
            limits:
              memory: "2Gi"
              cpu: "2000m"
          readinessProbe:
            httpGet:
              path: /health
              port: 8000
            initialDelaySeconds: 60
            periodSeconds: 10
          livenessProbe:
            httpGet:
              path: /health
              port: 8000
            initialDelaySeconds: 90
            periodSeconds: 30
      volumes:
        - name: code
          configMap:
            name: browser-automation-mcp-code
        - name: deps
          emptyDir: {}
---
apiVersion: v1
kind: Service
metadata:
  name: browser-automation-mcp
  namespace: ai-platform
  labels:
    app: browser-automation-mcp
    component: mcp
spec:
  type: NodePort
  selector:
    app: browser-automation-mcp
  ports:
    - port: 8000
      targetPort: 8000
      nodePort: 31094
      name: http
