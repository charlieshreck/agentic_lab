apiVersion: v1
kind: ConfigMap
metadata:
  name: incident-db-schema
  namespace: ai-platform
  labels:
    app: incident-db
data:
  init.sh: |
    #!/bin/sh
    set -e

    echo "=== Incident DB Init ==="

    # Create database if it doesn't exist
    psql -h "$PGHOST" -U "$PGUSER" -d postgres -tc \
      "SELECT 1 FROM pg_database WHERE datname='incident_management'" \
      | grep -q 1 || \
      psql -h "$PGHOST" -U "$PGUSER" -d postgres -c \
        "CREATE DATABASE incident_management"

    echo "Database incident_management ready"

    # Run schema migration
    psql -h "$PGHOST" -U "$PGUSER" -d incident_management -f /sql/schema.sql

    echo "=== Schema migration complete ==="

  schema.sql: |
    -- Incident Management Schema v1
    -- Kernow Autonomous Operations (KAO)

    -- Incidents: core table for all detected incidents
    CREATE TABLE IF NOT EXISTS incidents (
      id              SERIAL PRIMARY KEY,
      external_id     TEXT UNIQUE,
      status          TEXT NOT NULL DEFAULT 'detected'
                        CHECK (status IN (
                          'detected', 'investigating', 'awaiting_review',
                          'executing', 'resolved', 'closed', 'false_positive'
                        )),
      severity        TEXT NOT NULL DEFAULT 'warning'
                        CHECK (severity IN ('critical', 'warning', 'info')),
      source          TEXT NOT NULL,
      alert_name      TEXT NOT NULL,
      description     TEXT DEFAULT '',
      fingerprint     TEXT,

      -- Enrichment data from Coroot, metrics, entities, runbooks
      enrichment      JSONB DEFAULT '{}',

      -- Claude screen session management
      screen_session  TEXT,
      model_used      TEXT DEFAULT 'haiku',

      -- Resolution
      resolution_type TEXT
                        CHECK (resolution_type IN (
                          'automated', 'manual', 'false_positive', 'escalated', NULL
                        )),
      resolution_summary TEXT,
      runbook_id      TEXT,
      lessons_learned JSONB DEFAULT '{}',

      -- Raw data
      raw_payload     JSONB DEFAULT '{}',
      labels          JSONB DEFAULT '{}',

      -- Grouped alerts (multi-incident correlation)
      grouped_alerts  JSONB DEFAULT '[]',

      -- Timestamps
      detected_at     TIMESTAMPTZ NOT NULL DEFAULT NOW(),
      updated_at      TIMESTAMPTZ NOT NULL DEFAULT NOW(),
      resolved_at     TIMESTAMPTZ,
      closed_at       TIMESTAMPTZ,
      close_scheduled_at TIMESTAMPTZ
    );

    -- Incident transitions: audit trail for all status changes
    CREATE TABLE IF NOT EXISTS incident_transitions (
      id            SERIAL PRIMARY KEY,
      incident_id   INTEGER NOT NULL REFERENCES incidents(id) ON DELETE CASCADE,
      from_status   TEXT,
      to_status     TEXT NOT NULL,
      actor         TEXT NOT NULL DEFAULT 'system',
      note          TEXT,
      created_at    TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );

    -- Runbook usage: track which runbooks were used for which incidents
    CREATE TABLE IF NOT EXISTS runbook_usage (
      id              SERIAL PRIMARY KEY,
      runbook_id      TEXT NOT NULL,
      incident_id     INTEGER NOT NULL REFERENCES incidents(id) ON DELETE CASCADE,
      match_type      TEXT NOT NULL CHECK (match_type IN ('EXACT', 'SIMILAR', 'NO_MATCH')),
      confidence      REAL DEFAULT 0.0,
      success         BOOLEAN,
      model_used      TEXT,
      time_to_resolve INTEGER,
      created_at      TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );

    -- FP patterns: learned false positive patterns for auto-suppression
    CREATE TABLE IF NOT EXISTS fp_patterns (
      id              SERIAL PRIMARY KEY,
      alert_pattern   TEXT NOT NULL,
      source          TEXT NOT NULL,
      reason          TEXT,
      suppress_until  TIMESTAMPTZ,
      occurrences     INTEGER DEFAULT 1,
      created_at      TIMESTAMPTZ NOT NULL DEFAULT NOW(),
      updated_at      TIMESTAMPTZ NOT NULL DEFAULT NOW(),
      UNIQUE (alert_pattern, source)
    );

    -- Indexes
    CREATE INDEX IF NOT EXISTS idx_incidents_status ON incidents(status);
    CREATE INDEX IF NOT EXISTS idx_incidents_detected_at ON incidents(detected_at DESC);
    CREATE INDEX IF NOT EXISTS idx_incidents_external_id ON incidents(external_id);
    CREATE INDEX IF NOT EXISTS idx_incidents_fingerprint ON incidents(fingerprint);
    CREATE INDEX IF NOT EXISTS idx_incidents_source ON incidents(source);
    CREATE INDEX IF NOT EXISTS idx_incident_transitions_incident ON incident_transitions(incident_id);
    CREATE INDEX IF NOT EXISTS idx_runbook_usage_runbook ON runbook_usage(runbook_id);
    CREATE INDEX IF NOT EXISTS idx_runbook_usage_incident ON runbook_usage(incident_id);
    CREATE INDEX IF NOT EXISTS idx_fp_patterns_alert ON fp_patterns(alert_pattern, source);

    -- Auto-update updated_at trigger
    CREATE OR REPLACE FUNCTION update_updated_at()
    RETURNS TRIGGER AS $$
    BEGIN
      NEW.updated_at = NOW();
      RETURN NEW;
    END;
    $$ LANGUAGE plpgsql;

    DROP TRIGGER IF EXISTS incidents_updated_at ON incidents;
    CREATE TRIGGER incidents_updated_at
      BEFORE UPDATE ON incidents
      FOR EACH ROW EXECUTE FUNCTION update_updated_at();

    DROP TRIGGER IF EXISTS fp_patterns_updated_at ON fp_patterns;
    CREATE TRIGGER fp_patterns_updated_at
      BEFORE UPDATE ON fp_patterns
      FOR EACH ROW EXECUTE FUNCTION update_updated_at();
